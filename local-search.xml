<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>载具的物理同步方案</title>
    <link href="/posts/undefined/"/>
    <url>/posts/undefined/</url>
    
    <content type="html"><![CDATA[<h2 id="1-载具的物理模拟"><a href="#1-载具的物理模拟" class="headerlink" title="1. 载具的物理模拟"></a>1. 载具的物理模拟</h2><p>游戏中经常被使用的载具种类有很多，如汽车、摩托、船艇和飞机等。其中，汽车是最为常见的载具。在没有特别说明的前提下，载具通常默认表示汽车。</p><p>当然，无论是哪种载具，其在现实世界中的运动状态都很复杂。如何对载具的运动状态进行合理的简化和解耦，建立合适的<code>物理模拟模型</code>，让玩家能感受到真实的物理效果，对载具的物理模拟至关重要。</p><p>以游戏中最常见的汽车为例，为了最大程度还原真实的驾驶体验，需要模拟在通过障碍物时悬挂的缓冲效果、踩下油门之后引擎驱动汽车的加速效果，以及转动方向盘时控制轮胎朝向的转向效果。</p><p>一般来说，不同物理引擎上的汽车物理模拟都大同小异，可大致抽象为如下所示的流程：</p><p><img src="https://blog-images-1253364479.cos.ap-guangzhou.myqcloud.com/Image.png" alt="Image"></p><hr><h2 id="2-载具物理同步的难点"><a href="#2-载具物理同步的难点" class="headerlink" title="2. 载具物理同步的难点"></a>2. 载具物理同步的难点</h2><p>与大部分游戏场景中的需要进行物理同步的物体相比，载具的运动状态更为复杂，网络同步的难度更高，其主要难点体现在以下几个方面：</p><ol><li><code>移动速度快</code>：载具在游戏中最主要的作用就是提高玩家所操纵角色的移动速度，因此载具的运动速度在大部分情况下都很快，即便是细微的网络延迟都会造成很大的误差；</li><li><code>物理交互多</code>：玩家在驾驶载具时可能会频繁与场景中的其他物体发生碰撞、摩擦或者挤压等物理交互。而这些物理交互都会导致载具的<code>运动状态（速度大小、方向，以及朝向）</code>发生剧烈改变，进一步加大了物理同步的难度；</li><li><code>质量要求高</code>：载具的运动轨迹是平滑的曲线，对物理同步质量的要求更高。<code>频繁拉扯</code>所形成的不自然轨迹会立刻引起玩家注意，影响玩家的游戏体验；</li><li><code>输入预测难</code>：从<code>1. 载具的物理模拟流程</code>一节中不难知道，载具的运动状态很大程度上由输入数据决定。而输入数据来自于玩家的操作，其变化很难预测，其对载具运动状态所造成的变化自然也就很难预测；</li></ol><hr><h2 id="3-载具物理同步方案"><a href="#3-载具物理同步方案" class="headerlink" title="3. 载具物理同步方案"></a>3. 载具物理同步方案</h2><p>物理同步的基本思路是<code>预测+纠错</code>。载具也是如此。只是与普通物体相比有以下几个区别：</p><ol><li>载具的运动状态由<code>当前的运动状态</code>和<code>输入数据</code>一起决定，仅同步载具的运动状态无法满足预测的要求；</li><li>玩家在操作载具时，客户端上的输入数据要立刻生效，否则网络传输带来的输入延迟会极大地影响玩家的操作体验；</li></ol><p>为了满足上面的限制，最简单直接的方案是，<code>主控端</code>直接使用输入数据修改载具的运动状态，然后将输入数据发给服务器，再由服务器广播给其他<code>模拟端</code>，并在<code>服务器</code>和<code>模拟端</code>上分别使用输入数据修改载具的运动状态。最后，再通过物理同步的方式，纠正不确定性物理引擎在模拟过程中的差异。</p><p><img src="https://blog-images-1253364479.cos.ap-guangzhou.myqcloud.com/Image(1).png" alt="Image(1)"></p><blockquote><p>红色虚线的圆圈表示服务器同步过来的运动状态，绿色虚线的圆圈表示在相同时刻下服务器的预测结果，而黑色实线的圆圈则表示当前的运动状态。</p></blockquote><p>从上图可以看到，为了满足输入数据立刻生效的要求，载具在服务器上的运动状态一定是滞后于主控端的。此时，当服务器给主控端下发运动状态并尝试进行物理同步时，主控端既要根据输入数据进行物理模拟，又要按照物理同步的处理逻辑修正运动状态。</p><p>如何权衡这两者的关系，是载具物理同步的重点之一。如果用服务器下发的滞后数据去纠正主控端的运动状态，那么主控端可能出现拉扯问题。而如果以主控端的物理模拟结果为准去纠正服务器的运动状态，则会面临玩家作弊的风险。</p><p>此外，因为模拟端上的数据都来自于服务器，所以即便是在模拟端上进行预测也只能缩小与服务器的延迟。而先行预测的主控端明显快于服务器，因此模拟端与主控端一定会存在延迟。如何缩小模拟端与主控端的延迟，是载具物理同步的另外一个重点。</p><h3 id="3-2-UE4的原生方案"><a href="#3-2-UE4的原生方案" class="headerlink" title="3.2 UE4的原生方案"></a>3.2 UE4的原生方案</h3><p>UE4使用<code>导航预测算法</code>实现了一套适用于许多应用场景的物理同步方案。因此，UE4并未针对载具的物理同步做过多的额外处理，依然使用其通用的物理同步方案，以服务器下发的运动状态为准强行纠正客户端的运动状态。</p><blockquote><p>更多关于UE4物理同步的细节，可以看<a href="http://www.asancai.top/posts/84142416/">UE4的物理同步</a>一文。</p></blockquote><p>同时，主控端每帧都会将最新的输入数据发给服务器，确保主控端与服务器运动状态相差不大。</p><p><img src="https://blog-images-1253364479.cos.ap-guangzhou.myqcloud.com/Image(2).png" alt="Image(2)"></p><p>因此，当网络延迟较大，主控端的输入数据无法及时发给服务器时，主控端会在物理同步逻辑的影响下不断将载具的运动状态纠正至服务器所下发的运动状态。而此时服务器下发的运动状态是使用较长时间之前的输入数据进行物理模拟的结果，所以玩家会感觉到此时载具会失去控制，无法及时响应其输入数据。</p><p><img src="https://blog-images-1253364479.cos.ap-guangzhou.myqcloud.com/06.gif" alt="网络延迟较大时出现明显的卡顿、滞后感"></p><p>此外，即便网络延迟较小，玩家在操作载具时也会出现载具来回摆动的现象，这主要有两个原因：</p><ol><li>由于外插值算法的缺陷，UE4的物理同步方案在处理持续转弯的物体时会出现频繁抖动的问题；</li><li>主控端的物理模拟结果和物理同步的结果冲突；</li></ol><p><img src="https://blog-images-1253364479.cos.ap-guangzhou.myqcloud.com/07.gif" alt="网络较好时也会出现轻微的卡顿"></p><p>总体来说，在处理载具的物理同步上，UE4的原生方案有多致命的缺陷，并非一个好的方案。</p><h3 id="3-3-预测一切：来自《火箭联盟》的启发"><a href="#3-3-预测一切：来自《火箭联盟》的启发" class="headerlink" title="3.3 预测一切：来自《火箭联盟》的启发"></a>3.3 预测一切：来自《火箭联盟》的启发</h3><p>根据<a href="https://www.youtube.com/watch?v=ueEmiDM94IE">火箭联盟在GDC 2018上的演讲</a>，可以知道作为一个以<code>载具与球之间的物理交互</code>作为核心玩法的<code>多人PC游戏</code>，火箭联盟更具挑战的点在于不仅需要处理载具的物理同步问题，同时还需要处理因为网络延迟所带来的碰撞问题。</p><p>首先，作为一个PC游戏，使用一个权威服务器防止玩家作弊是必不可少的。在此基础上，为了让玩家拥有<code>零延迟的操作体验（No Input Delay）</code>，火箭联盟采用的策略是客户端在收到输入数据时马上对操纵的载具进行物理模拟，也就是<code>客户端提前预测</code>。</p><p>姑且先不讨论客户端模拟结果与服务器结果模拟不一致之后如何纠错的问题，这个方案会带来一个很致命的问题：在同一个客户端上，玩家操作的载具是快于服务器的，而玩家准备踢的球则是慢于服务器的。</p><blockquote><p>玩家踢的球慢于服务器并不难理解，既然要用权威服务器来防止玩家作弊，那么对于影响游戏结果的球来说，其<code>物理状态（位置和速度）</code>由服务器同步给客户端，客户端只负责渲染是一个很合理的方案。</p></blockquote><p>当<code>未来的载具</code>准备踢<code>过去的球</code>，自然会出现玩家认为自己踢到了球，而服务器却认为玩家根本没碰到球的问题。</p><p><img src="https://blog-images-1253364479.cos.ap-guangzhou.myqcloud.com/01.gif" alt="球从左往右运动，载具从上往下运动准备踢球"></p><p>如何解决这一问题？如果直接使用FPS游戏里常用的<code>延迟补偿（Lag Compension）</code>方案，那么则会出现低延迟的玩家在马上踢到球时，发现球在其他高延迟玩家的交互下突然从身边飞走了。</p><blockquote><p><strong>延迟补偿的具体实现</strong>：<br>  在客户端踢到球时将载具和球的数据一起发送给服务器，服务器在收到数据包之后，将球拉回到网络延迟前的位置并确认客户端是否踢到了球。如果校验通过，那么服务器则会接受客户端的结果，认为客户端踢到了球并纠正球的物理状态。</p></blockquote><p>让高延迟的玩家影响低延迟玩家的游戏体验显然是无法接受的。为了兼顾所有玩家的游戏体验，最终火箭联盟采用了类似于守望先锋的<code>关键帧同步方案</code>：</p><ol><li><p>客户端在接收到输入数据时直接开始物理模拟，然后记录下<code>当前的物理帧号</code>和<code>所有物体的物理状态</code>作为当前的关键帧，并将关键帧数据存入<code>关键帧缓存队列</code>中；</p></li><li><p>客户端将<code>输入数据</code>以及<code>对应的物理帧号</code>发送给服务器；</p></li><li><p>服务器收到客户端同步的数据数据之后开始物理模拟，然后将<code>当前的物理帧号</code>和<code>所有物体的物理状态</code>同步给客户端；</p></li><li><p>客户端收到服务器同步的数据时，从关键帧缓存队列里找出对应的关键帧数据进行比对，对于差距比较大的物体，将其物理状态直接回溯到服务器同步过来的状态；</p></li><li><p>回溯结束之后，从关键帧缓存队列中取出后续的输入操作，然后一次性执行<code>多次物理模拟</code>，直到将全部输入数据都消耗完为止，确保客户端以正确的状态重新进行预测；</p></li></ol><p>如下图所示，客户端在接收到输入数据时让载具直接移动，而此时客户端的球因为缺少服务器同步过来的数据处于静止的状态。直到后面服务器将数据同步过来时，才发现从第1帧开始球的状态就与服务器出现不同步，而载具则因为输入数据没有发生变化而与服务器保持同步。</p><p><img src="https://blog-images-1253364479.cos.ap-guangzhou.myqcloud.com/02.gif" alt="全预测方案的具体步骤"></p><p>此时，客户端先回溯到第1帧，然后将球的状态纠正至服务器同步下来的状态。因为客户端的最新物理帧为4，所以会一次性执行3次物理模拟，同时对载具和球以正确的状态进行预测，确保客户端上的载具和球都快于服务器。这样，客户端上的载具在踢球时，就是以<code>未来的载具</code>踢<code>未来的球</code>。只要客户端的网络稳定，那么客户端的预测结果就与服务器相差不大，客户端也就感受不到任何延迟。</p><blockquote><p>因为客户端会对<code>所有物体（玩家操作的载具、其他玩家操作的载具和球）</code>的物理状态进行预测，确保其物理状态处于相同的时间线，所以这个预测策略被称为<code>客户端全预测（Client Predict Everything）</code>。</p></blockquote><p>在梳理清楚火箭联盟的物理同步方案之后，不难知道在预测失败时需要在<code>一帧内完成回溯以及多次物理模拟</code>的操作，CPU开销很大。为了尽可能地避免客户端预测失败的问题，火箭联盟将服务器和客户端的物理帧率都设置为120帧，以减少每次物理模拟时的差异，但过高的物理帧率无疑会进一步的增加CPU的开销。因此，火箭联盟的物理同步方案比较适合PC或者主机游戏，而不太适合手机游戏。此外，当游戏中的物体过多时，每次回溯的CPU开销和关键帧需要保存的数据也会快速增长，因此也并<code>不适合场景过大、物体较多</code>的游戏。</p><p>当然，即便火箭联盟的物理同步方案在应用上存在诸多限制，但其<code>回溯+纠正+重新预测</code>的方案确实可以有效解决服务器的同步数据与客户端的预测数据冲突时的拉扯问题。</p><h3 id="3-4-苦痛之路：打满补丁的《看门狗2》"><a href="#3-4-苦痛之路：打满补丁的《看门狗2》" class="headerlink" title="3.4 苦痛之路：打满补丁的《看门狗2》"></a>3.4 苦痛之路：打满补丁的《看门狗2》</h3><p>在2017年的GDC上，育碧的开发人员详细地分享了《看门狗2》关于载具物理同步的策略。</p><p>《看门狗2》的网络模型是基于状态同步的P2P，主控端在接收到输入数据时直接进行物理模拟，然后将载具的物理状态同步给模拟端，并在模拟端上使用<code>导航预测算法</code>进行预测以减少载具的延迟。因为模拟端并<code>没有使用载具的输入数据</code>进行物理模拟，所以在载具转弯时会出现因为频繁预测失败而出现抖动的现象。</p><p><img src="https://blog-images-1253364479.cos.ap-guangzhou.myqcloud.com/03.gif"></p><p>本来最佳的解决方案应该是使用<code>输入数据</code>驱动<code>载具的物理模拟系统</code>，然后根据轮胎的朝向和速度等物理属性来预测载具的转向变化。但《看门狗2》的开发团队觉得这个很复杂，所以使用了更为简单的方案，直接用载具的角速度进行外插值来预测载具的转向，结果确实平滑了很多但仍能看到有轻微的抖动。</p><p><img src="https://blog-images-1253364479.cos.ap-guangzhou.myqcloud.com/03(1).gif"></p><p>也正是因为预测机制的缺陷导致载具的运动轨迹会被频繁纠正，所以《看门狗2》又打了个补丁：使用主控端同步给模拟端的<code>快照（Sanpshot，也就是载具的物理状态）</code>对模拟端的载具进行内插值，从而得到更为准确的运动轨迹。</p><p>但内插值会增加载具在模拟端上的延迟，而外插值可以减小延迟所带来的运动状态差异。因此，《看门狗2》使用了内插值和外插值混合的策略，以尽可能缩小模拟端上的载具与主控端的差异。下图演示了这个策略的具体工作原理：</p><blockquote><p>其实这个策略很简单，总结起来就一个原则：有最新的快照就优先用内插值得到较为准确的轨迹，如果没有就使用外插值尽可能缩小与主控端的差异。</p></blockquote><p><img src="https://blog-images-1253364479.cos.ap-guangzhou.myqcloud.com/05.gif" alt="内插值和外插值的混合策略"></p><p>如上图所示，模拟端在收到第一个<code>SnapShot（红色的点）</code>时，因为没有下一个SanpShot用于内插值，此时执行的是外插值，所以模拟端的运动轨迹和主控端不一致。等收到第二个<code>SnapShot</code>的时候，开始内插值，此时模拟端则可以以一个较为准确的运动轨迹追上主控端。最后，模拟端与客户端的延迟为3帧，而如果单纯用内插值，延迟则为5帧。</p><blockquote><p><a href="https://zhuanlan.zhihu.com/p/336869551">细谈网络同步在游戏历史中的发展变化（下）</a>一文中，关于这一过程的解读明显是错的。</p></blockquote><p>此外，在网络比较好的情况下，有可能模拟端在追上最新的SnapShot之前，又收到了一个新的SanpShot。此时，如何决定外插值和内插值的比例是一个很大的问题。如果外插值比例过大，那么载具运动轨迹的准确性会变差。而如果内插值的比例过大，那么载具的延迟会增加。</p><p>因此，《看门狗2》引入了<code>TimeOffset</code>的概念，用TimeOffset来决定内插值和外插值的比例。TimeOffset的大小为<code>网络平均延迟</code>加上一个<code>由载具速度决定的修正值</code>，并且限制其最大不超过300ms。</p><blockquote><p>（1）TimeOffset必须大于网络延迟是合理的。如下图所示，如果外插值的预测完全正确，那么模拟端载具的物理状态在<code>时刻T</code>一定可以与主控端载具的物理状态（SnapShot 3同步下来的数据），此时再进行外插值反而会加大模拟端和主控端的差异；<br>（2）综合考虑网络的波动性和预测的不准确性，在网络延迟的基础上加上一个修正值是很有必要的，只是这个修正值是一个经验数值；</p><p><img src="https://blog-images-1253364479.cos.ap-guangzhou.myqcloud.com/Image(3).png" alt="TimeOffset的用法"></p></blockquote><p>当然，外插值和内插值混合的方案只能减少延迟而不能完全消除延迟。玩家操作的载具在与其他玩家操作的载具碰撞时，依旧会出现<code>玩家当前的载具</code>撞击了<code>其他玩家过去的载具</code>的问题，也就是《火箭联盟》面临的问题。更要命的是，这个方案在载具相互碰撞时会出现bug。</p><p>如下图所示，不妨假设下面两个车相互撞击。此时模拟端上的白车在与蓝车碰撞之后，因为还没收到主控端下发的SnapShot，所以会使用外插值继续向前行驶。而白车在主控端上则因为碰撞向后运动，并随后向模拟端下发一个向后运动的Snap Shot。当模拟端的白车在收到该Snap Shot之后，则会因为外插值而向后运动更长的距离。</p><p><img src="https://blog-images-1253364479.cos.ap-guangzhou.myqcloud.com/Image(4).png" alt="撞击时载具的运动图解"></p><p>因为《看门狗2》没有权威服务器，没有一个权威的碰撞结果让客户端有机会纠正网络延迟带来的差异。所以为了让载具有更为自然的碰撞表现，《看门狗2》又打上了<code>物理模拟融合（Physsics Simulation Blending）</code>补丁：在碰撞时让模拟端的载具完全受物理模拟的控制，随后不断减小物理模拟的权重增大网络同步的权重，从而让载具在碰撞的时候有更加自然的表现。</p><p><img src="https://blog-images-1253364479.cos.ap-guangzhou.myqcloud.com/Image(5).png" alt="Physsics Simulation Blending"></p><p>虽然使用物理模拟融合之后碰撞效果也没有很自然，但至少比使用物理模拟融合前的碰撞效果好了很多。</p><p>总体来说，《看门狗2》最终的载具物理同步效果并不好，虽然主要是受限于P2P的网络模型，但也从某种程度上说明载具的物理同步确实很难，否则也不需要打这么多补丁才能得到一个勉强能看的效果。</p><p>里面提到的很多优化策略大部分都没有多少参考价值，都是为了弥补P2P的缺陷所打的补丁，唯一比较值得参考的点是通过内插值和外插值混合的方式，确保模拟端载具以比较准确的轨迹运动的同时减少和主控端的延迟。</p><hr><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>物理同步一直是多人网络游戏中比较不好处理的部分，如何处理拥有复杂物理模拟逻辑的载具更是难上加难。</p><p>目前并没有针对载具物理同步的通用解决方案，基本都需要根据项目的具体需求和限制来决定具体的同步策略。就像《火箭联盟》的方案可以获得一个很棒的同步效果，但其回溯以及高物理帧率所带来的巨大CPU开销使其很难在手机游戏上落地。</p><hr><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol><li><a href="https://www.cxymm.net/article/Jingsongmaru/119149115">车辆动力学及在Unity、UE4中的实现</a></li><li><a href="https://app.yinxiang.com/fx/76709e67-7faa-4913-aed6-19192b007bf9">UE4的物理同步</a></li><li><a href="https://zhuanlan.zhihu.com/p/341447703">浅谈物理引擎的网络同步方案</a></li><li><a href="https://www.youtube.com/watch?v=ueEmiDM94IE">GDC 2018, It IS Rocket Science! The Physics of Rocket League Detailed</a></li><li><a href="https://www.gabrielgambetta.com/lag-compensation.html">Fast-Paced Multiplayer (Part IV): Lag Compensation</a></li><li><a href="https://zhuanlan.zhihu.com/p/95560180">复制混乱——看门狗2的载具同步(翻译)</a></li><li><a href="https://zhuanlan.zhihu.com/p/387842360">手游中的载具物理同步的实现方案</a></li><li><a href="https://devforum.roblox.com/t/extrapolated-physics-interpolation-mode/842873">Extrapolated physics interpolation mode</a></li><li><a href="https://zhuanlan.zhihu.com/p/336869551">细谈网络同步在游戏历史中的发展变化（下）</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>UnrealEngine的苦痛之路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>UE4</tag>
      
      <tag>载具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《Space Engineers》基于物理的预测同步方案</title>
    <link href="/posts/53757809/"/>
    <url>/posts/53757809/</url>
    
    <content type="html"><![CDATA[<h2 id="1-背景介绍"><a href="#1-背景介绍" class="headerlink" title="1. 背景介绍"></a>1. 背景介绍</h2><p><code>《Space Engineers》</code><sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[Space Engineers, Wikipedia](https://en.wikipedia.org/wiki/Space_Engineers)">[1]</span></a></sup>是一款发行于2013年的沙盒类多人游戏。玩家可以建造功能各异且大小不一的太空船、太空站、行星哨所，也可以驾驶飞船在太空中畅游，在星球上探索并收集生存所需的资源。</p><p>用于开发《Space Engineers》的游戏引擎，是<code>Keen Software</code>自研的游戏引擎VRAGE。VARGE是一个<code>基于体素(Voxel)</code>的游戏引擎，并使用了Havok作为其物理引擎。</p><blockquote><ol><li><p>体素的一些基本概念<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="[以体素建构三维游戏世界，Milo Yip](https://zhuanlan.zhihu.com/p/20065737)">[2]</span></a></sup></p><p>​体素（Voxel）是体积元素（Volume Pixel）的简称，可以将其理解为三维空间下的像素。如果使用一个<code>三维数组</code>来表示<code>栅格化的三维空间</code>，那么三维数组里面的每个元素就是一个体素，每个体素只需要存储一个比特用来表示其所占的空间是空心还是实心的。与网格数据相比，体素数据更加简单和独立、更容易修改。</p><p>​当然，体素还能储存物体的材质、颜色，甚至是游戏属性等额外的信息。当把体素缩小之后，也可以获得高级别的真实感。如果赋予体素物理属性，那么每个体素都能在物理约束下独立地进行物理模拟，从而获得更加真实、更加丰富的物理效果。</p></li><li><p>不确定性物理引擎（Non-deterministic Physics Engine）<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="[Game Engines and Determinism](https://www.duality.ai/blog/game-engines-determinism)">[3]</span></a></sup></p><p>​作为三大物理引擎之一的Havok物理引擎也是一个<code>不确定性物理引擎</code>。</p><p>​不确定性物理引擎使用浮点数进行计算，不同机器上的CPU对浮点数实现的标准可能不一样，因此不同平台下计算的结果会有细微的差异。即便是同一机器，每次模拟的结果也都会因为浮点数精度的问题得到不一样的模拟结果。</p><p>​除此之外，不同平台上伪随机数、物理模拟帧率等其他因素所带来的差异，也是造成不确定性物理引擎在不同平台上的模拟结果不完全一致的原因。</p></li></ol></blockquote><p>该游戏的主要特点如下：</p><ol><li>允许玩家可以任意改变地形；</li><li>玩家可以通过联机进行多人协作或者多人对抗，允许超过百人同时在线；</li><li>地图很大，有超过一万个实体需要管理；</li><li>所有物体的运动都是由物理模拟驱动的，也包括玩家控制的角色；</li></ol><hr><h2 id="2-基本同步思路"><a href="#2-基本同步思路" class="headerlink" title="2. 基本同步思路"></a>2. 基本同步思路</h2><p><code>《Space Engineers》</code>使用的网络同步模型是C&#x2F;S模型。</p><p>玩家在进行交互操作时，客户端将采集到的<code>输入数据</code>发送给服务器进行模拟，然后服务器将模拟结果（如玩家的位置等数据）下发给客户端，最后由客户端负责更新数据并将游戏画面渲染到显示器上。</p><p>这无疑是一个简单直接的同步策略，但随之而来的，是巨大的、不可接受的<code>延迟（Lag）</code>。</p><blockquote><p>延迟指的是，从玩家操作输入设备，到屏幕上渲染出对应游戏画面所需要的时间。</p></blockquote><p>如果下图所示，假设<code>游戏帧率稳定为60HZ（16.6ms每帧）</code>，<code>网络延迟（Ping）稳定为50ms</code>，不考虑丢包等问题的影响，玩家的延迟为231ms</p><p><img src="https://blog-images-1253364479.cos.ap-guangzhou.myqcloud.com/image-20231119134539750.png" alt="image-20231119134539750"></p><blockquote><p>① 操作系统检测到玩家操作输入设备需要2ms；</p><p>② 客户端在游戏线程的Tick中搜集输入数据，需要16.6ms；</p><p>③ 服务器在25ms后收到从客户端发送过来的<code>输入数据A</code>；</p><p>④ 服务器将<code>输入数据A</code>缓存到一个4帧大小的队列中，需要等待66.4ms；</p><p>⑤ 服务器使用<code>数据输入A</code>进行模拟，并在下一帧时将模拟结果下发给客户端，需要等待16.6ms；</p><p>⑥ 客户端在25ms后收到服务器下发的模拟结果；</p><p>⑦ 客户修改本地的数据，等待下一帧进行渲染，需要16.6ms；</p><p>⑧ 渲染器（Render）搜集数据，并提交到GPU进行渲染，需要16.6ms；</p><p>⑨ GPU渲染的画面显示到显示器上，需要的时间与显示器硬件有关，这里取平均值30ms；</p></blockquote><p>如果网络情况较差，网络延迟提高到300ms，那么延迟则会飙升至481ms。在丢包、掉帧等问题的影响下，延迟会变得更高。</p><p>如此高的延迟会给玩家带来非常差的游戏体验。一个行之有效的、可以大幅度降低延迟的策略是，客户端在获得玩家的输入数据时，立刻在本地进行模拟并渲染对应的游戏画面，也就是所谓的<code>预表现</code>。这样延迟就只需要97ms，且不受网络波动影响。</p><p><img src="https://blog-images-1253364479.cos.ap-guangzhou.myqcloud.com/image-20231119140402303.png" alt="image-20231119140402303"></p><p>但天下没有免费的午餐。前面提到，《Space Engineers》使用的Havok物理引擎是一个不确定物理引擎，因此客户端和服务器的模拟结果并不能保证完全一致。再加上网络的不稳定性，服务器收到的输入数据和客户端用来预表现的输入数据也不能保证完全一致。</p><p>因此，<code>客户端预表现的结果</code>和<code>服务器模拟的结果</code>极大概率是不一致的。这也意味着，客户端需要在收到服务器下发的模拟结果时，及时对预表现的结果进行<code>纠正（Correction）</code>，从而确保不出现不同步的问题。</p><hr><h2 id="3-网络协议的选择"><a href="#3-网络协议的选择" class="headerlink" title="3. 网络协议的选择"></a>3. 网络协议的选择</h2><p>网络同步其实就是使用网络协议传输业务数据。</p><p>尽管<code>TCP(Transmission Control Protocol)</code>提供了<code>可靠传输</code>、<code>流量控制</code>和<code>拥塞控制</code>等特性，使开发者无需担心数据丢失和重传等细节问题。但在要求及时响应的网络游戏中，TCP为了提供这些特性而带来的延迟会极大地影响玩家的体验，毕竟TCP协议设计之初就不是为了及时响应的。</p><p>正因如此，网络游戏通常会使用延迟更低的<code>UDP(User Datagram Protocol)</code>作为其网络同步协议，《Space Engineers》也不例外。</p><p>但因为UDP只会尽最大能力交付，并不保证数据的可靠传输，会出现丢包、乱序等问题。所以在采用UDP来作为开发网络游戏的网络协议时，需要开发者自己实现<code>可靠UDP</code>。可靠UDP一般分为两种：</p><ol><li><code>基于可靠传输的UDP(Reliable UDP)</code>：指在UDP上加一层封装，在<code>传输层</code>实现重传等类似TCP的特性，保证<code>上层逻辑</code>在处理数据包的时候，不需要考虑数据丢失和重传等细节，如Enet，KCP等；</li><li><code>业务按需实现的可靠UDP</code>：指直接使用原始的UDP，然后在业务层针对特定的数据，实现一个带超时的重传确认机制，让业务层负责超时重发、排序等工作；</li></ol><p>通常来讲，<code>业务按需实现的可靠UDP</code>要优于直接使用<code>可靠UDP协议</code>，因为不是所有的数据都需要可靠交付。让所有的数据都进行可靠交互，只会造成不必要的浪费。</p><p>如果某个状态是有实效性的，那么过期的状态信息就是可丢失的，每个新的状态信息可以直接取代旧的信息。例如玩家在场景中的位置数据，只有最新的位置数据是有意义的。</p><p>相反，有一些数据则需要避免丢失或者乱序的问题，如玩家的输入数据。如果玩家的输入数据在发送至服务器的过程中出现丢失或者乱序，那么会让服务器和客户端的模拟结果出现显著的差异，从而导致不同步的问题。</p><hr><h2 id="4-输入数据的同步"><a href="#4-输入数据的同步" class="headerlink" title="4. 输入数据的同步"></a>4. 输入数据的同步</h2><h3 id="4-1-Playout-Delay-Buffer"><a href="#4-1-Playout-Delay-Buffer" class="headerlink" title="4.1 Playout Delay Buffer"></a>4.1 Playout Delay Buffer</h3><p>为了让UDP在传输<code>输入数据</code>时更加可靠，其采取的策略是：</p><ol><li>客户端为每个输入数据打上对应的帧号；</li><li>在服务器添加一个4帧大小的<code>播放延迟缓存区（Playout Delay Buffer）</code>；</li><li>服务器在收到输入数据时，先根据输入数据的帧号筛选出过期或者重复的输入数据并直接丢弃；</li><li>校验通过的输入数据会被放进缓存区里按照帧号进行排序；</li><li>最后服务器依次从缓存区里取出输入数据进行模拟；</li></ol><p>下图演示<code>播放延迟缓存区</code>的具体工作过程：</p><p><img src="https://blog-images-1253364479.cos.ap-guangzhou.myqcloud.com/image-20231120211153010.png" alt="image-20231120211153010"></p><blockquote><ol><li><p>服务器每帧都会取出缓存区的第一个元素作为当前帧的输入数据，如果当前取出的元素为空，则表示当前帧没有任何输入数据；</p><ol><li>第5帧：收到<code>输入数据2</code>，将其存入缓存区的末尾；</li></ol></li><li><p>第6帧：取出位于缓存区首位的空元素作为输入数据进行模拟，随后收到<code>输入数据5</code>，将其存入缓存区并进行排序；</p></li><li><p>第7帧：取出位于缓存区首位的空元素作为输入数据进行模拟，随后收到<code>乱序的输入数据3</code>，将其存入缓存区并进行排序；</p></li><li><p>第8帧：取出位于缓存区首位的空元素作为输入数据进行模拟，此时没有收到任何输入数据，将一个空元素插入缓存区的末尾；</p></li><li><p>第9帧：取出位于缓存区首位的<code>输入数据2</code>作为输入数据进行模拟，随后收到<code>过时的输入数据1（此时输入数据2已经生效了，再使用输入数据1会出现乱序的问题）</code>，直接将其丢弃，此时视为没有收到任何输入数据，继续将一个空元素插入缓存区的末尾；</p></li><li><p>第10帧：取出位于缓存区首位的<code>输入数据3</code>作为输入数据进行模拟，此时没有收到任何输入数据，将一个空元素插入缓存区的末尾；</p></li><li><p>第11帧：本应取出<code>输入数据5</code>作为输入数据进行模拟，当检测到和上一帧使用的<code>输入数据3</code>并不连续，因此需要继续使用<code>输入数据3</code>补齐中间丢失的输入数据；</p></li><li><p>第12帧：使用<code>输入数据5</code>作为输入进行模拟，此时没有收到任何输入数据，则将一个空元素插入缓存区的末尾；</p></li><li><p>值得注意的是因为服务器从第10帧开始一直没有收到输入数据，所以在第12帧之后所有缓存的输入数据都被消耗完了。但此时服务器仍会在<code>随后的几帧</code>重复使用最后一个收到的<code>输入数据5</code>作为输入数据进行模拟。</p><ol><li>视频中并没有提到这么做的目的，<code>个人猜测</code>这里应该是为了对抗网络波动，等待下一个潜在的输入数据；</li></ol></li><li><p>不妨假设在第13帧时收到<code>输入数据6</code>：<br>   1. 如果在第12帧使用了<code>输入数据5</code>之后，不将<code>输入数据5</code>留在缓存区里继续重复使用，那么在收到<code>输入数据6</code>时，<code>输入数据6</code>会被直接放到最末尾再等待4帧，这显然会极大地增加延迟；</p><ol start="2"><li>如果将<code>输入数据5</code>留在缓存区里继续重复使用，那么在收到<code>输入数据6</code>时，会直接对其进行排序，放到<code>输入数据5</code>之后，那么第15帧就可以使用<code>输入数据6</code>了，延迟会显著降低；</li></ol></li><li><p>当然，重复使用的帧数不能太多，否则玩家会发现停止操作之后，游戏里的角色仍在自己移动，这显然是有问题的。</p></li></ol></blockquote><p>从上面的流程不难理解，《Space Engineers》在处理输入数据时，选择以增加一定的延迟作为代价，将输入数据先放到缓存区里，在缓存区中对其进行筛选剔除和排序，从而尽可能降低了输入数据乱序对模拟结果的影响。这也是<code>2. 框架总览</code>一节中，输入数据在到达服务器之后还要等待66.4ms的原因。</p><p>当然，缓存区的长度是<code>可调整的（Optional）</code>，但并不是越长越好，因为这会增加服务器模拟结果的延迟时间。而如果太短，则无法起到其应有的作用，其最终采用的4帧长度也是一个调整出来的经验值。</p><h3 id="4-2-一个让输入数据更可靠的思路"><a href="#4-2-一个让输入数据更可靠的思路" class="headerlink" title="4.2 一个让输入数据更可靠的思路"></a>4.2 一个让输入数据更可靠的思路</h3><p>虽然使用<code>Playout Delay Buffer</code>可以解决输入数据乱序的问题，但并不能解决丢包的问题。因为服务器在发现<code>丢包（帧号不连续）</code>时并没有请求客户端重发，客户端也不知道服务器在接收时丢失了哪些输入数据。</p><p>一个可行的优化策略是，通过<code>冗余重传的方式</code><sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><span class="hint--top hint--rounded" aria-label="[动作手游实时PVP帧同步方案（客户端）](https://gameinstitute.qq.com/community/detail/127640)">[4]</span></a></sup>实现一个简单可靠的UDP。具体的修改如下：</p><ol><li>客户端将本地的输入数据依次存放进<code>发送缓存区</code>里；</li><li>客户端每次将发送缓存区里的输入全量发送给服务器；</li><li>服务器接收到客户端发送过来的数据之后，将过期的输入数据直接丢弃，然后把尚未接收国的输入数据放进<code>接收缓存区</code>里；</li><li>服务器通知服务器当前已接收的最新输入数据；</li><li>客户端<code>发送缓存区</code>中服务器已确认的输入数据清理掉，不再发送；</li></ol><p><img src="https://blog-images-1253364479.cos.ap-guangzhou.myqcloud.com/image-20231120213440788.png" alt="image-20231120213440788"></p><p>不难看出，这个方案的缺点很明显，客户端每次都需要额外发送冗余的数据数据。当客户端网络较差，长时间收不到服务器的确认信息时，发送缓存区会迅速膨胀，不断加大后面发送输入数据的性能压力。因此，限制发送缓存区的最大上限、甚至在一定的时间间隔之后强制清空发送缓存区是很有必要的。</p><p>但不可否认的是，这种方式可以很好地解决丢包、乱序的问题，让UDP在传输数据时更可靠，且实际的延迟比<code>Space Engineers</code>的方案更低。</p><hr><h2 id="5-位置数据的同步"><a href="#5-位置数据的同步" class="headerlink" title="5. 位置数据的同步"></a>5. 位置数据的同步</h2><p>虽然位置数据是具备时效性的，不需要额外处理乱序和丢包的问题，但还是需要给位置数据加一些额外的标记，从而让客户端区分该位置数据是否已经过时了。通常的做法，是给位置数据加上<code>时间戳</code>，<code>Space Engineers</code>也不例外。</p><p>在客户端收到服务器下发的位置数据之后，根据位置数据的用途，可以区分出两种同步模式：<code>Animated</code>和<code>Predicted</code>。</p><h3 id="5-1-Animated"><a href="#5-1-Animated" class="headerlink" title="5.1 Animated"></a>5.1 Animated</h3><p>Animated同步模式很简单，就是完全使用服务器下发的位置数据来修改物体在客户端上的位置。这也是<code>模拟端（如多人游戏中其他玩家控制的角色）</code>最常用的位置同步方式。</p><p>考虑到UDP在传输位置数据时是不可靠的，为了让物体移动更加平滑，尽可能在网络较差时出现频繁抖动的问题。客户端会将收到的位置数据存进一个<code>缓存队列（Position History）</code>里，然后使用<code>内插值和外插值</code>的方式更新物体的位置。</p><blockquote><p>内插值和外插值的具体实现并不是这里的重点，在网上有很多讲解的文章<sup id="fnref:5" class="footnote-ref"><a href="#fn:5" rel="footnote"><span class="hint--top hint--rounded" aria-label="[浅谈物理引擎的网络同步方案，Clawko](https://zhuanlan.zhihu.com/p/341447703)">[5]</span></a></sup>。</p></blockquote><p>当然，在将位置数据放入缓存队列之前，客户端会检查位置数据的时间戳，来判断该位置数据是否过期。原视频并没有很详细地介绍缓存队列的具体工作流程，只是简单地介绍了客户端具体是如何通过时间戳来判断位置数据是否过期的。</p><p><img src="https://blog-images-1253364479.cos.ap-guangzhou.myqcloud.com/image-20231121175118351.png" alt="image-20231121175118351"></p><p>但从上面的描述，<code>个人猜测</code>具体工作流程应该是这样的。客户端在收到位置数据时，先算出该位置数据的有效时间：</p><blockquote><p>位置数据的有效时间：服务器时间戳 + ping &#x2F; 2 + T（T推测应该就是60ms）</p></blockquote><p>如果在当前用来内插值的位置数据的有效时间内，收到了更新的位置数据，那么就会将新收到的位置数据存起来，并按照服务器的时间戳排序。否则就会认为新收到的位置数据已经过期了，直接丢弃，如下图所示：</p><p><img src="https://blog-images-1253364479.cos.ap-guangzhou.myqcloud.com/image-20231121192640160.png" alt="image-20231121192640160"></p><p>从上图中不难看到，乱序的<code>位置数据B</code>在<code>位置数据C</code>被客户端用于内插值之前到达客户端，所以位置数据B会被放到缓存区里进行排序，等待后面用于内插值。如果位置数据B在位置数据C被用于内插值之后到达客户端，那么会直接丢弃。相当于<code>位置数据B</code>在传输的过程中发生了丢包的问题。</p><p>这并不影响最后的结果，只是会<code>丢失一部分运动轨迹</code>，从原本的<code>A→B→C</code>直接变成<code>A→C</code>。</p><p>最后，如果客户端一直没收到新的位置数据，那么会从最后收到的<code>位置数据C</code>继续外插值一段时间，这是为了避免在网络出现波动时，后面的位置数据因为传输时延迟较大而出现<code>物体时走时停</code>的问题。</p><p><img src="https://blog-images-1253364479.cos.ap-guangzhou.myqcloud.com/image-20231121193403246.png" alt="image-20231121193403246"></p><p>当然，外插值毕竟只是猜测服务器后续的运动轨迹，外插值的时间越长，其与服务器实际运动轨迹的误差就越大。通常来讲，外插值的时间最长不能超过<code>ping / 2</code> ，当超过<code>ping / 2</code>都没收到新的位置数据时，再进行外插值就失去了意义。此时应该认为服务器上的物体已停止运动，客户端上的物体也应该立即停止运动。</p><h3 id="5-2-Relative-Position-Updates"><a href="#5-2-Relative-Position-Updates" class="headerlink" title="5.2 Relative Position Updates"></a>5.2 Relative Position Updates</h3><p>Animated同步模式的主要目的在于平滑地更新物体在客户端上的位置，所付出的代价是增加物体位置更新的延迟，并且在网络不好时会丢失物体部分的运动轨迹。</p><p>如果是单个物体，玩家可能察觉不到。但如果将多个物体链接在一起，并且施加一定的物理约束（如物体只能沿着链接点的某个轴转动），那么物体在各自更新位置的过程中，可能会出现物体之间穿模或者断开等违背物理约束的问题。</p><img src="C:\Users\96985\Desktop\GDC\1.gif" alt="1" style="zoom:100%;" /><p>《Space Engineers》采取的解决办法是，为这些链接在一起的物体建立一个树状的<code>层级结构（Hierarchy）</code>。其中，Root节点还是接着使用原本的Animated同步逻辑，而Children节点则略有不同。</p><p>首先，服务器不再同步Child节点的<code>世界位置数据</code>，而是同步Child在Parent节点下的<code>相对位置数据</code>。然后，Child节点在Parent节点的局部坐标系下执行Animated同步逻辑，算出当前的相对位置数据，最后再其转换成世界位置数据，并修改物体的位置。这样，虽然Child节点的<code>世界位置数据</code>不一定准确，但至少彼此之间的相对位置是正确的。</p><p><img src="C:\Users\96985\Desktop\GDC\2.gif" alt="2"></p><p>最后，因为链接在一起的物体是平级的，如何在它们之间选取一个物体作为Root节点并建立层级结构是一个需要解决的问题。</p><p>考虑到Child节点的世界位置数据会受Parent节点的世界位置数据影响<code>（因为需要利用Parent节点的世界位置数据计算）</code>，更新的延迟会增加。因此《Space Engineers》选择的策略是：将<code>体积更大</code>或者<code>玩家当前正在操作、交互</code>的物体选择为Root节点，因为这些物体对位置数据的准确性要求更高。</p><h3 id="5-3-Predicted"><a href="#5-3-Predicted" class="headerlink" title="5.3 Predicted"></a>5.3 Predicted</h3><p>Predicted同步模式只用于玩家当前所控制的物体。</p><p>在<code>2. 基本同步思路</code>中提到，为了降低玩家的延迟，客户端会先使用玩家的输入数据直接进行模拟（也就是预表现），随后在收到服务器同步来下的模拟结果时，对客户端本地的预表现结果进行纠正。</p><p>为此，<code>《Space Engineers》</code>采用了和<code>《Rocket League》</code><sup id="fnref:6" class="footnote-ref"><a href="#fn:6" rel="footnote"><span class="hint--top hint--rounded" aria-label="[载具的物理同步，RainbowCyan](https://zhuanlan.zhihu.com/p/623356428)">[6]</span></a></sup>类似的同步策略：</p><ol><li>客户端将带上帧号的输入数据发送给服务器，随后立即使用输入数据进行模拟，并记录当前的模拟结果和帧号存进<code>History List</code>里；</li><li>当服务器在使用该输入数据进行模拟并得到模拟结果之后，服务器会将模拟结果打上对应输入数据的帧号，并下发给客户端；</li><li>客户端收到服务器下发的模拟结果之后，通过帧号从<code>History List</code>中找到对应的数据进行验证，判断是否需要进行纠正；</li><li>从客户端的<code>History List</code>删除已经验证过的记录（帧号比当前已被验证过的数据小的）；</li></ol><p><img src="https://blog-images-1253364479.cos.ap-guangzhou.myqcloud.com/image-20231123173015750.png" alt="image-20231123173015750"></p><p>上面的流程看上去很简单，但细究起来，会发现有很多细节需要处理：</p><ol><li><p><strong>如何确保<code>客户端预表现结果</code>和<code>服务器模拟结果</code>的比较是有意义的？</strong></p><p><code>客户端预表现结果</code>和<code>服务器模拟结果</code>有意义的前提是，客户端和服务器在相同的输入数据下，可以得到<code>大致相同</code>的模拟结果（之所以是大致相同，是因为<code>Space Engineers</code>使用的Havok物理引擎是不确定性物理引擎）。</p><p>（1）<code>确保输入数据相同</code>：除了前面提到的使用帧号进行标记之外，还要确保在网络传输的过程中，客户端在<code>序列化输入数据</code>和服务器在<code>反序列化输入数据</code>时要保持一定的精度，不能出现很大的差异；</p><p>（2）<code>确保模拟结果相同</code>：一个很重要的前提则是客户端和服务器<code>每次模拟的时间相同（Synchronizing simulation steps）</code>。这不是将客户端和服务器的帧率设置成一样就可以的，因为每一帧的实际耗时是由该帧的计算量决定的。当计算量小时，当前帧会提前结束进入下一帧，而当计算量大时，当前帧则会占用更多的时间，出现<code>丢帧（Frame Drop）</code>的情况。</p><blockquote><pre><code class="hljs"> 1.  计算量小提前进入下一帧的问题，可以很方便地通过锁帧，也就是在帧的末尾等到该帧分配的时间耗尽才进入下一帧的方式解决； 2.  计算量大导致丢帧的问题，则可以通过性能优化的方式去缓解。但性能优化并不能保证100%不出现丢帧的问题，因为玩家本地可以使用各种Mod，而Mod的性能则是无法控制的；</code></pre></blockquote><p>因此，通过一些额外的处理来确保客户端和服务器的帧率尽可能保持一致，是让<code>客户端预表现结果</code>和<code>服务器模拟结果</code>的比较有意义的重点和难点。</p></li><li><p><strong>如何让客户端和服务器的帧率尽可能保持一致？</strong></p><p>让客户端和服务器的帧率尽可能保持一致的前提条件是，能知道客户端和服务器当前帧率的实际差距，从而决定如何对客户端的帧率进行调整。</p><p>如何计算客户端和服务器当前帧率的实际差距呢？首先，客户端需要记录每一帧对应的<code>实际时间</code>。其次，当服务器在使用输入数据得到模拟结果之后，要把<code>输入数据的帧号</code>和<code>服务器当前的帧号</code>一起带上下发客户端。</p><p><img src="https://blog-images-1253364479.cos.ap-guangzhou.myqcloud.com/image-20231126143114835.png" alt="image-20231126143114835"></p><p>如上图所示，当客户端在第9帧收到服务器下发的数据时，用第9帧的时间戳减去第1帧的时间戳，就得到了<code>RTT（Rount-Trip Time）</code>的具体时长。</p><blockquote><p>用第9帧的时间戳减去第1帧的时间戳，其实应该包括RTT、输入数据在Playout Delay Buffer里等待的时间、服务器得到模拟结果的实际耗时，原视频将其近似为RTT。</p></blockquote><p>至于<code>服务器帧号</code>的具体用途，原视频并没有很详细地介绍。根据上下文信息，<code>个人猜测</code>服务器帧号的具体用途应该是用来得到<code>客户端对应帧</code>的时间戳。之所以会这样猜测，是因为在理想情况下，客户端会在ping &#x2F; 2之后收到服务器的模拟结果，因此可以反推出服务器在得到该模拟结果时所对应的客户端时间戳。</p><p>但此时我们希望得到的是客户端和服务器之间帧率的差异，因此我们还需要知道在服务器得到该模拟结果时客户端实际的时间戳。因此，使用服务器帧号来拿客户端实际的时间戳，然后来比较服务器帧率和客户端帧率的快慢，这就比较合理了。</p><p>如下图所示，不妨假设客户端的帧率低于服务器，也就是客户端每帧的耗时大于服务器。当客户端在第7帧收到服务器下发的数据时，先根据推算出的ping值，算出<code>服务器得到模拟结果的估算时间</code>，然后再根据服务器下发的帧号，找到<code>客户端对应帧的实际时间</code>。根据这两个时间，可以很快推算出客户端和服务器每帧耗时的差距，也就是左边的红色部分。</p><p><img src="https://blog-images-1253364479.cos.ap-guangzhou.myqcloud.com/image-20231126161524118.png" alt="image-20231126161524118"></p><p>但《Space Engineers》采用的算法略有不同，是先根据<code>客户端对应帧的实际时间</code>推算出<code>在客户端的实际时间下服务器数据预期的抵达时间</code>，然后再根据<code>服务器数据的实际抵达时间</code>算出客户端和服务器每帧耗时的差距，也就是右边的红色部分，从而判断客户端当前是比服务器慢还是比服务器更快。</p><blockquote><p>虽然算法不一样，但很明显能知道两种方法算出来的差值，也就是左右两边的红色部分是一样的。</p></blockquote><p>当<code>服务器数据的预期抵达时间</code>快于实际抵达时间时，客户端的进度落后于服务器（Client falling beind），需要对客户端进行加速，也就是缩短客户端每帧执行的时间。而当服务器数据的预期抵达时间慢于实际抵达时间时，客户端的进度比服务器更快（Client ahead），客户端需要等待服务器，也就是让客户端每帧多等待一段时间。</p><blockquote><p>当客户端落后服务器太多，大于1000ms时，需要执行reset to server操作。原视频对这里的介绍比较含糊，只是提到了”skips all frames up to the current server time”。</p><p>个人猜测，此时累积的误差已足够大，后面的调整已经失去了意义。这里最好的方式，应该是指将客户端上的History List中的所有帧都清空，并强制客户端用服务器下发的位置数据进行重置。然后以当前收到的数据包为起点，重新进行对时，开始新一轮的预测。</p></blockquote><p><img src="https://blog-images-1253364479.cos.ap-guangzhou.myqcloud.com/image-20231126201030017.png" alt="image-20231126201030017"></p></li><li><p><strong>如何判断客户端是否需要纠正？</strong></p><p>由于浮点数精度的问题，比较两个浮点数是否相等，本质上是判断这两个浮点数的差值是否在一个可接受的范围内。</p><p>同理，对于使用浮点数计算并表示的模拟结果来说，判断客户端和服务器的模拟结果是否一致，本质上也是判断两者的位置、朝向、速度等数据的差值是否在<code>预期的阈值</code>内。</p><p>如果误差小于阈值，那么可以近似地将它们视为一致的，此时不需要对客户端进行纠正。而如果误差超出了阈值，那么就应该对客户端进行纠正。</p></li><li><p><strong>如何对客户端进行纠正？</strong></p><p>当对客户端进行纠正的时候，其实是在对客户端的预表现，也就是客户端所记录的<code>History List</code>进行纠正。</p><p>《Rocket League》采用的纠正办法是，先回溯到<code>不同步帧</code>，然后将物体强行重置到服务器下发的位置，最后再按照<code>History List</code>所记录的输入数据重新逐帧进行模拟，得到一个新的<code>History List</code>，也就是纠正后的预表现结果。</p><p>因为场景很大物体很多，重新模拟的计算量是巨大的，所以《Space Engineers》并没有采用上述方法，而是直接使用<code>不同步帧</code>中客户端与服务器模拟结果的差异值去纠正<code>History List</code>里 的每一个数据，从而得到纠正后的预表现结果。</p><p><img src="https://blog-images-1253364479.cos.ap-guangzhou.myqcloud.com/image-20231123200738752.png" alt="image-20231123200738752"></p><p>当然，这种修正并不是准确的，甚至某种程度上还有可能加大客户端与服务器后续模拟结果的差异。因此，在应用修正值时，应该随着时间的推进不断减小修正的幅度。</p><blockquote><p>原文是：The correction should be applied over time with small doses - exponential to its extent.</p></blockquote></li></ol><h3 id="5-4-Relative-Prediction"><a href="#5-4-Relative-Prediction" class="headerlink" title="5.4 Relative Prediction"></a>5.4 Relative Prediction</h3><p>Animated同步模式下，物体的位置数据会晚于服务器，而在Predicted同步模式下，物体的位置数据则是早于服务器。</p><p>如果说服务器所处的时间线是<code>现在</code>，那么玩家在客户端上控制的角色则处于<code>未来</code>，其他玩家所控制的物体则处于<code>过去</code>。此时，当玩家想控制角色与其他玩家控制的物体进行交互时，无疑会产生和服务器上不一样的结果，这就是<code>时间悖论（Time Paradox）</code>。</p><p>如下所示，其他玩家开的<code>飞船（蓝色方块）</code>以50m&#x2F;s的速度向左飞行，玩家控制的<code>角色（灰色圆圈）</code>也以50m&#x2F;s的速度向左飞行，并在追上之后准备从<code>门（黄色方块）</code>进入飞船。然而，在服务器，角色所在的位置却是飞船偏后的位置。不难知道，在一段时间之后，服务器上的角色会撞在船外面无法进入，然后将客户端上的角色纠正回船外面。此时控制角色的玩家看到自己进入飞船之后又迅速被拉扯回飞船外面，这无疑是非常差的体验。</p><p><img src="https://blog-images-1253364479.cos.ap-guangzhou.myqcloud.com/image-20231123232431683.png" alt="image-20231123232431683"></p><p>《Space Engineers》解决这一问题的方法被称为<code>Relative Prediction</code>，和前面提到的<code>Relative Position Updates</code>很像，那就是将飞船当前玩家所控制角色的Parent节点，然后服务器给客户端下发角色的相对位置数据，此时客户端本地的History List所记录的位置数据也全部转换成相对位置数据，并在Parent节点的局部坐标系下完成纠正，最后再转换成世界位置数据。</p><p>服务器下发相对位置之后，先纠正客户端的相对位置，然后再转换成世界位置。此时，角色的相对位置是正确的，但世界位置则和服务器相差比较大，这是因为转换时所使用的Parent在客户端上的世界位置是晚于服务器的。虽然此时玩家也被拉扯了，但玩家会认为是自己网络突然卡了导致没追上，而不会觉得是bug。</p><p><img src="https://blog-images-1253364479.cos.ap-guangzhou.myqcloud.com/image-20231123234625531.png" alt="image-20231123234625531"></p><p>那么什么时候该选择合适的Parent并切换成同步相对位置呢？</p><p>一个理想的情况，是角色接触到其他物体之后，将角色所接触的物体设置为Parent然后开始同步相对位置，如角色站在其他玩家操作的飞船上。</p><p><img src="https://blog-images-1253364479.cos.ap-guangzhou.myqcloud.com/image-20231123235455815.png" alt="image-20231123235455815"></p><p>还有一种复杂的情况，是玩家在飞行或者行走的过程中，试图靠近其他物体（例如前面准备进入飞船）。此时，如果等待接触时再切换到同步相对位置就太晚了。这个问题可以通过给物体加上一个包围盒解决，但角色进入包围盒，且速度和当前物体接近时，就认为物体是角色潜在的操作对象，此时将该物体设置为角色Parent并开始同步相对位置是比较合理的。</p><blockquote><p>（1）之所以要加上速度的限制，是为了避免玩家只是单纯路过物体时，出现奇怪的拉扯问题；</p><p>（2）如果角色同时进入了多个物体的包围盒，且这些物体都满足成为Parent的要求，那么会优先选择最大的物体作为Parent；</p></blockquote><p><img src="https://blog-images-1253364479.cos.ap-guangzhou.myqcloud.com/image-20231123235717606.png" alt="image-20231123235717606"></p><hr><h2 id="6-性能优化带来的问题"><a href="#6-性能优化带来的问题" class="headerlink" title="6. 性能优化带来的问题"></a>6. 性能优化带来的问题</h2><p>作为一个太空沙盒类游戏，《Space Engineers》的场景很大，需要同步的物体也很多。直接将整个游戏世界的状态全部同步给客户端会造成巨大的性能浪费，因为距离玩家过远的物体，玩家根本看不到也并不关心，同步这些物体的状态没有任何作用。</p><p>因此，《Space Engineers》使用了常规的<code>AOI（Area of Interest）技术</code>，根据玩家所控制角色所在的位置，将位于其附近的物体同步给客户端。且物体与角色的距离越远，物体同步的频率就越低。</p><p>此外，为了进一步优化客户端的性能，《Space Engineers》将客户端上所有非玩家控制的物体都设置为<code>不会进行物理模拟的Static RigidBody</code>，只有玩家控制的物体才会被设置为<code>Dynamic RigidBody进行物理模拟</code>。当玩家切换当前控制的物体时，新控制的物体会被切换为<code>Dynamic RigidBody</code>，而被停止控制的物体则会被切换为<code>Static RigidBody</code>。</p><blockquote><p>（1）对于被设置为Static RigidBody的物体，其只会使用服务器下发的数据来修改位置，也就是前面提到的Animated同步模式；</p><p>（2）而玩家控制的物体则会直接使用输入数据进行物理模拟，然后再用服务器下发的数据进行纠正，也就是前面的Predicted同步模式；</p><p>（3）需要同步的物体在服务器上都是<code>Dynamic RigidBody</code>，这样才能得到模拟数据下发给客户端；</p></blockquote><p>这个优化策略无疑大大减少了客户端物理模拟的开销，但付出的代价则是同步上的各种的问题╮（╯＿╰）╭</p><h3 id="6-1-物理模拟差异导致的不同步"><a href="#6-1-物理模拟差异导致的不同步" class="headerlink" title="6.1 物理模拟差异导致的不同步"></a>6.1 物理模拟差异导致的不同步</h3><p>当角色准备推动比较小的物体时，由于客户端上的物体是Static RigidBody，所以角色没办法推动物体，而是直接爬到物体之上。但服务器上的物体是Dynamic  RigidBody，角色可以正常推动物体，并给客户端下发物体移动后的位置数据。</p><p><img src="https://blog-images-1253364479.cos.ap-guangzhou.myqcloud.com/image-20231124225612556.png" alt="image-20231124225612556"></p><p>由于客户端和服务器的物理设置不同，导致两边的模拟结果出现了不同步的问题。再加上角色接触到了物体之后，会按照前面的<code>Relative Prediction</code>规则将物体设置为角色的Parent。那么可想而知，后面物体会正常通过Animated同步模式使用服务器下发的数据往前移动，而角色则会因为纠正而出现拉扯问题。</p><p><img src="https://blog-images-1253364479.cos.ap-guangzhou.myqcloud.com/Small%20Entity.gif" alt="Small Entity"></p><p>​</p><h3 id="6-2-物理属性缺失导致的不同步"><a href="#6-2-物理属性缺失导致的不同步" class="headerlink" title="6.2 物理属性缺失导致的不同步"></a>6.2 物理属性缺失导致的不同步</h3><p>被设置为Static RigidBody的物体是不具备<code>速度</code>、<code>角速度</code>等物理属性的。当角色站在运动的物体上时，如果不做特殊处理，角色的速度会和服务器保持一致，而物体则会因为被设置成Static RigidBody失去速度。相当于客户端上角色和物体之间的<code>相对运动</code>出现了极大的不同步。</p><p>为了解决这一问题，当其他物体成为玩家控制角色的Parent时，服务器会将客户端的速度修改成相对速度，从而确保角色和物体的相对运动是同步的。</p><p><img src="https://blog-images-1253364479.cos.ap-guangzhou.myqcloud.com/image-20231125111910100.png" alt="image-20231125111910100"></p><p>同时，为了在客户端还原角色和物体之间的相对运动关系（也就是被抹除的那一部分速度所带来的位移），当服务器下发物体的位置数据让客户端修改物体的位置时，客户端会将物体位置的变化<code>传播（Propagate）</code>给角色，先让角色移动相同的距离，然后角色再以当前的实际速度向前运动。</p><p><img src="https://blog-images-1253364479.cos.ap-guangzhou.myqcloud.com/image-20231125170139109.png" alt="image-20231125170139109"></p><p>这种策略，本质上是通过牺牲角色世界位置的准确性为代价，来获得相对位置的正确性。不难想象，当物体的速度处于一直变化的状态时，如果角色通过跳跃等方式与物体不再进行接触，不再将物体视为Parent，切换为世界位置的同步，前面累积的巨大差异将会使角色立刻触发纠正被拉扯。</p><p><img src="https://blog-images-1253364479.cos.ap-guangzhou.myqcloud.com/image-20231125171235867.png" alt="image-20231125171235867"></p><p>如上图所示，当角色站在一个以固定角速度旋转的物体上时，虽然物体的速度大小不变、但速度的方向一直在变化。虽然客户端上物体的角度与服务器相差不大，但角色所在的位置相差却很大。当角色跳跃脱离物体时，会立刻触发纠正被拉扯（离开时被拉扯回正确的世界位置，但相对位置不对，于是落下时又被拉扯回正确的相对位置）。</p><p><img src="https://blog-images-1253364479.cos.ap-guangzhou.myqcloud.com/%20switch%20off.gif" alt=" switch off"></p><p>客户端无法正确预测缺失的数据，这是一个无法解决的问题。因此，《Space Engineers》只能打上一个补丁：当检测到玩家所控制的角色频繁触发纠正被拉扯时，会关闭角色的预测，将其切换到Animated同步模式。这样角色就不再会出现频繁的拉扯问题，但付出的代价则是<code>玩家的延迟大大增加</code>。</p><h3 id="6-3-复杂物理约束导致的不同步"><a href="#6-3-复杂物理约束导致的不同步" class="headerlink" title="6.3 复杂物理约束导致的不同步"></a>6.3 复杂物理约束导致的不同步</h3><p>玩家可能会通过游戏提供的链接组件将许多物体链接在一起，制造出很复杂的、可控制的物体。例如下图的Strandbeest-like Walker，它的每条腿都拥有很多个关节。</p><p><img src="https://blog-images-1253364479.cos.ap-guangzhou.myqcloud.com/image-20231125184632776.png" alt="image-20231125184632776"></p><p>当玩家控制这个步行器时，其每个关节都需要根据玩家的输入数据在物理约束下进行物理模拟，并驱动这个步行器进行移动。因此，每个关节都需要通过Prediced同步模式进行预表现和纠正。</p><p>但是，在不确定性物理引擎中，物理的模拟结果是存在差异的。尤其是在物理约束的作用下，前面关节的模拟结果会影响到后面关节的模拟结果，也就是物理模拟的误差会逐渐累积。当物体的关节越多、物理约束链越长时，其末尾的物体在客户端和服务器上的模拟差异就会越大，就会频繁地触发纠正，导致抽搐等不自然的表现。</p><p><img src="https://blog-images-1253364479.cos.ap-guangzhou.myqcloud.com/walker.gif" alt="walker"></p><p>为了规避这一问题，当物体的物理约束链过于复杂时，不再对约束链上的物体进行预测，而是切换到Animated同步模式，并通过前面提到的<code>Relative Position Updates</code>，确保约束链上物体相对位置的正确性，从而获得更加流畅自然的效果。</p><p><img src="https://blog-images-1253364479.cos.ap-guangzhou.myqcloud.com/Animated%20Walker.gif" alt="Animated Walker"></p><p>虽然这会极大地提高玩家在操作步行器的延迟，但考虑到约束链的模拟本身就存在延迟（需要等上一级模拟完之后才接着模拟，可以简单地理解为力的传递需要时间），不进行预测所带来的额外延迟玩家很难察觉到，是可以接受的。</p><h3 id="6-4-脏碰撞导致的不同步"><a href="#6-4-脏碰撞导致的不同步" class="headerlink" title="6.4 脏碰撞导致的不同步"></a>6.4 脏碰撞导致的不同步</h3><p>按照物体物理设置的切换规则，当玩家尝试操纵一个载具时，载具会从Static RigidBody切换成Dynamic RigidBody。此时，如果载具内部挂着另外一个物体，尽管该物体在服务器上被设置为Dynamic RigidBody，但因为该物体在客户端上没有被玩家控制，所以会被设置为Static RigidBody并与载具不断发生自碰撞。</p><blockquote><p>其实这里没有特别理解为什么会出现这样的问题。</p><p>如果物体在服务器上与载具没有发生自碰撞，说明碰撞设置应该是彼此之间都Ignore Collision。此时就算物体被设置为Static RigidBody，载具和物体也不会产生任何碰撞。</p><p>而且在分享中也没有明确提到，但物体从Dynamic RigidBody被设置为Static RigidBody时，会修改其碰撞设置（事实上也没这个必要）。</p><p>因此，唯一的可能是，载具和物体是通过某种<code>特殊的物理约束</code>链接在一起的，这中物理约束会<code>忽略物体和载具之间的碰撞</code>且只对Dynamic RigidBody起作用。当物体被设置为Static RigidBody时，这个约束会失效，自然就会出现自碰撞的问题。之所以会有这个猜测，是因为既然允许玩家自由将不同的物体链接在一起去自由建造新的东西，那肯定需要相应的措施去解决物体碰撞体重叠时的碰撞问题。</p></blockquote><p>针对这个问题，一个解决的方法是，如果发现玩家控制的物体出现频繁的脏碰撞，那么可以考虑将其也设置为Static RigidBody并切换到Animated同步模式，等过段时间没有检测到任何脏碰撞时，再将其恢复成Dynamic RigidBody并切换回Predicted同步模式。</p><p><img src="https://blog-images-1253364479.cos.ap-guangzhou.myqcloud.com/image-20231125180550709.png" alt="image-20231125180550709"></p><hr><h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h2><p>总的来说，这是一次很棒的分享，里面很详细地介绍了方案的实现细节，并很客观地介绍了一些不得不做的优化，以及这些优化所带来的各种问题，并逐一分享了这些问题对同步方案的挑战和解决的思路，很有启发。</p><p>唯一的缺点是分享的内容比较分散，需要多看几遍才能理解前后不同章节的内容之间的联系。但瑕不掩瑜，这仍是一个非常值得认真观看并学习的GDC分享。</p><hr><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://en.wikipedia.org/wiki/Space_Engineers">Space Engineers, Wikipedia</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://zhuanlan.zhihu.com/p/20065737">以体素建构三维游戏世界，Milo Yip</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://www.duality.ai/blog/game-engines-determinism">Game Engines and Determinism</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span><a href="https://gameinstitute.qq.com/community/detail/127640">动作手游实时PVP帧同步方案（客户端）</a><a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:5" class="footnote-text"><span><a href="https://zhuanlan.zhihu.com/p/341447703">浅谈物理引擎的网络同步方案，Clawko</a><a href="#fnref:5" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:6" class="footnote-text"><span><a href="https://zhuanlan.zhihu.com/p/623356428">载具的物理同步，RainbowCyan</a><a href="#fnref:6" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>GDC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络同步</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从零开始部署waline服务器</title>
    <link href="/posts/17ed14e0/"/>
    <url>/posts/17ed14e0/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>waline 是一款简洁、安全、支持多种部署方式的评论系统。网上关于如何使用<code>Vercel+LeanCloud</code>进行部署的资料很多很详细，但这类免费平台的稳定性很差。如果自己有服务器，在自己服务器上部署无疑是更好的选择。遗憾的是，很少有文章会详细地记录如何使用独立服务器部署waline，大多数只记录了其中某些关键的步骤，容易让新手感到困惑。</p><p>因此在看了官方文档和一些独立部署的文章之后，这里总结了如何从零开始，一步一步地在一台服务器上部署waline。</p><blockquote><p>服务器：腾讯云轻量应用服务器（CentOS 8系统）</p><p>数据库：MySQL</p></blockquote><hr><h2 id="安装node环境"><a href="#安装node环境" class="headerlink" title="安装node环境"></a>安装node环境</h2><p>运行curl命令，下载并运行NodeSource安装脚本。<code>setup_16.x</code>里的16是版本号，可根据自己需要修改。该脚本运行后会将NodeSource签名密钥添加到您的系统，创建yum储存库文件，安装所有必需的软件包，并刷新yum缓存。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -fsSL https://rpm.nodesource.com/setup_16.x | sudo bash<br></code></pre></td></tr></table></figure><p>接着运行以下命令安装Node.js和npm。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo yum install -y nodejs<br></code></pre></td></tr></table></figure><p>安装完成之后，可以运行以下命令判断是否安装成功。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">node --version<br><span class="hljs-comment"># v16.20.0</span><br><br>npm --version<br><span class="hljs-comment"># 8.19.4</span><br></code></pre></td></tr></table></figure><hr><h2 id="配置mysql环境"><a href="#配置mysql环境" class="headerlink" title="配置mysql环境"></a>配置mysql环境</h2><h3 id="安装mysql"><a href="#安装mysql" class="headerlink" title="安装mysql"></a>安装mysql</h3><p>首先通过以下命令确保<code>CentOS系统</code>处于最新的状态。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo yum update<br></code></pre></td></tr></table></figure><p>然后在服务器的任意目录下，使用yum下载MySQL 8.0数据库版本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo wget https://dev.mysql.com/get/mysql80-community-release-el7-3.noarch.rpm<br></code></pre></td></tr></table></figure><p>下载完成后，通过<code>ls</code>指令可以看到<code>mysql80-community-release-el7-3.noarch.rpm</code>已成功下载到服务器上。此时可以执行以下指令安装数据库。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo rpm -Uvh mysql80-community-release-el7-3.noarch.rpm<br></code></pre></td></tr></table></figure><p>安装完成之后，可以直接使用yum安装<code>MySQL Server</code>。在遇到系统提示时输入<code>y</code>并按<code>Enter</code>确认安装即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo yum install mysql-server<br></code></pre></td></tr></table></figure><p>至此，mysql的安装工作已全部完成。</p><h3 id="初始化mysql设置"><a href="#初始化mysql设置" class="headerlink" title="初始化mysql设置"></a>初始化mysql设置</h3><p>安装好mysql之后，需要执行以下指令启动mysql，并查看mysql的状态。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 开启mysql</span><br>service mysqld start<br><span class="hljs-comment"># Redirecting to /bin/systemctl start mysqld.service</span><br><br><span class="hljs-comment"># 查看状态</span><br>service mysqld status<br></code></pre></td></tr></table></figure><p>然后运行以下指令进入mysql。mysql的root用户初始密码默认为空，所以第一次进入时，在输入密码处直接按回车即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mysql -u root -p<br></code></pre></td></tr></table></figure><p>进入mysql之后，先设置一下root的密码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 设置密码，显示指定了使用mysql_native_password的加密方式<br>ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;新密码&#x27;;<br><br># 刷新权限<br>flush privileges;<br></code></pre></td></tr></table></figure><p>完成设置之后通过以下指令退出mysql。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">exit</span>;<br></code></pre></td></tr></table></figure><h3 id="创建waline使用的数据库"><a href="#创建waline使用的数据库" class="headerlink" title="创建waline使用的数据库"></a>创建waline使用的数据库</h3><p>按照<a href="https://waline.js.org/guide/database.html#mysql">官网文档</a>的指引，需要在服务器的任意目录下，创建一个名为<code>waline.sql</code>的文件，然后将官网用于<a href="https://github.com/walinejs/waline/blob/main/assets/waline.sql">创建数据库表结构的文件</a>复制粘贴到<code>waline.sql</code>中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 创建并打开waline.sql文件，具体编辑文件的方式可以查询vim的用法</span><br>vim waline.sql<br></code></pre></td></tr></table></figure><p>完成编辑之后，输入<code>pwd</code>查看并复制<code>waline.sql</code>所在的目录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 这里我直接在root下创建waline.sql文件</span><br><span class="hljs-built_in">pwd</span><br><span class="hljs-comment"># /root</span><br></code></pre></td></tr></table></figure><p>接着用前面设置的密码进入mysql，并创建一个名为<code>waline</code>的数据库。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create database waline;<br><br># 查看是否创建成功<br>show databases;<br></code></pre></td></tr></table></figure><p>然后进入新创建的waline数据库，通过source指令创建表结构。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 将当前数据库切换成waline<br>use waline;<br><br># waline.sql文件所在的目录<br>source /root/waline.sql;<br><br># 查看当前数据库下的表，可以看到wl_Comment，wl_Counter和wl_Users这三张表被创建了<br>show tables;<br></code></pre></td></tr></table></figure><p>最后切换到mysql数据库，将waline数据库的所有权限全部开放给root用户。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 这里指的是切换到一个名为mysql的数据库，这里保存着所有用户数据<br>use mysql;<br><br># 将waline数据库的所有权限全部开放给root用户<br>GRANT ALL ON waline.* TO &#x27;root&#x27;@&#x27;localhost&#x27; ;<br></code></pre></td></tr></table></figure><p>操作完成之后先退出mysql，然后输入以下指令重启mysql服务。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 重启mysql</span><br>service mysqld restart<br></code></pre></td></tr></table></figure><p>此时可以选择删除前面创建<code>waline.sql</code>文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">rm</span> -rf waline.sql<br></code></pre></td></tr></table></figure><hr><h2 id="部署waline"><a href="#部署waline" class="headerlink" title="部署waline"></a>部署waline</h2><h3 id="创建waline项目"><a href="#创建waline项目" class="headerlink" title="创建waline项目"></a>创建waline项目</h3><p>首先，在服务器的任意位置创建一个目录<code>waline-service</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> waline-service<br></code></pre></td></tr></table></figure><p>紧接着在该目录下初始化项目。此步骤会创建<code>package.json</code>文件，该文件用于记录项目所依赖的module，并配置项目的相关属性。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> waline-service<br><br>npm init -y<br></code></pre></td></tr></table></figure><p>初始化完成之后，直接安装waline的服务器依赖包。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install @waline/vercel<br></code></pre></td></tr></table></figure><h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><p>下载完成后，还需要进行环境变量的配置。直接修改全局环境变量配置文件并不是推荐的做法，使用<code>dotenv</code>在<code>不污染全局环境变量配置文件</code>的前提下创建环境变量无疑是更好的做法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 安装dotenv的依赖包</span><br>npm install dotenv<br></code></pre></td></tr></table></figure><p>然后创建环境变量<code>.env</code>文件，并根据官方文档的配置说明写入环境变量配置项。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># waline环境变量配置</span><br><span class="hljs-comment"># 使用的数据库是mysql，所以这里需要设置mysql的相关配置</span><br><br><span class="hljs-comment"># 数据库连接地址</span><br>MYSQL_HOST=127.0.0.1<br><span class="hljs-comment"># 数据库连接端口号</span><br>MYSQL_PORT=3306<br><span class="hljs-comment"># 数据库名</span><br>MYSQL_DB=waline<br><span class="hljs-comment"># 连接数据库用户名</span><br>MYSQL_USER=root<br><span class="hljs-comment"># 连接密码</span><br>MYSQL_PASSWORD=root的密码<br></code></pre></td></tr></table></figure><p>编辑完成之后，新建<code>main.js</code>文件，指定环境变量配置的覆盖逻辑。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 引入dotenv</span><br><span class="hljs-keyword">const</span> dotenv = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;dotenv&#x27;</span>)<br><span class="hljs-comment">// 调用config方法合并.env环境变量</span><br>dotenv.<span class="hljs-title function_">config</span>()<br><span class="hljs-comment">// 引入并执行该文件</span><br><span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;@waline/vercel/vanilla.js&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a>运行项目</h3><p>配置完成之后，可以使用node进程管理工具<code>pm2</code>来运行项目。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 这里需要先全局安装pm2，如果提示权限不足安装失败，需要切换到root用户再重新安装</span><br>npm install -g pm2<br></code></pre></td></tr></table></figure><p>接着创建<code>ecosystem.config.js</code>文件，指定pm2的执行参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">apps</span>: [<br>    &#123;<br>      <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;waline-service&#x27;</span>, <span class="hljs-comment">// 项目名称</span><br>      <span class="hljs-attr">script</span>: <span class="hljs-string">&#x27;./main.js&#x27;</span>, <span class="hljs-comment">// 执行入口</span><br>      <span class="hljs-attr">cwd</span>: <span class="hljs-string">&#x27;./&#x27;</span>, <span class="hljs-comment">// 工作路径</span><br>      <span class="hljs-attr">watch</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 是否开启监听</span><br>      <span class="hljs-attr">ignore_watch</span>: [<span class="hljs-string">&#x27;logs&#x27;</span>, <span class="hljs-string">&#x27;.git&#x27;</span>, <span class="hljs-string">&#x27;node_modules&#x27;</span>], <span class="hljs-comment">// 监听器忽略文件目录</span><br>      <span class="hljs-attr">out_file</span>: <span class="hljs-string">&#x27;./logs/waline_info.log&#x27;</span>, <span class="hljs-comment">// 日志输出路径</span><br>      <span class="hljs-attr">error_file</span>: <span class="hljs-string">&#x27;./logs/waline_err.log&#x27;</span>, <span class="hljs-comment">// 报错日志输出路径</span><br>      <span class="hljs-attr">log_date_format</span>: <span class="hljs-string">&#x27;YYYY-MM-DD HH:mm&#x27;</span>, <span class="hljs-comment">// 日志时间格式 会在每一行日志的前面加上该格式的时间戳</span><br>      <span class="hljs-attr">merge_logs</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 合并日志文件名称</span><br>      <span class="hljs-attr">restart_delay</span>: <span class="hljs-number">1000</span>, <span class="hljs-comment">// 崩溃重启服务时间间隔</span><br>      <span class="hljs-attr">max_restarts</span>: <span class="hljs-number">3</span> <span class="hljs-comment">// 崩溃后重启次数</span><br>    &#125;<br>  ]<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>然后修改package.json里的<code>scripts</code>字段配置启动项，让pm2使用<code>ecosystem.config.js</code>文件的执行参数运行项目。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  ...<br>  <span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;start&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;pm2 start ./ecosystem.config.js&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;stop&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;pm2 stop waline-service&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;log&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;pm2 log waline-service&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;status&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;pm2 status&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  ...<br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>最后，执行以下指令运行项目。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 运行项目</span><br>npm run start  <br><br><span class="hljs-comment"># 其他常用的指令</span><br>npm run stop    <span class="hljs-comment"># 停止服务</span><br>npm run <span class="hljs-built_in">log</span>     <span class="hljs-comment"># 查看服务日志</span><br>npm run status  <span class="hljs-comment"># 查看服务运行状态</span><br></code></pre></td></tr></table></figure><p>除此之外，还可以使用pm2设置waline项目开机自启动，具体命令如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 在项目运行期间执行，保存当前任务</span><br>pm2 save<br><br><span class="hljs-comment"># 将保存的任务生成开机自启动服务配置pm2-root.service</span><br>pm2 startup<br><br><span class="hljs-comment"># 允许任务开机自启动</span><br>systemctl <span class="hljs-built_in">enable</span> pm2-root<br></code></pre></td></tr></table></figure><hr><h2 id="使用waline"><a href="#使用waline" class="headerlink" title="使用waline"></a>使用waline</h2><h3 id="注册管理员并测试"><a href="#注册管理员并测试" class="headerlink" title="注册管理员并测试"></a>注册管理员并测试</h3><p>waline默认使用8360端口，因此需要确保云服务器的8360端口处于开放的状态。以腾讯云的轻量应用服务器为例，需要手动添加一个开放8360端口的<code>安全组</code>。</p><p><img src="https://blog-images-1253364479.cos.ap-guangzhou.myqcloud.com/image-20230604125546557.png" alt="开放8360端口"></p><p>然后可以在浏览器输入<code>http://服务器公网IP:8360/</code>进入waline的测试界面。此时点击<code>login</code>则会出现登录界面，点击注册或者使用关联账号登录之后，waline会默认将第一个用户注册为后台管理员。</p><p><img src="https://blog-images-1253364479.cos.ap-guangzhou.myqcloud.com/image-20230604020556416.png" alt="waline测试界面"></p><p>注册完成之后，可以输入<code>http://服务器公网IP:8360/ui</code>进入后台管理系统，并在里面管理评论数据。</p><p><img src="https://blog-images-1253364479.cos.ap-guangzhou.myqcloud.com/image-20230604021129648.png" alt="waline后台管理界面"></p><h3 id="在hexo中接入waline"><a href="#在hexo中接入waline" class="headerlink" title="在hexo中接入waline"></a>在hexo中接入waline</h3><p>hexo并没有默认接入waline，但开发者可以在自主开发的主题中接入。</p><p>对于支持waline的hexo主题来说，接入waline最重要的参数是<code>serverURL</code>，也就是前边用于测试评论效果的<code>http://服务器公网IP:8360/</code>。</p><p>以本博客使用的<a href="https://hexo.fluid-dev.com/docs/guide/#%E8%AF%84%E8%AE%BA">hexo-fluid-theme</a>为例，只需要在<code>_config.fluid.yml</code>中开启评论功能之后，在填入上述链接即可。</p><p><img src="https://blog-images-1253364479.cos.ap-guangzhou.myqcloud.com/image-20230604132649089.png" alt="_config.fluid.yml"></p><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://www.wstee.com/2022/08/22/self-host-waline.html">独立部署waline评论系统</a></li><li><a href="https://anyfork.github.io/blog-docs/posts/other/walineServer.html">Waline 服务端独立部署解决方案</a></li><li><a href="https://loclink.cn/views/articles/back-end/waline-service.html#%E5%88%9D%E5%A7%8B%E5%8C%96%E6%95%B0%E6%8D%AE%E5%BA%93">Waline 服务端一键独立部署解决方案</a></li><li><a href="https://www.51cto.com/article/741252.html">在CentOS 7上安装 MySQL 保姆级教程</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>个人博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>waline</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UE4的物理同步</title>
    <link href="/posts/84142416/"/>
    <url>/posts/84142416/</url>
    
    <content type="html"><![CDATA[<h2 id="1-为什么需要物理同步"><a href="#1-为什么需要物理同步" class="headerlink" title="1. 为什么需要物理同步"></a>1. 为什么需要物理同步</h2><p>在网络游戏中，如果场景中某个可以<code>与玩家所操作的对象发生交互</code>的物体需要<code>借助物理引擎的模拟</code>来得到正确的<code>位置</code>和<code>朝向</code>，那么需要确保在不同客户端上的模拟结果一致。</p><p>如果可以保证物理引擎的每一次模拟结果是确定的，那么仅需要同步每次玩家操作，就能保证不同客户端的模拟结果一致。但大部分物理引擎（如UE4使用的PhysX物理引擎）都是不确定性物理引擎，其模拟结果受不同平台浮点数精度不同等问题影响，在不同客户端上的物理模拟结果常常不一致。</p><blockquote><p>之所以大部分物理引擎都是不确定性物理引擎，是因为确定性物理引擎有以下劣势：</p><ol><li>需要使用定点数来代替浮点数进行物理运算，且需要确保每个客户端用于随机运算的随机数种子一致；</li><li>定点数的运算消耗大于浮点数，且能表示的数值范围远小于浮点数；</li><li>所有与物理相关的数据都需要用定点数表示（如碰撞体数据、地形数据等），需要编写专门的数据转换工具；</li></ol></blockquote><p>如果仅仅让不同客户端分别独立进行物理模拟，而不进行物理同步。那么在网络延迟的作用下，不同客户端的状态差异会让物理模拟上的细微差异迅速放大，从而让不同客户端失去同步。</p><blockquote><p>（1）<code>主控端</code>的预表现会让<code>玩家所控制的角色</code>状态先于服务器；<br><img src="https://blog-images-1253364479.cos.ap-guangzhou.myqcloud.com/CA16C895E44049B1B512DC1274786B04.png" alt="CA16C895E44049B1B512DC1274786B04"><br>（2)如果不进行物理同步，那么主控端上玩家控制的角色踢到了球，但服务器的球则会因为没有接触玩家所控制的角色而继续向前运动，从而导致不同步的问题；<br><img src="https://blog-images-1253364479.cos.ap-guangzhou.myqcloud.com/9CE09B822481471F9C185FCDA4394C5F.png" alt="9CE09B822481471F9C185FCDA4394C5F"></p></blockquote><hr><h2 id="2-物理同步的基本策略"><a href="#2-物理同步的基本策略" class="headerlink" title="2. 物理同步的基本策略"></a>2. 物理同步的基本策略</h2><h3 id="2-1-物理同步需要解决的问题"><a href="#2-1-物理同步需要解决的问题" class="headerlink" title="2.1 物理同步需要解决的问题"></a>2.1 物理同步需要解决的问题</h3><p>使用非确定性物理引擎的网络游戏没办法使用帧同步作为网络同步方案，因此这里主要讨论状态同步下的物理同步策略。</p><p>状态同步的思路是客户端将输入上传到服务器后，由服务器计算出结果，再将发生变化的状态广播给所有客户端，让客户端在本地更新渲染数据。如果按照这个思路，服务器将物理状态同步给客户端，而客户端只负责渲染本地数据，会有以下几个问题：</p><ol><li>为了节省带宽会降低服务器的同步频率（每秒10帧左右），导致物体移动很不平滑（帧率过低）；</li><li>玩家的操作需要等待一个<code>RTT（往返时延）</code>之后才会在客户端上生效，再加上网络的不稳定性（丢包或者卡顿），输入延迟较大；</li></ol><p>如何让客户端上的物体能及时、平滑地正确运动，是物理同步需要解决的问题。</p><h3 id="2-2-内插值（Interpolation）"><a href="#2-2-内插值（Interpolation）" class="headerlink" title="2.2 内插值（Interpolation）"></a>2.2 内插值（Interpolation）</h3><p>内插值是一种常用的物理同步方案，其基本思路是仅同步物体的<code>位置</code>和<code>朝向</code>，在收到的两个数据包间通过<code>线性插值（Lerp）</code>插入过渡数据，从而让物体移动的视觉效果更加平滑。</p><p>虽然内插值解决了物体移动不平滑的问题，但解决不了输入延迟的问题，且会引入新的问题：</p><ol><li>在收到数据包时不能立刻应用，必须等下一个数据包到来才可以开始插值，延迟增加；</li><li>如果网络延迟比较高，那么会停住直到下一个数据包到来；</li><li>在运动状态发生剧烈变化时，会丢失部分的运动状态；</li></ol><p><img src="https://blog-images-1253364479.cos.ap-guangzhou.myqcloud.com/5F5C2EB7D44342B481FEFBD7CC6C7E91.gif" alt="5F5C2EB7D44342B481FEFBD7CC6C7E91"></p><blockquote><p>左侧客户端丢失了一次往返运动</p></blockquote><h3 id="2-3-外插值（Extrapolation）"><a href="#2-3-外插值（Extrapolation）" class="headerlink" title="2.3 外插值（Extrapolation）"></a>2.3 外插值（Extrapolation）</h3><p>外插值的基本思路是，通过额外同步<code>线速度</code>、<code>角速度</code>、<code>加速度</code>和<code>网络延迟</code>等数据，在收到数据包时直接推测出下一个数据包的状态，从而降低延迟。</p><p>与内插值相比，外插值因为不需要等下一个数据包，所以会少一个RTT的延迟。但因为外插值需要等服务器发回来的数据包，所以并不能解决<code>输入延迟</code>的问题。</p><p>此外，外插值会根据当前的运动状态预测出下一个数据包的状态，所以即便运动状态有变化，也可以很好地预测。但如果发生了碰撞，那么简单的预测无法模拟出正确的物理结果，此时则需要让客户端也进行物理模拟。</p><p><img src="https://blog-images-1253364479.cos.ap-guangzhou.myqcloud.com/015CD5D20C304B90877924B6E27F15AE.gif" alt="015CD5D20C304B90877924B6E27F15AE"></p><p>当然，因为物理引擎的不确定性，即便让客户端也进行物理模拟，其最后的模拟结果也不一定正确。再加上在网络情况不稳定、运动方向频繁改变等情况下，外插值的预测结果非常容易出错，由此引入了新的问题：</p><ol><li>如何判断外插值的预测结果是否正确；</li><li>如何从错误的预测结果平滑过渡到正确的运动状态；</li></ol><h3 id="2-4-导航推测算法"><a href="#2-4-导航推测算法" class="headerlink" title="2.4 导航推测算法"></a>2.4 导航推测算法</h3><p><code>导航推测算法（Dead Reckoning Algorithm，简称DR）</code>是一个利用物体位置及速度推定未来位置方向的<code>航海技术</code>，后被用于在网络游戏中<code>预测物体未来的位置</code>并<code>计算物体的运动轨迹</code>。</p><p>Murphy在<a href="https://www.researchgate.net/publication/293809946_Believable_Dead_Reckoning_for_Networked_Games">Believable Dead Reckoning for Networked Games</a>一文中提出了一个可以用于预测物体未来位置的公式。</p><p><img src="https://blog-images-1253364479.cos.ap-guangzhou.myqcloud.com/7C457560CE134A1784C9D384EC62C1BD.png" alt="7C457560CE134A1784C9D384EC62C1BD"></p><blockquote><p>假设服务器告诉客户端，物体当前正处于位置P0’，并以V0’的速度和A0’的加速度向前运动。那么可以预测时间T之后，服务器上的物体将会处于位置Qt</p></blockquote><p>当然，如果服务器在通知客户端之后立即转向，那么客户端将会得到一个错误的预测结果。</p><p><img src="https://blog-images-1253364479.cos.ap-guangzhou.myqcloud.com/F73ABF49266448F5BFDD0DA2B9A6D7A8.png" alt="F73ABF49266448F5BFDD0DA2B9A6D7A8"></p><blockquote><p>P0是客户端的预测结果，而P’0是物体在服务器上的位置。</p></blockquote><p>针对这种预测错误的情况，最简单的处理方法是直接将物体在客户端的位置切换到P’0，然后开始新一轮的预测。显然，这样做的效果非常不好，让物体沿着平滑的运动轨迹逐渐切换到正确的运动状态是更加理想的做法。</p><p>在预测的点P0到实际的点P’0之间计算出一条曲线有很多种方法，比如<code>三次贝塞尔曲线（Cubic Bezier Curve）</code>。但出于CPU开销、曲线平滑度等因素的考虑，Murphy提出了一种名为<code>Projective Velocity Blending</code>的算法，它使用简单的线性插值去计算物体的运动轨迹，并能很好地消除速度变化对轨迹的影响。</p><p><img src="https://blog-images-1253364479.cos.ap-guangzhou.myqcloud.com/72B5AB84C4D84FFA9F78647B61C5DC2B.png" alt="72B5AB84C4D84FFA9F78647B61C5DC2B"></p><p><img src="https://blog-images-1253364479.cos.ap-guangzhou.myqcloud.com/FBBC579333D641738956CB365BD4D56E.png" alt="FBBC579333D641738956CB365BD4D56E"></p><blockquote><p>整个算法的思路非常简单，那就是接受客户端预测失败的事实，然后想办法让客户端在每次预测的时候尽量多靠近服务器真实状态一点，从而确保客户端沿着一个平滑的轨迹不断修正预测结果。<br>（1）先用线性插值纠正客户端的速度，得到速度Vb；<br>（2）然后利用前面提到的公式，分别计算出T秒后<code>客户端的位置Pt</code>和<code>服务器的位置P&#39;t</code>；<br>（3）最后再使用线性插值，进一步纠正客户端的位置，算出一个<code>更接近服务器预测位置的Qt</code>；</p></blockquote><h3 id="2-5-纠错机制"><a href="#2-5-纠错机制" class="headerlink" title="2.5 纠错机制"></a>2.5 纠错机制</h3><p>尽管<code>Projective Velocity Blending</code>算法可以很好地纠正大部分预测错误的情况，但在预测结果偏差很大时，客户端的运动轨迹与服务器的运动轨迹的差异也会很大，其纠正所需的时间也会越长。期间出现碰撞等问题导致客户端的运动状态与服务器的运动状态差异变得更大的可能性也就越高。</p><p><img src="https://blog-images-1253364479.cos.ap-guangzhou.myqcloud.com/BCB3FB9403FE474494707AED081EB412.png" alt="BCB3FB9403FE474494707AED081EB412"></p><blockquote><p>红色线表示物体在客户端上的运动轨迹，而绿色线则表示物体在服务器的运动轨迹。<br>客户端在沿着红色虚线这一计算出来的轨迹运动时，与蓝色物体发生了碰撞，导致与服务器的运动状态差异更大。</p></blockquote><p>因此，在差异过大时（尤其是地形比较复杂，障碍物比较多的场景），直接强行将客户端纠正到服务器下发的最新运动状态是很有必要的。</p><p>一般来讲，可以通过以下几个指标来衡量客户端与服务器的差异程度。</p><ol><li>位置距离大小；</li><li>朝向夹角大小；</li><li>速度方向的夹角大小；</li></ol><p>然后通过设定阈值的方式，在某一指标差异过大时，直接纠正客户端的<code>运动状态（位置、朝向和速度等）</code>，再进行下一次的预测。</p><hr><h2 id="3-UE4的物理同步"><a href="#3-UE4的物理同步" class="headerlink" title="3. UE4的物理同步"></a>3. UE4的物理同步</h2><h3 id="3-1-主要流程"><a href="#3-1-主要流程" class="headerlink" title="3.1 主要流程"></a>3.1 主要流程</h3><p>UE4是在其网络同步框架的基础上实现物理同步，其主要流程如下所示。</p><p><img src="https://blog-images-1253364479.cos.ap-guangzhou.myqcloud.com/719AF098A2474293A2A5726AADC7A026.png" alt="719AF098A2474293A2A5726AADC7A026"></p><p>其中，服务器在每一帧的物理模拟结束之后，将物体的物理数据存放进类型为<code>FRepMovement</code>的成员变量<code>ReplicatedMovement</code>，并由UE4的网络同步框架将其同步至客户端。</p><p>在被同步至客户端之后，ReplicatedMovement的数据会在<code>AActor::PostNetReceivePhysicState函数里</code>被拷贝至一个类型为<code>FRigidBodyState</code>的变量，最后将其添加到<code>FPhysicsReplication</code>的<code>ComponentsToTargets</code>队列中，并准备执行物理同步逻辑。</p><p><img src="https://blog-images-1253364479.cos.ap-guangzhou.myqcloud.com/C0E01D1895A34847959F0BBB1C314E9C.png" alt="C0E01D1895A34847959F0BBB1C314E9C"></p><blockquote><p>FRepMovement用于同步物体的物理数据，而FRigidBodyState则用于记录物体的物理状态。</p><p>考虑到float的表示范围在大部分游戏场景下都是大大溢出的，可以在传输时对其进行压缩，减少数据量。但是float遵循IEEE754标准，在网络上传输float无法使用自适应Bit流来减小数据量，导致直接传输FVector就必须用12个Byte，有些浪费。</p><p>因此，UE4在FRepMovement中定义了针对<code>Location</code>、<code>Velocity</code>和<code>Roation</code>这三个变量的压缩等级，在将其序列化前根据压缩等级对FVector进行有损压缩。至于<code>FRigidBodyState</code>中使用的<code>FVector_NetQuantize100</code>则是封装了压缩操作的数据结构。</p></blockquote><p>物理同步逻辑执行完之后，客户端再以同步后的物理状态继续物理模拟，从而得到同步之后最新的物理结果。</p><h3 id="3-2-物理同步逻辑"><a href="#3-2-物理同步逻辑" class="headerlink" title="3.2 物理同步逻辑"></a>3.2 物理同步逻辑</h3><p>UE4在<code>FPhysicsReplication::ApplyRigidBodyState方法</code>里使用<code>导航预测算法</code>实现了物理同步逻辑，这里主要讨论UE4是如何应用导航预测算法的。</p><h4 id="3-2-1-预测逻辑"><a href="#3-2-1-预测逻辑" class="headerlink" title="3.2.1 预测逻辑"></a>3.2.1 预测逻辑</h4><p>从<code>2.3节</code>可以知道，外插值可以很好地解决物理同步中的延迟问题。因此，在收到服务器同步的数据包之后，UE4首先通过外插值的方式，推测出此时物体在服务器上的物理状态。</p><p><img src="https://blog-images-1253364479.cos.ap-guangzhou.myqcloud.com/ABF2CF247DBC41F48E5B87B1ED61C69D.png" alt="ABF2CF247DBC41F48E5B87B1ED61C69D"></p><p>下图更加直观地展示了预测的过程。在知道服务器同步数据包时的物理状态和数据包的传输延迟的前提下，利用导航预测算法给出的公式，就能很好的预测在同一时刻下，物体在服务器上的物理状态。</p><p><img src="https://blog-images-1253364479.cos.ap-guangzhou.myqcloud.com/72469268A0DD4E27BC43CE0F81F9B559.png" alt="72469268A0DD4E27BC43CE0F81F9B559"></p><blockquote><ol><li>圆形表示物理同步的目标；</li><li>三角形表示场景中的静态物体，用于体现圆形物体的运动状态变化；</li><li>虚线方框表示某个时刻下的场景状态；</li></ol></blockquote><p>接下来，只需要消除<code>客户端的实际物理状态</code>与<code>服务器的预测状态</code>之间的差异，就可以消除网络延迟的影响，实现物理同步。</p><h4 id="3-2-2-纠错逻辑"><a href="#3-2-2-纠错逻辑" class="headerlink" title="3.2.2 纠错逻辑"></a>3.2.2 纠错逻辑</h4><p>为了让客户端的运动轨迹更加平滑自然，UE4采用了一种名为<code>错误累积（Error Accumulation）</code>的纠错机制。</p><p>首先计算<code>客户端的实际物理状态</code>与<code>服务器的预测状态</code>之间的<code>距离差</code>和<code>夹角大小</code>，若这两个数值的<code>加权和</code>小于预设的阈值，说明此时客户端与服务器是完全同步的，无须执行任何纠正逻辑，并通过设置<code>bRestoredState</code>为true来表示该物体在收到新的数据包之前无需再进行物理同步逻辑。</p><p><img src="https://blog-images-1253364479.cos.ap-guangzhou.myqcloud.com/89AC412420814203BD67867CC8E75FB4.png" alt="89AC412420814203BD67867CC8E75FB4"></p><p>如果大于阈值，则会执行纠错逻辑。如果两者距离差不是很大，那么会尝试通过导航预测算法里的<code>Projective Velocity Blending</code>让客户端以平滑的曲线不断接近服务器的预测状态，直到这两者差距足够小，不需要再进行物理同步为止。</p><p><img src="https://blog-images-1253364479.cos.ap-guangzhou.myqcloud.com/4D0818374D764652A85B16BF40B32AA4.png" alt="4D0818374D764652A85B16BF40B32AA4"></p><blockquote><p>虽然这里和<code>2.5节</code>里给出的计算方式不完全一样，但仔细推导，就会发现思路其实很像；</p><ol><li>不难知道<code>TargetPos</code>是预测的位置P’t，而<code>NewLinVel</code>则是修正后的速度Vb；</li><li>使用<code>TargetPos(P&#39;t)</code>和<code>CurrentState.Position(P0)</code>插值得到NewPos用于纠正物体的位置；</li><li>在网络同步处理完之后，使用修正后的速度Vb进行物理模拟，这中间的位移等效于(Pt - P0)；</li><li>因此，最终物体的位置Qt &#x3D; P0 + (P’t - P0) * ΔT + (Pt - P0) &#x3D; Pt + (P’t - P0) * ΔT；</li></ol></blockquote><p>为了判断本次纠正是否有效，会计算<code>PrevProgress</code>和<code>PrevSimilarity</code>这两个指标并分别与设置的阈值比较。如下图所示，<code>PrevProgress</code>表示上一次修正的有效程度，而<code>PrevSimilarity</code>则表示上一次修正之后，客户端实际位置与当前预测位置的差异大小。</p><p><img src="https://blog-images-1253364479.cos.ap-guangzhou.myqcloud.com/B5E93E08C9294083BAC081A2888475A4.png" alt="B5E93E08C9294083BAC081A2888475A4"></p><blockquote><p>如果纠正有效，客户端沿着正确的轨迹朝预测位置不断靠近：</p><ol><li>在客户端每帧运动的距离不变的前提下（蓝色线长度不变），蓝色线与绿色线会不断趋于平行，也就是<code>PrevProgress</code>的值会不断变大；</li><li>客户端与预测位置的距离差会不断变小，也就是红色线的长度会不断变小，也就是<code>PrevSimilarity</code>会不断变小；</li></ol><p>值得注意的是，<code>PrevSimilarity</code>过大有可能不是纠正无效，而是收到了新的数据包，预测位置发生了变化。因此需要同时结合<code>PrevProgress</code>来判断客户端是否确实在沿着正确的轨迹不断靠近。<br><img src="https://blog-images-1253364479.cos.ap-guangzhou.myqcloud.com/58E982BF1DA24F99B72518EB204E2A04.png" alt="58E982BF1DA24F99B72518EB204E2A04"></p></blockquote><p>确定了如果判断纠正是否有效的方法之后，再来考虑<code>2.5节提到的问题</code>：如果在纠正过程中，因为碰撞或者其他原因，导致客户端实际位置与预测位置的状态差异更大了，该如何处理？</p><p>如果在发生错误时立刻将其拉扯到预测位置，那么表现效果会很差，卡顿感会很明显。但如果长时间不干涉，差异则有可能越来越大，直到失去同步。</p><p>对此，UE4给出的结果方案是，每次在发现纠正逻辑无法让客户端靠近预测位置时，先暂时相信客户端的纠错能力，只累积错误时间而不做其他处理，然后继续纠正。直到错误时间累积足够久（在一定时间内客户端始终无法完成纠错），或者两者的距离差距足够大时，才触发<code>Hard Snap</code>操作，直接将客户端拉扯到服务器的预测状态上，从而一定程度上减少物理同步时的卡顿感。</p><p><img src="https://blog-images-1253364479.cos.ap-guangzhou.myqcloud.com/F9DEFDE4922846A5B9D80B967A24A40C.png" alt="F9DEFDE4922846A5B9D80B967A24A40C"></p><blockquote><p>触发HardSnap操作之后，客户端的位置显然与预测位置是同步的，后面自然不需要再执行物理同步逻辑。故这里直接将<code>bRestoredState</code>设置为true，并清空累积的错误时间。</p></blockquote><h4 id="3-2-3-参数配置"><a href="#3-2-3-参数配置" class="headerlink" title="3.2.3 参数配置"></a>3.2.3 参数配置</h4><p>为了在客户端有更好的表现，UE4允许允许根据项目的实际情况，配置错误阈值等各种参数。如下图所示，在Project Setting里，可以配置物理同步的各个参数，以获得不同的物理同步效果。</p><p><img src="https://blog-images-1253364479.cos.ap-guangzhou.myqcloud.com/4069096125D44B189C4C8FC1ADE64A05.png" alt="4069096125D44B189C4C8FC1ADE64A05"></p><hr><h2 id="4-一些小缺陷"><a href="#4-一些小缺陷" class="headerlink" title="4. 一些小缺陷"></a>4. 一些小缺陷</h2><p>虽然到这里，UE4物理同步的大致逻辑已被梳理清楚，但仍有一个十分重要的点还没讨论到，那就是如何处理物体角速度和朝向的同步？</p><p>UE4的处理逻辑十分简单，依旧是通过<code>&quot;预测+插值平滑&quot;</code>的方式来出处理物体的朝向同步逻辑。尽管这个方法在处理<code>物体的位置同步</code>上效果非常好，但在处理<code>物体的朝向同步</code>时，表现则比较差。如下图所示，相同的方法，可以计算出一条平滑的位置同步曲线，但只能得到一条来回波动的朝向同步折线。</p><p><img src="https://blog-images-1253364479.cos.ap-guangzhou.myqcloud.com/25C68A9A593A499EBC7DA61809D23F8B.png" alt="25C68A9A593A499EBC7DA61809D23F8B"></p><blockquote><p>这个例子也许不是十分恰当，但能比较简单、直观地说明在处理物体的朝向同步时出现频繁抖动的原因。</p></blockquote><p>如果将每个帧的运动轨迹叠加起来，那么可以得到一个锯齿状的朝向同步折线。也就是说，物体在持续改变方向时，抖动感会非常明显。造成这一现象的主要原因，就是因为朝向同步的要求比位置同步的要求更为苛刻。位置同步只需要确保最终的轨迹平滑就可以了，而朝向同步则是在平滑的基础上尽可能避免来回波动。</p><p><img src="https://blog-images-1253364479.cos.ap-guangzhou.myqcloud.com/0BFF01D335474FE2A9AAFAACEE364F71.gif" alt="0BFF01D335474FE2A9AAFAACEE364F71"></p><blockquote><p>在位置上来回波动几厘米肉眼可能感知到不到，但如果在朝向上来回波动几度，那么玩家则可以明显感知到物体的抖动，尤其是玩家当前正在操作、有摄像机跟随的物体。</p></blockquote><p>修复这一问题的方法有很多，其中最简单的一个方法是通过修改参数减小朝向的预测幅度，从而尽可能减少朝向在修正过程中来回波动的情况。</p><p><img src="https://blog-images-1253364479.cos.ap-guangzhou.myqcloud.com/7FEBBEBCC2894B53BD88F921261FD2E9.gif" alt="7FEBBEBCC2894B53BD88F921261FD2E9"></p><blockquote><p>在Project Setting里，将物理同步参数里的<code>Angle Lerp</code>从默认的0.4改成0.2，可以看到物体的抖动幅度明显降低。</p></blockquote><hr><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>总体来说，UE4的物理同步逻辑能很好地满足大部分使用场景的需求，但并没有做到完美。玩家在操作高速运动、且频繁改变运动方向的物体时（如驾驶载具时），UE4的物理同步逻辑会导致物体持续抖动。</p><p>尽管通过调整物理同步的参数可以缓解这一问题，但始终是治标不治本。最佳的方案是根据游戏的实际需求自定义物理同步逻辑。</p><hr><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol><li><p><a href="https://zhuanlan.zhihu.com/p/341447703">浅谈物理引擎的网络同步方案</a></p></li><li><p><a href="https://www.researchgate.net/publication/293809946_Believable_Dead_Reckoning_for_Networked_Games">Believable Dead Reckoning for Networked Games</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/114341957">UE4移动的网络同步，”关于FVector_NetQuantize一节”</a></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>UnrealEngine的苦痛之路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>UE4</tag>
      
      <tag>物理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《C++回顾笔记》取模运算与取余运算</title>
    <link href="/posts/ad89a9b/"/>
    <url>/posts/ad89a9b/</url>
    
    <content type="html"><![CDATA[<p>对于整型数a，b来说，取模运算和取余运算的计算方法是一样的：</p><ol><li>求整数商：c &#x3D; a&#x2F;b;</li><li>取余和取模：r &#x3D; a - c * b;</li></ol><p>取模运算和取余运算的区别在于第一步对计算结果舍入的方式不同：取模运算在计算c的值时，会将结果<code>向负无穷方向舍入</code>，而取余运算在取c的值时，<code>向0方向舍入</code>。</p><blockquote><p>例如-1对256取模和取余时：</p><ol><li>求整数商c，取模将结果向负无穷方向舍入得到-1，而取余则将结果向0方向舍入得到0；</li><li>将算出的整数商c代入计算r的公式，得到取模的结果为255，而取余的结果为-1；</li></ol></blockquote><p>当整数a和b的符号一致时，易知其整数商必大于或者等于0，取模运算和取余运算对其舍入后的结果也一致，所以此时取模运算和取余运算的结果是一样的。<br>当整数a和b的符号不一致时，易知其整数商必小于或者等于0，因此可以得到：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">r = a + |a| * <span class="hljs-built_in">sign</span>(b) * s<br></code></pre></td></tr></table></figure><p>其中，<code>sign(b)</code>表示b的符号<code>(b大于0时，其为1；小于0时其为-1)</code>。而<code>s</code>表示舍入后整数商对原始商的变化倍数。易知对于取模运算来说，<code>s</code>必大于1，而对于取模运算来说，<code>s</code>必小于1。也就是说，<code>当a和b的符号不一致时，求模运算结果的符号和b一致，而求余运算结果的符号和a一致</code>。</p><p>最后，需要注意的是，在不同的语言里，运算符<code>%</code>表示的含义不一致，有的语言认为%表示取模运算<code>(如Python)</code>，但在C&#x2F;C++里，<code>%</code>表示取余运算。</p>]]></content>
    
    
    <categories>
      
      <category>《C++回顾笔记》</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>漫话帧同步</title>
    <link href="/posts/c090c893/"/>
    <url>/posts/c090c893/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&amp;emsp;&amp;emsp;帧同步作为网络游戏经常使用的一种同步方案，网络上介绍帧同步原理和具体实现的技术文章俯拾皆是。因此，本文也不再班门弄斧，而只是将一些写得很好的文章加以归纳整理，并结合自己在实际应用中对帧同步的一些理解对一些观点进行补充，以期达到让没接触过帧同步的人在看完本文章之后能快速了解帧同步的相关知识。</p><hr><h2 id="网络游戏究竟在同步什么"><a href="#网络游戏究竟在同步什么" class="headerlink" title="网络游戏究竟在同步什么"></a>网络游戏究竟在同步什么</h2><p>&amp;emsp;&amp;emsp;对于一个电子游戏来说，其最重要的要素可以粗略地分为三个部分：<code>玩家输入</code>、<code>游戏逻辑</code>和<code>画面反馈</code>。当玩家通过UI交互或者其他方式产生游戏输入的时候，游戏逻辑会执行相应的运算产生游戏结果，然后再交给游戏引擎的渲染模块渲染成相应的画面，给予玩家反馈。如果是网络游戏，那么玩家除了希望看到自己输入产生的画面反馈外，他必定也想看到其他玩家的输入产生的画面反馈。<br>&amp;emsp;&amp;emsp;因此，不难知道，网络游戏除了需要<code>同步游戏结果(数据同步)</code>，还需要<code>同步游戏画面(表现同步)</code>。数据同步是<code>服务器端</code>的操作，而表现同步就是让<code>客户端</code>对<code>服务器端</code>同步过来的数据进行进一步的处理从而达到游戏画面上的一致。</p><hr><h2 id="状态同步和帧同步"><a href="#状态同步和帧同步" class="headerlink" title="状态同步和帧同步"></a>状态同步和帧同步</h2><p>&amp;emsp;&amp;emsp;文章<a href="https://zhuanlan.zhihu.com/p/130702310">细谈网络同步在游戏历史中的发展变化（上）</a>详细地谈到了网络游戏的发展历程。从把每个玩家把自己操作数据同步给其他玩家再分别运算出游戏结果的<code>P2P架构</code>，再到采用<code>专有服务器</code>来收集、处理、转发玩家请求的<code>CS架构</code>，后面很自然地就出现了以某个玩家作为Host主机的CS架构，这样每个玩家都可以作为服务器，不需要维护专门的服务器，节省服务器的运行和开发成本，这种方式被其为<code>Packet Server</code>。不过，虽说叫CS架构，但这种架构本质上还是P2P模型，依旧存在<code>P2P模型的缺点（Host主机如果网络不好会影响到所有玩家；所有的逻辑都在Host主机上执行，存在Host主机作弊对其他玩家不公平的风险）</code>。</p><p>&amp;emsp;&amp;emsp;在网络游戏刚出现的时候，大部分网络游戏都属于<code>弱交互游戏（对操作的实时性要求不高）</code>， 可以将它们简单理解为一种<code>回合制游戏</code>：在<code>每个回合开始</code>时，所有玩家一同思考并把相关操作指令信息发送给其他玩家，其他玩家收到了别人的消息后就会在本地处理然后<code>结束当前回合</code>，如果没有收到就会进入<code>无限期的等待</code>。由于每个回合有<code>比较长的思考和操作时间</code>，所以<code>网络延迟</code>可以忽略不计，只要保证在<code>回合结束</code>的时候，<code>所有玩家的状态和数据保持一致</code>即可。这种游戏采用的同步方式是一种很自然也很简单的同步模型，但随着游戏的种类和玩法复杂性的提升，其面对的问题也接踵而来：</p><blockquote><p>&amp;emsp;&amp;emsp;节选至<a href="https://zhuanlan.zhihu.com/p/130702310">细谈网络同步在游戏历史中的发展变化（上）</a>:</p><ol><li><code>在CS架构下逻辑在客户端执行还是在服务器执行？</code>如果逻辑都在服务器执行，那么客户端的操作都会被发送到服务器运算，服务器计算出结果后通知客户端，客户端拿到结果后再做表现，这样的好处是所有的逻辑由服务器处理和验证，客户端无法作弊，但坏处是会造成客户端的资源被浪费，服务器运算压力过大。如果逻辑在各个客户端执行，那么玩家可以在本地计算后再把本地得到的结果告知服务器，服务器只进行简单的转发，这样的好处是玩家的本地表现很流畅，但坏处是很容易在本地进行作弊。而对于P2P架构，反作弊更是一个严重的问题，我连一个权威服务器都没有，根本无法验证其他客户端消息的真伪，怎么知道其他玩家有没有作弊？</li><li><code>要发送什么数据来进行同步？</code>如果发送每个对象当前的状态，那么如果一个游戏里面有大量的角色，就会大规模的占用网络带宽，造成数据拥塞、丢包等等问题。如果发送玩家指令，那这个指令是要服务器执行还是服务器转发？而且对于大型多人在线游戏又没必要处理所有不相关的玩家信息，同样浪费网络资源。</li><li><code>选择哪种计算机网络协议来进行同步？</code>TCP、UDP还是Http？</li></ol></blockquote><p>&amp;emsp;&amp;emsp;对于不同的游戏类型，在考虑上述的问题时很自然地会有不同的解决方案。对于某些不同的解决方案来说，它们可能会存在一些<code>共性（因为本来就是解决同一类问题）</code>，为了方便在开发新的网络游戏时快速地选定<code>合适的游戏同步方案</code>，许多开发团队不约而同地尝试对不同类型的同步方案做<code>广义上的区分</code>，因此便有了<code>帧同步</code>和<code>状态同步</code>这样的说法，用于描述<code>侧重点不同</code>、<code>适合不同游戏类型</code>的两大类同步方案。</p><blockquote><p>&amp;emsp;&amp;emsp;当然，也正因为<code>状态同步</code>和<code>帧同步</code>只是两个广义上的分类，所以在为某个具体的游戏来选择同步方案的时候，需要开发团队做一些<code>更加细节、更加具体的抉择和优化</code>。</p></blockquote><p>&amp;emsp;&amp;emsp;一般来讲，状态同步泛指<code>允许各个客户端的外在表现不同，只确保它们内部的逻辑状态统一</code>的<code>弱同步方案</code>，典型的状态同步方案便是客户端将<code>玩家操作</code>或者<code>局部状态</code>交给服务器，由<code>服务器</code>来运算出游戏内的<code>全局状态</code>，最后由服务器把游戏内的全局状态分发给所有客户端，让客户端根据这些状态渲染出对应的画面。</p><p>&amp;emsp;&amp;emsp;与之相对的，帧同步则泛指<code>保证各个客户端在每个逻辑帧输入一致，并得到相同的结果</code>的<code>强同步方案</code>，典型的帧同步方案便是客户端将<code>玩家操作</code>交给服务器，而服务器只负责将在<code>单个逻辑帧</code>内收集到的<code>所有客户端的玩家操作</code>转发给所有客户端，由客户端自己运算出游戏内的全局状态，再渲染出对应的画面。</p><blockquote><p>&amp;emsp;&amp;emsp;文章<a href="https://zhuanlan.zhihu.com/p/165293116">关于“帧同步”说法的历史由来</a>中提到了一个很有趣的说法：因为帧同步强调的是<code>每个逻辑帧运算结束后</code>都得到<code>相同的结果</code>，所以<code>帧同步</code>应该叫<code>帧间同步</code>。</p></blockquote><hr><h2 id="帧同步和Lockstep"><a href="#帧同步和Lockstep" class="headerlink" title="帧同步和Lockstep"></a>帧同步和Lockstep</h2><p>&amp;emsp;&amp;emsp;一个常见的误解是，许多人会将<code>Lockstep</code>翻译成帧同步，其实这并不准确。严格来说，Lockstep应该翻译成<code>锁定步进算法</code>。Lockstep这个术语由军事语境引入，用来表示队伍中的所有人都执行一致的动作步伐向前行军。</p><p>&amp;emsp;&amp;emsp;最早的Lockstep算法被称为<code>确定性锁定步进算法(Deterministic Lockstep)</code>，它里面的帧其实是一个虚拟概念，将其称为<code>回合(Turn)</code>或许会更加直观。在每个Turn里，只有当服务器收集到了所有玩家的输入之后，服务器才会将所有输入转发给每个玩家进行计算，然后进入下一个Turn。只有通过这种方式确保每个玩家推进Turn的速度一致，才能保证每个玩家的帧一致性。</p><blockquote><p><img src="https://raw.githubusercontent.com/AsanCai/BlogImage/master/Lockstep/Lockstep.png" alt="Deterministic Lockstep"><br>&amp;emsp;&amp;emsp;从上图可以明显看到，在第二个Turn的时候，因为Player1有延迟，而导致Player2也停下来等待，从而延迟了往下推进下一个Turn的时间。</p></blockquote><p>&amp;emsp;&amp;emsp;显而易见，这种同步算法最大的缺点就是，当一个玩家网络很差的时候，其他玩家也将陷入无尽的等待中。因此，后期为了解决这个问题，有人提出了<code>Bucket同步算法(Bucket Synchronization)</code>。Bucket同步算法是一个<code>Lockstep的改良算法</code>，服务器会把时间按固定时长划分为多个<code>Bucket</code>，在每个Bucket时间节点，服务器会将收集到的所有指令同步给所有玩家，而不需要严格等待收集齐所有玩家的命令再处理，因此网络好的玩家也就不会受到网络差的玩家限制。Bucket同步算法<code>不严格要求每个玩家以同样的进度推进游戏</code>，也就是常说的<code>乐观帧锁定</code>算法。</p><blockquote><p><img src="https://raw.githubusercontent.com/AsanCai/BlogImage/master/Lockstep/BucketSynchronization.png" alt="Bucket Synchronizationp"><br>&amp;emsp;&amp;emsp;从上图可以知道，网络较好的PlayerA并不需要停下来等待PlayerB。</p></blockquote><p>&amp;emsp;&amp;emsp;虽然Bucket Synchronization解决了Deterministic Lockstep的致命性缺陷，但它并不能解决显而易见的作弊问题。比如有种被称为<code>Lookahead Cheats</code>作弊手段，玩家可以使用工具，每次都将自己的操作信息推迟发送，等到看到了别人的决策后再决定执行什么，或者假装网络信号不好丢弃第K步的操作，第K+1步再发送。为了对抗lookahead cheat类型的作弊手段，有人提出了<code>锁定步进协议(Lockstep Protocol)</code>。</p><blockquote><p><strong>Lockstep Protocol的基本步骤：</strong> </p><ol><li>先针对要发送的明文信息进行加密，生成<code>预提交哈希值</code>并发送给其他客户端；</li><li>待本地客户端接收到<code>所有其他客户端</code>的第K步预提交哈希值之后，再发送自己第K步的<code>明文信息</code>；</li><li>收到<code>所有其他客户端</code>的第K步<code>明文信息</code>后，本地客户端会为所有明文信息逐个生成<code>明文哈希值</code>并和<code>预提交哈希值</code>对比；</li><li>如果发现有客户端的<code>明文哈希值</code>和<code>预提交哈希值</code>不同，则可以判定该客户端是外挂，若没有发现异常，则游戏正常向前推进；<br><img src="https://raw.githubusercontent.com/AsanCai/BlogImage/master/Lockstep/LockstepProtocol.png" alt="Lockstep Protocol"></li></ol></blockquote><p>&amp;emsp;&amp;emsp;因为Lockstep Protocol是通过对玩家的操作进行二次校验的方式来对抗外挂，所以会浪费大量网络带宽，且网络条件好的客户端会时刻受到网络差的客户端的影响。因此，后来有人对Bucket synchronization、Lockstep protocol等方法进一步分析并针对存在的缺点进行优化，并提出了<a href="http://www.ekozlowski.com/assets/multiplayer-game-cheating-prevention.pdf">Pipelined Lockstep Protocol</a>。Pipelined Lockstep Protocol的核心思路是，当前玩家的指令行为<code>不与其他人产生冲突</code>，就可以<code>连续发送</code>的自己的指令而<code>不需要等待其他人</code>的指令。当然，为了防止<code>Lookahead Cheats</code>外挂同样需要提前发送Hash。</p><blockquote><p><img src="https://raw.githubusercontent.com/AsanCai/BlogImage/master/Lockstep/PipelinedLockstepProtocol.png" alt="Pipelined Lockstep Protocol"><br>&amp;emsp;&amp;emsp;如果<code>假设玩家接下来的三个操作</code>都必然不会和其他玩家产生冲突，那么可以看到Pipelined Lockstep Protocol允许客户端在没收到其他玩家的预提交哈希时，连续发送自己后面三个指令的预提交哈希值，而并不需要去等待网络较差的玩家。</p></blockquote><p>&amp;emsp;&amp;emsp;自<code>Pipelined Lockstep Protocol</code>出现之后，<code>操作同步</code>、<code>不等待超时玩家</code>的特性逐渐成为帧同步的标准，被广泛应用于使用帧同步开发的网络中。但值得一提的是，现在大部分使用帧同步的网络游戏并非用的<code>Pipelined Lockstep Protocol</code>，而是在<code>Bucket Synchronization</code>的基础上，让每个客户端在相同的时机将本地的<code>关键数据</code>计算成Hash，然后上报服务器，由服务器判断是否有人作弊。网上大部分讲帧同步实现细节的文章，也基本是按照<code>Bucket Synchronization</code>的基本原理来实现的。</p><hr><h2 id="帧同步的技术要点"><a href="#帧同步的技术要点" class="headerlink" title="帧同步的技术要点"></a>帧同步的技术要点</h2><p>&amp;emsp;&amp;emsp;如果充分理解了状态同步和帧同步的定义，那么就不难知道状态同步和帧同步的最大区别在于：状态同步的游戏逻辑在<code>服务端</code>，帧同步的游戏逻辑在<code>客户端</code>。游戏逻辑就是所谓的GamePlay，它包括了实体相关的逻辑（移动、碰撞、攻击、AI和属性等），还包括了具体的玩法逻辑（如胜利失败的条件和关卡流程等）。</p><blockquote><p>&amp;emsp;&amp;emsp;这就回答了前面所提到的、网络游戏面临的问题里的其中两个：<code>在CS架构下逻辑在客户端执行还是在服务器执行</code>和<code>要发送什么数据来进行同步</code>。状态同步给出的答案是：在服务器执行，服务器下发游戏中每个实体当前的状态进行同步。而帧同步给出的答案则是：在客户端执行，服务器转发每个玩家的指令(或者说输入)进行同步。</p></blockquote><p>&amp;emsp;&amp;emsp;对于状态同步来说，因为战斗逻辑写在服务端，那么服务器只需要将计算好的游戏结果以一定频率下发给客户端，让客户端渲染出具体的画面即可。在这个过程中，客户端收到什么数据就负责渲染什么画面，并不需要去关心不同的客户端之间的表现是否一致（此时的客户端，更像是服务器的一个<code>表现层</code>）。因为对于服务器来说，不管所有客户端的表现是否一致，本场游戏的结果都是唯一确定的，那就是服务器算出来的结果。因此，状态同步泛指<code>允许各个客户端的外在表现不同，只确保它们内部的逻辑状态统一</code>的<code>弱同步方案</code>。</p><p><img src="https://raw.githubusercontent.com/AsanCai/BlogImage/master/Lockstep/StateSynchronization.png" alt="状态同步图解"></p><p>&amp;emsp;&amp;emsp;而对于帧同步来说，由于游戏逻辑写在<code>客户端</code>，服务器只负责转发所有玩家的操作，所以客户端需要时刻关心不同客户端之间的计算出来的游戏结果是否一致。这也是帧同步泛指<code>保证各个客户端在每个逻辑帧输入一致，并得到相同的结果</code>的<code>强同步方案</code>的原因。为了确保这一点，帧同步需要做大量的工作，如：</p><ol><li>使用<code>定点数(Fixed Point)</code>来表示浮点数，并进行一些浮点数运算，以规避不同设备、不同平台上的<code>浮点数存储精度</code>不同导致的游戏结果不同问题；</li><li>使用<code>确定性的随机数算法</code>、<code>确定性的容器及算法（排序、增加、移除和遍历）</code>；</li><li>使用可靠的网络传输确保游戏过程中，所有客户端收到的<code>输入完全一样</code>；</li><li>对游戏逻辑进行<code>严格分层</code>从而确保不同客户端的<code>UI交互等本地逻辑</code>不会影响到游戏结果，导致与其他客户端的游戏结果不一致；</li><li>在结束一局游戏时，<code>严格清理所有相的数据</code>，确保不会影响下一局游戏的初始数据；</li><li>间隔一段时间就使用游戏中的<code>关键数据</code>来计算Hash，从而判断客户端之间的游戏结果是否出现了不一致；</li></ol><p><img src="https://raw.githubusercontent.com/AsanCai/BlogImage/master/Lockstep/FrameSynchronization.png" alt="帧同步图解"></p><blockquote><p>补充说明：</p><ol><li><p>很多人会将帧同步中分出来的层称为<code>表现层</code>和<code>逻辑层</code>，其中<code>表现层</code>则是渲染画面和处理表现相关的逻辑部分，而<code>逻辑层</code>就是用来计算游戏逻辑的部分。在我个人看来，<code>表现层</code>和<code>逻辑层</code>这个叫法并不准确，将其叫做<code>客户端层</code>和<code>服务器层</code>则更能让人清楚每一层应该拥有哪些逻辑。</p><blockquote><ul><li>一个常见的错误是直接在表现层中处理游戏逻辑：例如<code>点击UI执行一些影响游戏结果的操作</code>：点击UI这一逻辑，显然应该被归到<code>表现层</code>，但很多人会直接在UI的点击回调方法里直接去调用<code>逻辑层</code>的接口去执行影响游戏结果的操作。如果将<code>逻辑层</code>命名为<code>服务器层</code>，将<code>表现层</code>命名为<code>客户端层</code>，那么显然所有人都会意识到，直接在客户端上操作服务器的逻辑是非常不科学的行为；</li><li>另外一个常见的分层错误是将一些表现层的逻辑放进逻辑层里：例如<code>在攻击时产生攻击特效</code>，攻击这一操作显然是需要放进逻辑层里的，但很多时候为了方便，会有人将产生攻击特效这一操作也放在攻击的逻辑里。如果将<code>逻辑层</code>命名为<code>服务器层</code>，那么显然所有人都知道，<code>在服务器上创建一个特效</code>是极其不合理的行为；</li><li>如果将<code>逻辑层</code>命名为<code>服务器层</code>，将<code>表现层</code>命名为<code>客户端层</code>，那么显而易见的是，<code>表现层直接从逻辑层取用数据</code>是非常合理的，这个过程就类似于<code>客户端向服务器请求数据</code>，只是服务器位于本地，并不需要网络传输；</li></ul></blockquote></li><li><p>帧同步中使用游戏<code>关键数据</code>计算Hash的方法，直接判断出客户端是否发生了不同步。如果需要判断是哪个客户端作弊，还需要引入<code>第三方判断</code>。</p><blockquote><ul><li>如果是<code>超过两个玩家</code>的多人游戏，可以使用<code>客户端自验证</code>的方式，只要有一个玩家和其他玩家的Hash都不一致，就可以判断是该客户端作弊。</li><li>对于<code>只有两个玩家</code>的多人游戏来说，最常用的第三方判断方法则是<code>服务器验证</code>，也就是把前面提到的<code>逻辑层（或者更准确的叫服务器层）</code>放到服务器（也就是所谓的<code>校验服</code>）上计算出权威的Hash，只要有玩家的Hash与之不同，就可以判断是该玩家作弊。</li></ul></blockquote></li></ol></blockquote><hr><h2 id="帧同步的手感优化"><a href="#帧同步的手感优化" class="headerlink" title="帧同步的手感优化"></a>帧同步的手感优化</h2><p>&amp;emsp;&amp;emsp;手感是影响玩家游戏体验的关键因素之一，但手感是一个极其模糊的概念，可能在不同的游戏里会有不同的具体要求。从程序的角度出发，我认为手感应该指的是<code>能否在玩家执行相应的操作之后给予玩家预期的反馈</code>，例如当玩家按下闪避键的时候，玩家希望能立马看到游戏里的角色开始切换到闪避的动作，并在玩家预计的时间内流畅地闪避至预期的位置。如果是单机游戏，在不考虑性能影响的前提下，对玩家操作的响应基本没有任何延迟。但对于网络游戏来说，网络同步过程中的网络延迟和网络波动，会极大地影响游戏响应玩家操作的实时性和流畅性，进而影响游戏的手感。</p><p>&amp;emsp;&amp;emsp;为了降低网络延迟，需要选用延迟比较低的网络协议。<code>TCP(Transmission Control Protocol)</code>是最常用的网络传输协议，它提供了<code>可靠传输</code>、<code>流量控制</code>和<code>拥塞控制</code>等特性，使开发者无需担心数据丢失和重传等细节问题。但在要求及时响应的网络游戏中，TCP为了提供这些特性而带来的延迟会极大地影响玩家的体验，毕竟TCP协议设计之初就不是为了及时响应的。也正因如此，帧同步通常会使用延迟更低的<code>UDP(User Datagram Protocol)</code>。但因为UDP只会尽最大能力交付，并不保证数据的可靠传输，所以采用UDP来作为开发网络游戏的网络协议时，需要开发者自己实现<code>可靠UDP</code>。</p><blockquote><p>可靠UDP一般分为两种：</p><ol><li><code>基于可靠传输的UDP(Reliable UDP)</code>，指在UDP上加一层封装，在<code>传输层</code>实现重传等类似TCP的特性，保证<code>上层逻辑</code>在处理数据包的时候，不需要考虑数据丢失和重传等细节，如Enet，KCP等；</li><li><code>冗余信息的UDP</code>，指的是直接使用原始的UDP，然后在<code>上层逻辑</code>处理数据丢包、乱序和重传等问题，常见的实现方式就是在数据里插入<code>确认信息</code>，一旦客户端没收到服务端已确认其发送的数据，就会一直重传直到服务端确认为止。文章<a href="https://gameinstitute.qq.com/community/detail/127640">动作手游实时PVP帧同步方案（客户端）</a>详细地介绍了如何实现<code>冗余信息的UDP</code>；</li></ol></blockquote><p>&amp;emsp;&amp;emsp;除了网络协议的对比，文章<a href="https://zhuanlan.zhihu.com/p/336869551">细谈网络同步在游戏历史中的发展变化（下）</a>还提到了许多优化的要点，其中一个最重要的点就是<code>帧率稳定</code>。为了对抗网络波动的影响，让游戏的渲染帧率保持稳定，传统的帧同步框架加入了<code>缓冲</code>的概念，也就是在接收到服务器同步过来的数据之后，并不立即执行，而是延后几帧再执行。但显而易见的是，使用缓冲会极大地<code>降低游戏响应玩家操作的实时性</code>，所以大部分帧同步游戏<code>（如《王者荣耀》和《火影忍者手游》）</code>都<code>不采用缓冲策略</code>，而是通过加入<code>预表现</code>来减轻网络波动所造成的帧率不稳。</p><blockquote><ol><li><p><code>缓冲</code>策略类似于网络播放器的提前缓存，确保在网络较差时，用户仍能获得一个比较良好、流畅的观看体验；</p></li><li><p>对于帧同步游戏来讲，<code>预表现</code>有两种实现方式：</p><blockquote><ol><li><code>在逻辑层的预测</code>：在没有收到服务器的数据帧的情况下，直接在<code>逻辑层</code>根据预测的输入往前推进，然后在预测失败的时候将逻辑层的状态回退到开始预测时的状态。这种方式的难点在于，一旦开始预测，就需要<code>保存逻辑层的关键数据生成快照</code>，并需要确保回退时能<code>正确重置逻辑层的状态</code>，否则将出现不同步的问题；</li><li><code>在表现层的预测</code>：在没有收到服务器的数据帧的情况下，不推进<code>逻辑层</code>，而是在<code>表现层</code>根据预测的输入去模拟<code>逻辑层</code>的运算来得到预测的结果，一旦预测失败，只需要使用<code>逻辑层的数据</code>来重置<code>表现层的状态</code>即可。这种方式的难点在于，需要在表现层实现一套和逻辑层几乎一样的运算逻辑，或者在<code>不影响逻辑层状态</code>的前提下调用逻辑层的运算接口，并需要精确地管理什么时候使用表现层预测的数据、什么时候使用逻辑层的真实数据。因此，一般情况下，大多数游戏只会在<code>Run</code>和<code>Idle</code>动作实现预表现；</li></ol></blockquote></li></ol></blockquote><hr><h2 id="帧同步的优缺点"><a href="#帧同步的优缺点" class="headerlink" title="帧同步的优缺点"></a>帧同步的优缺点</h2><p>&amp;emsp;&amp;emsp;帧同步的同步方式是通过服务器收集、转发所有客户端的操作来确保各个客户端的游戏状态一致，当玩家数量增多书，服务器需要收集和转发的数据量也会大大增加，且无法像状态同步一样只同步玩家周围的玩家的数据。因此，帧同步并不适合有许多玩家的游戏。</p><p>&amp;emsp;&amp;emsp;但帧同步的优势则在于，所有的游戏结果都是客户端根据服务器转发的玩家输入计算得出，因此，客户端可以<code>任意地获取当前的游戏状态</code>，只需要调用<code>逻辑层（或者说服务器层）的接口</code>获取数据即可，而不需要设计复杂的网络协议去同步数据。对于那些<code>角色状态极为复杂的游戏（如动作游戏，有复杂的buff和攻击、受击状态）</code>，用帧同步则极为合适。</p><p>&amp;emsp;&amp;emsp;当然，帧同步适合什么游戏、不适合什么游戏，只是出于性能和开发效率的考虑之后得出来的一种经验性总结。如果不考虑性能和开发效率，理论上任何游戏都能采用帧同步实现。</p><hr><h2 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h2><ul><li><a href="https://blog.codingnow.com/2018/08/lockstep.html">lockstep 网络游戏同步方案</a></li><li><a href="https://zhuanlan.zhihu.com/p/130702310">细谈网络同步在游戏历史中的发展变化（上）</a></li><li><a href="https://zhuanlan.zhihu.com/p/336869551">细谈网络同步在游戏历史中的发展变化（下）</a></li><li><a href="https://blog.uwa4d.com/archives/USparkle_frame-alignment.html">帧同步优化难点及解决方案</a></li><li><a href="https://zhuanlan.zhihu.com/p/165293116">关于“帧同步”说法的历史由来</a></li><li><a href="https://www.igiven.com/dotnet-2019-11-01-lock-step/">帧同步的相关问题</a></li><li><a href="http://www.ekozlowski.com/assets/multiplayer-game-cheating-prevention.pdf">Multiplayer Game Cheating Prevention With Pipelined Lockstep Protocol</a></li><li><a href="https://gameinstitute.qq.com/community/detail/127640">动作手游实时PVP帧同步方案（客户端）</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>编程随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络同步</tag>
      
      <tag>帧同步</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《C++回顾笔记》进程的内存空间分配</title>
    <link href="/posts/d1a4ed0e/"/>
    <url>/posts/d1a4ed0e/</url>
    
    <content type="html"><![CDATA[<p>&amp;emsp;&amp;emsp;现代操作系统会为每个进程都分配一个虚拟内存地址空间，<code>虚拟内存技术</code>使得每个进程都可以独占整个内存空间，地址从零开始，直到内存上限。进程会把整个地址空间<code>（从低地址到高地址）</code>分为不同的区间用于不同的用途：<br><img src="https://github.com/AsanCai/BlogImage/raw/master/C++ReviewNotes/memory.png" alt="进程的内存区间"></p><p>&amp;emsp;&amp;emsp;如上图所示，一般来讲，进程会将其虚拟内存地址空间分为<strong>六个部分</strong>，它们的用途分别如下：</p><ol><li><em><strong>TEXT段（代码段）</strong></em>：代码段用来存放程序执行代码和<code>所有常量</code>的区域。代码段的大小在<code>程序运行前</code>就已经确定，是固定大小且只读的区域<code>(这也是为什么常量不允许修改的原因)</code>。</li><li><em><strong>DATA段，又称GVAR段（数据段）</strong></em>：数据段通常是指用来存放程序中<code>已初始化的全局变量和静态变量</code>的一块内存区域。DATA段的内存属于<code>静态内存分配</code>。</li><li><em><strong>BSS段（Block Started by Symbol）</strong></em>：BSS段通常用来存放程序中<code>未初始化的全局变量和静态变量</code>的一块内存区域，这个区域的内存属于<code>静态内存分配</code>。BSS段的内存属于<code>静态内存分配</code>。</li><li><em><strong>HEAP（堆空间）</strong></em>：堆空间是用于存放进程运行中被<code>动态分配</code>的内存段，它的大小并不固定，可动态扩张或缩减。当进程调用<code>malloc</code>或者<code>new</code>等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；当利用<code>free</code>或者<code>delete</code>等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）。堆空间的内存属于<code>动态内存分配</code>。</li><li><em><strong>Unused Memory（未使用的内存）</strong></em>：处于堆空间和栈空间中间的、未被使用的区域。堆空间和栈空间的大小是可变的，堆空间从下往上增长，栈空间从上往下增长。堆空间和栈空间增长的时候会消耗未使用的内存区域，直至其被耗尽为止。</li><li><em><strong>STACK（栈空间）</strong></em>：栈空间用于存放函数的参数、返回值和函数体内定义的局部变量。在函数被调用时，其参数和函数体内定义的局部变量会被压入栈空间中。等到函数调用结束后，函数的返回值会被存放回栈中，且被压入栈中的参数和局部变量也会依次出栈。栈空间的内存属于<code>自动内存分配</code>。</li></ol><blockquote><p>值得注意的是：</p><ul><li><code>DATA段</code>和<code>BSS段</code>的区别在于，如果一个全局变量（或者静态变量）在定义后没有被初始化，那么它会被存在BSS段，一旦该全局变量（或者静态变量）被初始化，那么它就会被存到DATA段。</li><li><code>BSS段的字节值全为0</code>，因为未初始化的全局变量和静态变量都会被在BSS段中，所以可以认为它们都会被默认初始化为0（包括类的成员变量）</li><li>HEAP和STACK这两个区域的字节值不一定为0，所以对于存在这个区域的变量来说，如果不对它们进行初始化，那么它们将会得到一个<code>不确定的值（变量所处内存的残留值）</code>。</li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>《C++回顾笔记》</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《C++回顾笔记》声明、定义与初始化</title>
    <link href="/posts/be6fc527/"/>
    <url>/posts/be6fc527/</url>
    
    <content type="html"><![CDATA[<h2 id="声明（Declaration）"><a href="#声明（Declaration）" class="headerlink" title="声明（Declaration）"></a>声明（Declaration）</h2><p>所谓声明，是告诉编译器某个东西的名称和类型，但略去某些细节。在程序中，允许重复声明多次。下面的都是声明式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> x;                         <span class="hljs-comment">/// 声明一个变量</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span>;                         <span class="hljs-comment">/// 声明一个类</span><br><br><span class="hljs-function">std::<span class="hljs-type">size_t</span> <span class="hljs-title">numDigits</span><span class="hljs-params">(<span class="hljs-type">int</span> number)</span></span>;    <span class="hljs-comment">/// 声明一个函数</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> a;                     <span class="hljs-comment">/// 声明一个静态变量</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ul><li>任何包含了显式初始化的声明即成为定义，可以给由<code>extern</code>关键字标记的变量赋一个初始值，但是这么做也就抵消了extern的作用，也就不再是声明，而变成定义了：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>;                   <span class="hljs-comment">/// 定义了一个变量，其类型为int</span><br></code></pre></td></tr></table></figure></li><li>此外，只有当<code>extern</code>声明位于函数外部时，才能执行赋值操作。</li></ul></blockquote><hr><h2 id="定义（Definition）"><a href="#定义（Definition）" class="headerlink" title="定义（Definition）"></a>定义（Definition）</h2><p>&amp;emsp;&amp;emsp;定义的任务是，为编译器提供声明所遗漏的细节。对于对象而言，定义的任务是为此对象分配内存；对函数或者模板函数而言，定义提供了函数的实现；而对类或者模板类来说，定义列出其成员变量和成员函数。在程序中，只允许定义一次。下面的都是定义式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> x;                                <span class="hljs-comment">/// 定义一个变量</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span>                          <span class="hljs-comment">/// 定义一个类</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Widget</span>();<br>    ~<span class="hljs-built_in">Widget</span>();<br>&#125;<br><br><span class="hljs-function">std::<span class="hljs-type">size_t</span> <span class="hljs-title">numDigits</span><span class="hljs-params">(<span class="hljs-type">int</span> number)</span>     <span class="hljs-comment">/// 定义一个函数</span></span><br><span class="hljs-function"></span>&#123;<br>    std::<span class="hljs-type">size_t</span> digit = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> digit;<br>&#125;    <br><br><span class="hljs-type">int</span> A::a = <span class="hljs-number">0</span>;                         <span class="hljs-comment">/// 定义一个静态变量并初始化</span><br></code></pre></td></tr></table></figure><blockquote><p>大多数情况下，定义也完成了声明的工作，不需要再额外声明。但以下两种情况，定义只是定义：</p><ul><li>在类定义之外，定义并初始化一个静态数据成员</li><li>在类外定义非内联成员函数</li></ul></blockquote><hr><h2 id="声明和定义的关系"><a href="#声明和定义的关系" class="headerlink" title="声明和定义的关系"></a>声明和定义的关系</h2><p>&amp;emsp;&amp;emsp;为了允许把程序拆分成多个逻辑部分来编写，C++语言支持<code>分离式编译(separate compilation)</code>机制，该机制允许将程序分割为若干个文件，每个文件可被独立编译。为了支持分离式编译，C++语言将声明和定义区分开来。声明告诉程序一个名字，一个文件如果想使用别处定义的变量则必须包含对那个名字的声明，而定义负责创建与名字关联的实体。</p><blockquote><ul><li>程序使用到的每个名字都会指向一个特定的实体：<code>变量</code>、<code>函数</code>和<code>类型</code>等</li><li>变量声明规定了变量的类型和名字，在这一点上定义与之相同。但是除此之外，定义还申请存储空间，也可能会为变量赋一个初始值。</li></ul></blockquote><p>&amp;emsp;&amp;emsp;声明和定义的区别看起来也许微不足道，但实际上却非常重要。如果要在多个文件中使用同一个变量，就必须将声明和定义分离。此时，变量的定义<code>必须出现在且只能出现在一个文件中</code>，而其他用到该变量的文件必须对其进行声明，却绝对不能重复定义。</p><hr><h2 id="初始化（Initialization）"><a href="#初始化（Initialization）" class="headerlink" title="初始化（Initialization）"></a>初始化（Initialization）</h2><p>&amp;emsp;&amp;emsp;初始化是指<code>给予已定义的对象初始值</code>的过程。如果定义变量时候没有初始化，则变量将会被<code>默认初始化（隐式初始化，由编译器按照一定的规则自动完成）</code>。一般来说，默认初始化的规则如下：</p><ul><li>栈中的变量<code>（函数内定义的变量）</code>和堆中的变量<code>（动态内存）</code>会有不确定的值</li><li>全局变量和静态变量<code>（包括局部静态变量）</code>会被初始化为该变量的类型中<code>0</code>这个概念对应的值<blockquote><p>C++11: If no initializer is specified for an object, the object is default-initialized; if no initialization is performed, an object with automatic or dynamic storage duration has indeterminate value. Note: Objects with static or thread storage duration are zero-initialized.</p></blockquote></li></ul><p>&amp;emsp;&amp;emsp;之所以对不同类型的变量，默认初始化的行为会不一致，是因为编译器存储它们的内存空间不同。关于编译器存储变量的内存空间分配，可以参阅<a href="https://www.rainbowcyan.com/cpp-review-notes/c-hui-gu-bi-ji-jin-cheng-de-nei-cun-kong-jian-fen-pei/">进程的内存空间分配</a>。</p><p>&amp;emsp;&amp;emsp;值得注意的是，如果变量的类型是<code>自定义的类</code>，那么该变量在被默认初始化的时候，将会调用其默认构造函数。倘若该类找不到默认构造函数，或者没有带缺省参数的构造函数，编译器将会报错。</p><blockquote><p>对于自定义的类来说，其没有初始化的成员变量的值是否为一个不确定的值，取决于其所在对象的存储方式<code>（对象也没被初始化）</code>：</p><ol><li>如果对象为全局变量或者静态变量（存于BSS段），那么其成员变量的值将会被初始化为0</li><li>如果对象为动态对象或者局部变量（存于堆或者栈上），那么其成员变量的值将是一个不确定的值</li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> <br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Test</span>() <br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Test(): a = &quot;</span> &lt;&lt; a &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-type">int</span> a;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">StaticTest</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">StaticTest</span>()<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;StaticTest(): a = &quot;</span> &lt;&lt; a &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-type">int</span> a;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestPtr</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">TestPtr</span>()<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;TestPtr(): a = &quot;</span> &lt;&lt; a &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-type">int</span> a;<br>&#125;;<br><br>Test GlobalTest;                                          <span class="hljs-comment">/// 对象存于BSS段，成员变量a的值会被初始化为0，并调用默认构造函数</span><br><span class="hljs-type">static</span> StaticTest StaticGlobalTest;                       <span class="hljs-comment">/// 对象存于BSS段，成员变量a的值会被初始化为0，并调用默认构造函数</span><br><br>TestPtr* GlobalTestPtr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TestPtr</span>();                   <span class="hljs-comment">/// 对象存于堆上，成员变量a的值为不确定值，不会被初始化为0，并调用默认构造函数</span><br>TestPtr* GlobalTestPtr2;                                  <span class="hljs-comment">/// 指针GlobalTestPtr2存于BSS段，因此其值会被初始化为0，也就是nullptr</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;--------------------Initialization of local variable --------------------&quot;</span> &lt;&lt; endl;<br><br>Test LocalTest;                                         <span class="hljs-comment">/// 对象存于栈上，成员变量a的值为不确定值，不会被初始化为0，并调用默认构造函数</span><br><br><span class="hljs-type">static</span> StaticTest StaticLocalTest;                      <span class="hljs-comment">/// 对象存于BSS段，成员变量a的值会被初始化为0，并调用默认构造函数</span><br><br>TestPtr* LocalTestPtr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TestPtr</span>();                  <span class="hljs-comment">/// 对象存于堆上，成员变量a的值为不确定值，不会被初始化为0，并调用默认构造函数</span><br>TestPtr* LocalTestPtr2;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;GlobalTestPtr2 = &quot;</span> &lt;&lt; GlobalTestPtr2 &lt;&lt; endl;  <br><span class="hljs-comment">// cout &lt;&lt; &quot;LocalTestPtr2 = &quot; &lt;&lt; LocalTestPtr2 &lt;&lt; endl; /// 将会报错，不允许使用未初始化的变量</span><br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;根据默认初始化的规则，不难得到上述事例程序的输出为：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">Test</span><span class="hljs-params">()</span></span>: <span class="hljs-selector-tag">a</span> = <span class="hljs-number">0</span><br><span class="hljs-function"><span class="hljs-title">StaticTest</span><span class="hljs-params">()</span></span>: <span class="hljs-selector-tag">a</span> = <span class="hljs-number">0</span><br><span class="hljs-function"><span class="hljs-title">TestPtr</span><span class="hljs-params">()</span></span>: <span class="hljs-selector-tag">a</span> = -<span class="hljs-number">842150451</span><br>------------------<span class="hljs-attr">--Initialization</span> of local variable --------------------<br><span class="hljs-function"><span class="hljs-title">Test</span><span class="hljs-params">()</span></span>: <span class="hljs-selector-tag">a</span> = -<span class="hljs-number">858993460</span><br><span class="hljs-function"><span class="hljs-title">StaticTest</span><span class="hljs-params">()</span></span>: <span class="hljs-selector-tag">a</span> = <span class="hljs-number">0</span><br><span class="hljs-function"><span class="hljs-title">TestPtr</span><span class="hljs-params">()</span></span>: <span class="hljs-selector-tag">a</span> = -<span class="hljs-number">842150451</span><br>GlobalTestPtr2 = <span class="hljs-number">00000000</span><br>LocalTestPtr2 = <span class="hljs-number">00000000</span><br>请按任意键继续. . .<br></code></pre></td></tr></table></figure><hr><h2 id="赋值与初始化"><a href="#赋值与初始化" class="headerlink" title="赋值与初始化"></a>赋值与初始化</h2><p>&amp;emsp;&amp;emsp;在C++中，可以使用<code>=</code>来完成初始化，因此这很容易让人认为初始化是赋值的一种。然而，事实上，在C++语言中，赋值和初始化是两个完全不同的操作，只是它们两者的区别在很多情况下可以忽略不计。需要强调的是，初始化不是赋值，初始化的含义是创建变量的时候赋予其一个初始值，而赋值的含义则是把变量的当前值擦除，并使用一个新值来替代。</p>]]></content>
    
    
    <categories>
      
      <category>《C++回顾笔记》</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《重构--改善既有代码的设计》读书笔记（一）重构的原则</title>
    <link href="/posts/37143617/"/>
    <url>/posts/37143617/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&amp;emsp;&amp;emsp;在前段时间，我被安排去负责一个重要模块的重构工作。惭愧的是，在开始这项重要的重构工作之前，虽然我曾花费过一些时间仔细翻阅本书，但后面重构的过程依旧十分坎坷，而且在最后进行测试的时候，发现了很多重构时新引入的bug。尽管这些bug都是一些小问题，但这足以说明这是一次颇为失败的重构(ノへ￣、)。</p><blockquote><p><strong>一次失败的重构</strong><br>&amp;emsp;&amp;emsp;在重构开始之前，我和其他几个一起负责这个模块的同事一起商定了重构的目标——<code>花费几周的时间按照新的设计架构一步到位地彻底地重构整个模块</code>。因为在此期间需要<code>保证该模块必须要能正常运行</code>，所以只能采取在确保旧模块能正常运行的基础上，加上一个新的模块，并使用一个功能开关来控制启用新模块还是旧模块。<code>这是一切噩梦的开端</code>。<br>&amp;emsp;&amp;emsp;在重构刚刚开始的时候，我还能游刃有余地严格按照书中提及的一些技巧去重构依赖较少的部分。但随着重构工作的不断开展，重构涉及的外部业务模块越来越多，需要理解的上下文语义也越来越多。因为新旧两个模块的架构设计差别很大，所以在修改相关的外部业务模块时，常常需要在新模块提供一套功能类似、但实现截然不同的接口给外部业务模块用。此外，在重构工作开展期间，还有<code>大量的业务需求需要在旧模块上添加新功能</code>，而且这些新功能在新模块里也要有所体现，这无疑大大加大了重构的负担。<br>&amp;emsp;&amp;emsp;为了减轻重构的负担，只能尽快让新模块能正常工作以替代旧模块。因此，在重构的中期，我采用了激进的重构方式——<code>只确保新模块的主要功能能正常运行，等待新模块接入之后，再将遗漏的功能慢慢补齐</code>。例如，在遇到一些外部业务模块的时候，我选择将其暂时屏蔽，不在新模块中为其提供所需的接口。<code>这种激进的，不加小心的重构方式，为本次重构埋下了巨大的隐患</code>。<br>&amp;emsp;&amp;emsp;当然，如果按照计划，在新模块接入之后我能及时将其遗漏的功能补上，再按照测试用例确保其没有bug，倒也问题不大。但可惜的是，接入新模块之后，我因为忙于处理其他的紧急事务而搁置了补上遗漏功能的任务。再加上旧模块并没有清晰完备的测试用例，且没有经过充分的测试验证，导致许多问题在重构的过程中没有及时暴露出来。直到接入新流程之后，在某一个重要的测试节点，大家才发现，<code>这个模块怎么重构之后bug反而增多了</code>。</p></blockquote><p>&amp;emsp;&amp;emsp;之所以本书没能帮我顺利地完成重构工作，主要是因为我在翻阅本书的时候只重点学习了它里面介绍的重构技巧，而对介绍重构原则的章节只是囫囵吞枣地看了一遍。<code>初看不知书中意，再看已是书中人</code>。当我在对这次失败的重构进行复盘时，我又重新翻阅了介绍重构原则的章节，这时我才深刻地体会到了为什么会有这些原则。<br>&amp;emsp;&amp;emsp;值得一提的是，虽然我对书中对于重构的一些见解赞不绝口，但作者阐述的方式确实有些过于冗杂和混乱，于是我提炼了一下本章节的内容，加入了自己的理解<code>(事实上，本文中有相当多的内容都是自己对原文的补充、理解)</code>，并稍微地调整了一下本章节的结构<code>(运用作者介绍的重构原则对本章节的内容进行重构，开个玩笑︿(￣︶￣)︿)</code>。</p><hr><h2 id="什么是重构"><a href="#什么是重构" class="headerlink" title="什么是重构"></a>什么是重构</h2><p>&amp;emsp;&amp;emsp;所谓重构(Refactring)，是指运用<code>大量微小且不改变代码原始功能</code>的步骤，一步步地对代码做出修改，以改进代码的内部结构的过程。每个单独的重构要么很小，要么由若干小步骤组合而成。如果有人说他们在重构过程中，代码有一两天的时间不可用，那么基本可以肯定他们在做的事情不是重构。<br>&amp;emsp;&amp;emsp;可能刚接触重构的人会觉得，用很多小步骤完成似乎可以一大步就能做完的事，会非常低效。之所以会有这样的错觉，是因为他们将每个小步骤都当成彼此割裂的小步骤。实际上，每个小步骤都是彼此之间都是联系紧密的。每个小步骤做出修改的目的都是为了让后面的修改能更加容易地朝着最后的目标靠拢，这就是重构的艺术。</p><blockquote><p>每次要修改时，首先令修改很容易（警告：这件事有时候会很难），然后再进行这次容易的修改。</p></blockquote><p>&amp;emsp;&amp;emsp;也正因如此，如果能在开发的过程中，时常花费时间对代码进行重构来提升代码质量，那么通过提升代码质量所节省的开发时间，将会远大于花在重构的时间。</p><blockquote><p><strong>设计耐久性假说</strong><br>&amp;emsp;&amp;emsp;通过投入精力改善软件的内部设计，可以提高软件的耐久性，从而可以更长时间地保持开发的快速。因为还没有科学的证据可以证实这个理论，所以在书中作者称其为“假说”。</p></blockquote><hr><h2 id="为什么要重构"><a href="#为什么要重构" class="headerlink" title="为什么要重构"></a>为什么要重构</h2><p>&amp;emsp;&amp;emsp;对于程序员来说，大部分人都觉得应该先有一个良好的设计，然后才能开始编码。但随着人们不断修改代码，根据原先设计所得到的整体结构往往会逐渐衰弱，代码的质量也会慢慢沉沦。这是因为开发者经常会为了短期目的，在没有完全理解整体结构的设计意图的前提下去修改代码，于是代码逐渐失去了原有的结构，开发者也会越来越难以通过阅读源码来理解代码所代表的设计意图。此时，按照心理学上的<code>破窗理论</code>，在这个系统上的编码工作，会从一个严谨性的工程逐渐堕落为胡砍乱劈的随性行为，开发者的开发效率也会大大降低。</p><blockquote><p><strong>破窗理论</strong><br>环境中的不良现象如果放任存在，会诱使人们效仿，甚至变本加厉。</p></blockquote><p>&amp;emsp;&amp;emsp;重构有助于维持代码本身该有的结构，甚至改进代码的结构，从而提高开发的效率，用更少的工作量创造更多的价值。</p><hr><h2 id="何时进行重构"><a href="#何时进行重构" class="headerlink" title="何时进行重构"></a>何时进行重构</h2><ol><li><p>如果在动手添加新功能之前，通过审视代码发现对已有的代码结构做一些微调，就能使添加新功能的工作轻松很多，那么此时就应该先对这一部分代码进行重构；</p><blockquote><p>&amp;emsp;&amp;emsp;如果我要往东去100公里，我不会往东一头把车开进树林。而是先往北开20公里上高速，然后再向东开到目的地（或许这里不止100公里）。（虽然后者需要行驶的距离更长），但后者的速度可能比前者要快上3倍。如果有人催着你“赶快直接去那儿”，有时你需要说：“等等，我要先看看地图，找出最快的路径。”</p></blockquote></li><li><p>如果发现有大量重复的代码时，应该对这些代码进行重构，消除这些重复代码；</p><blockquote><p>&amp;emsp;&amp;emsp;重复代码越多，就意味着有更多的代码需要去理解，实现某一功能所需要作出的修改动作就越多，做出正确的修改也就越难。消除重复代码，既可以使需要理解的代码量减少，也可以确定代码行为在代码中只表述一次，只需要修改对应的地方即可。</p></blockquote></li><li><p>如果发现功能正确，可以正常运行，但结构却不甚理想或者逻辑混乱的代码，让人需要花费几分钟甚至几小时才能明白这些代码在做什么，可以对它们进行重构，使得代码可以更清晰地描述代码所代表的设计意图；</p><blockquote><p>&amp;emsp;&amp;emsp;在修改代码之前，开发者需要先理解代码在做什么。如果一段代码可以清晰地描述其代表的意图，那么开发者可以节省大量为了理解代码原先的设计意图而去阅读相关代码的时间，提高效率，还能看到之前没曾注意到的设计问题，提前消除潜在的bug。</p></blockquote></li></ol><hr><h2 id="重写还是重构"><a href="#重写还是重构" class="headerlink" title="重写还是重构"></a>重写还是重构</h2><p>&amp;emsp;&amp;emsp;重构和重写的目标是一样的，都是通过提高代码质量以提高开发的效率。它们的区别在于，<code>重构是一种增量式的活动</code>，因此它每次只会接触到系统的一部分，只在系统的局部造成修改，易于控制。而<code>重写是更具有攻击性的改变</code>，它会修改整个系统，造成更大的、不易控制的影响。因此要想让重写的影响稳定下来，时间要比重构长得多。</p><blockquote><p>&amp;emsp;&amp;emsp;如果将重构比喻成大扫除的话，那么重写则是先按照新的设计建造一个新房间，然后再把东西从旧房间搬到新房间去重新摆放。</p></blockquote><p>&amp;emsp;&amp;emsp;值得一提的是，当团队决定重写系统的时候，就注定会有一段时间，新旧两个系统在并行运行。此时，如果旧系统需要重构或者增添新功能，而新系统正在被重写，那么这种组合就会变成一项极度复杂的任务。因此，重构是不断提升系统更好的方式。它是慢速前进的，通过小的、经常的提升来提高质量。虽然重写也有其自身的优势，但在很多情况下它是一种有风险的、并且团队可能永远都不确定产出物的选择。</p><blockquote><p>&amp;emsp;&amp;emsp;重要的是要记住，当你从零开始的时候，没有绝对的理由相信你会比你第一次做得好。</p></blockquote><hr><h2 id="何时不进行重构"><a href="#何时不进行重构" class="headerlink" title="何时不进行重构"></a>何时不进行重构</h2><ol><li><p>如果有一个大规模的重构很有必要进行，需要花费一些精力，为了不从眼下正要完成的任务跑题太多，可以先不重构，等待完成当下的任务之后再回来重构它；</p></li><li><p>如果丑陋的代码能被隐藏在一个API之下，并不需要修改它，那么就不需要重构它。只有当需要理解其工作原理时，对其进行重构才有价值；</p></li><li><p>如果还没想清楚究竟应该如何优化代码，那么此时应该先做些实验，试试看能否有所改进，然后延迟重构；</p></li><li><p>当代码难于理解，并且不能确定它做什么的时候进行重构。但当很清楚知道代码做什么，但是很难理解那些代码的时候就重写；</p></li></ol><hr><h2 id="对重构的一些误解"><a href="#对重构的一些误解" class="headerlink" title="对重构的一些误解"></a>对重构的一些误解</h2><ol><li><p>重构不一定会让代码变得更快；</p><blockquote><p>&amp;emsp;&amp;emsp;重构与性能优化有很多相似之处：两者都需要修改代码，并且两者都不会改变代码的整体功能。两者的差别在于其目的：重构是为了让代码<code>更容易理解</code>，<code>更易于修改</code>。这可能使程序运行得更快，也可能使程序运行得更慢。而性能优化只关心如何让程序运行得更快，最终得到的代码有可能更难理解和维护。</p></blockquote></li><li><p>重构不是与编程割裂的行为。正常来说，并不应该安排一段时间来专门重构，绝大多数重构都应该在做其他事情的过程中自然发生；</p><blockquote><p>&amp;emsp;&amp;emsp;对于一些不需要花费太多时间就可以完成的重构<code>(见机行事的重构)</code>来说，这不难理解。而对于那些需要耗费几天甚至几周的的重构<code>(有计划的重构)</code>来说，相比安排专门的人花费大量时间去完成重构的工作，让整个团队达成共识，然后每次有人靠近需要重构的代码时，就把它们朝想要改进的方向推动一点，逐步完成重构，可能更为有效。这个策略的好处在于，每次小的重构不会破坏代码的行为，在小改动之后，整个系统仍能照常工作。</p><blockquote><p><strong>Branch By Abstraction</strong><br>&amp;emsp;&amp;emsp;如果想要替换掉一个正在使用的苦，可以先引入一层新的抽象，使其兼容新旧两个库的接口。一旦调用方已经完全改为使用这层抽象，那么替换下面的库就会容易得多。</p></blockquote></blockquote></li><li><p>重构不是在弥补过去的错误或者清理肮脏的代码。肮脏的代码必须重构，但整洁的代码也需要重构；</p><blockquote><p>&amp;emsp;&amp;emsp;在写代码时，开发者需要做出很多权衡取舍：参数化需要做到什么程度？函数之间的边界应该划在哪里？可能对于昨天的功能完全合理的权衡，在今天要添加新功能时可能就不再合理。当然，当开发者需要改变这些权衡以添加新的功能时，整洁的代码重构起来会更容易。</p></blockquote></li><li><p>重构不是为了写出整洁的代码，重构的唯一目的是提高开发的效率，用更少的工作量创造更多的价值；</p><blockquote><p>&amp;emsp;&amp;emsp;有些人试图用<code>整洁的代码</code>或者<code>良好的工程实践</code>之类的理由来论证重构的必要性，这是对重构的误解。重构的意义不在于把代码打磨得闪闪发光，而是纯粹从经济角度出发的考量。我们之所以重构，因为它能让我们更快——添加功能更快，修复bug更快。</p></blockquote></li></ol><hr><h2 id="重构面临的挑战"><a href="#重构面临的挑战" class="headerlink" title="重构面临的挑战"></a>重构面临的挑战</h2><ol><li><p>项目经理并不理解重构的重要性；</p><blockquote><p>&amp;emsp;&amp;emsp;毋庸讳言，项目经理会认为重构要么是开发者在弥补过去犯下的过错，要么是开发者在做不增加价值的无用功。<code>项目要交付给客户的，是可以有效运行的代码，而不是漂亮整洁的代码</code>。原先的代码既然运行起来还算正常，那么耗费多余的时间进行重构，做的工作却与要交付的功能毫不相关，这只会拖缓项目的进度。受进度驱动的的项目经理需要开发者<code>尽可能快速</code>地完成任务，至于怎么完成项目经理并不关心。<br>&amp;emsp;&amp;emsp;因此，开发者不应该安排专门的时间去重构<code>(通常情况下也不会被允许)</code>，只有在开发者认为最快完成任务的方式是重构的时候，再去将重构当成完成任务的一个必不可少的环节并完成它。</p></blockquote></li><li><p>代码所有权的边界会妨碍重构；</p><blockquote><p>&amp;emsp;&amp;emsp;很多重构手法不仅会影响一个模块内部，还会影响该模块与系统其他部分的关系。例如在修改函数声明的时候，可能并没有权限提交调用方的修改<code>（有些团队喜欢给每段代码都指定唯一的所有者，只有指定的所有者才能修改这段代码）</code>。此时，在声明一个新函数的同时，还需要保留原来的函数声明，并让其调用新函数，让接口变复杂。这就是<br>为了避免破坏使用者的系统而不得不付出的代价。虽然可以把旧的接口标记为<code>不推荐使用”（deprecated）</code>，等一段时间之后最终让其退休，但有些时候，旧的接口必须一直保留下去<code>（例如这个函数可能是一个提供给客户的API）</code>。<br>&amp;emsp;&amp;emsp;因此，正常来讲，应该允许团队里的成员都可以修改这个团队拥有的所有代码。虽然每个程序员可能各自分工负责系统的不同区域，但这种责任应该体现为<code>监控自己责任区内发生的修改</code>，而不是简单粗暴地禁止别人修改。</p></blockquote></li><li><p>分支开发会加大重构的难度；</p><blockquote><p>&amp;emsp;&amp;emsp;很多团队会让每个成员各自在代码库的一条分支上开发完整的功能，直到功能可以发布到生产环境，才把该分支上的修改合并回主线（这条分支通常叫master或trunk），从而与整个团队分享。这种做法的拥趸声称，这样能<code>保持主线不受尚未完成的代码侵扰</code>，能保留清晰的功能添加的版本记录，并且在某个功能出问题时能容易地撤销修改。<br>&amp;emsp;&amp;emsp;但显而易见的是，这种协作方式最大的缺点是，在隔离的分支上工作得越久，将完成的工作<code>集成（integrate）</code>回主线就会越困难。为了减轻集成的痛苦，大多数人的办法是频繁地从主线<code>合并（merge）</code>或者<code>变基（rebase）</code>到分支。但如果有几个人同时在各自的特性分支上工作，这个办法并不能真正解决问题，因为合并与集成是两回事。<br><code>合并只是一个单向的代码移动</code>——分支发生了修改，但主线并没有。而<code>集成是一个双向的过程</code>：不仅要把主线的修改<code>拉取（pull）</code>到分支上，而且要把分支修改的结果<code>推送（push）</code>回到主线上，两边都会发生修改。<br>&amp;emsp;&amp;emsp;假如程序员A正在她的分支上对某一部分代码进行重构，程序员B看不见程序员A的修改，直到程序员A将自己的修改与主线集成；此时程序员B就必须把程序员A的修改合并到他的分支上，这可能需要相当的工作量。其中困难的部分是处理重构时发生的语义变化，例如程序员B修改了一个函数声明，但程序员A又增添了一个对原函数的调用。<br>&amp;emsp;&amp;emsp;分支合并本来就是一个复杂的问题，随着特性分支存在的时间加长，合并的难度会指数上升。所以很多人认为，应该尽量缩短特性分支的生存周期，采用诸如<code>持续集成(Continuous Integration，CI，也叫基于主干开发(Trunk-Based Development))</code>的方法，确保每个团队成员每天至少向主线集成一次，避免任何分支彼此差异太大，从而极大地降低了合并的难度。不过CI也有其代价：每个团队成员必须使用相关的实践以<code>确保主线随时处于健康状态</code>，必须学会将大功能拆分成小块，还必须使用<code>特性开关(feature toggle，也叫特性旗标(feature flag))</code>将尚未完成又无法拆小的功能隐藏掉。</p></blockquote></li><li><p>在重构时对代码做出了不加小心的结构调整，破坏代码原来的功能；</p><blockquote><p>&amp;emsp;&amp;emsp;<code>不会改变程序可观察的行为，这是重构的一个重要特征</code>。但人总会有出错的时候，不过只要及时发现，就不会造成大问题。既然每个重构都是很小的修改，即便真的造成了破坏，也只需要检查最后一步的小修改——就算找不到出错的原因，只要回滚到版本控制中最后一个可用的版本就行了。<br>&amp;emsp;&amp;emsp;这里的关键就在于<code>快速发现错误</code>。要做到这一点，代码应该有一套完备的测试套件，并且运行速度要快，否则开发者会不愿意频繁运行它。也就是说，绝大多数情况下，如果想要重构，得先有可以自测试的代码。这也回答了<code>重构风险太大，可能引入bug</code>的担忧，如果<code>没有自测试的代 码</code>，这种担忧就是完全合理的。</p><blockquote><p>&amp;emsp;&amp;emsp;自测试的代码不仅使重构成为可能，而且使添加新功能更加安全，因为开发者可以很快发现并干掉新近引入的bug。这里的关键在于，一旦测试失败，开发者只需要查看上次测试成功运行之后修改的这部分代码。如果测试运行得很频繁，每次查看的范围就只有少量代码，加入知道必定是这部分代码造成bug的话，排查起来则会容易得多。</p></blockquote></blockquote></li><li><p>难以重构复杂且没有测试的遗留代码；</p><blockquote><p>&amp;emsp;&amp;emsp;从程序员的角度来看就不同了。遗留代码往往很复杂，测试又不足，而且最关键的是，是别人写的（瑟瑟发抖）。虽然重构可以很好地帮助开发者理解遗留系统，慢慢理顺糟糕的程序结构，使其更好地反映代码用途。但如果面对一个庞大而又缺乏测试的遗留系统，很难安全地重构清理它。<br>&amp;emsp;&amp;emsp;对于这个问题，显而易见的答案是<code>没测试就加测试</code>，其中的工作量必定很大。这个问题没有简单的解决办法，最好建议就是按照<code>《修改代码的艺术》</code>里的指导，先找到程序的接缝，在接缝处插入测试，如此将系统置于测试覆盖之下。当然，大多数时候开发者需要运用重构手法创造出接缝<code>(这样的重构很危险，因为没有测试覆盖，但这是为了取得进展必要的风险)</code>。</p></blockquote></li><li><p>数据库是<code>重构经常出问题的一个领域</code>;</p><blockquote><p>&amp;emsp;&amp;emsp;跟通常的重构一样，数据库重构的关键也是小步修改并且每次修改都应该完整，这样每次迁移之后系统仍然能运行。由于每次迁移涉及的修改都很小，写起来应该容易；将多个迁移串联起来，就能对数据库结构及其中存储的数据做很大的调整。例如，改名一个字段的步骤如下(这种修改数据库的方式是<code>并行修改(Parallel Change，也叫扩展协议(expandcontract))</code>的一个实例)：</p><ol><li>新添一个字段，但暂时不使用它，然后提交；</li><li>修改数据写入的逻辑，使其同时写入新旧两个字段，然后提交；</li><li>修改读取数据的地方，将它们逐个改为使用新字段，然后提交看看是否有bug冒出来;</li><li>确定没有bug之后，再删除已经没人使用的旧字段;</li></ol><blockquote><p>这里的数据库，也可以是存储数据的Excel表或者其他自定义的数据结构。</p></blockquote></blockquote></li></ol><hr><h2 id="重构、架构和YAGNI"><a href="#重构、架构和YAGNI" class="headerlink" title="重构、架构和YAGNI"></a>重构、架构和YAGNI</h2><p>&amp;emsp;&amp;emsp;重构对架构最大的影响在于，通过重构，开发者能得到一个设计良好的代码库，使其能够优雅地应对不断变化的需求。<code>在编码之前先完成架构</code>这种做法最大的问题在于，它假设了软件的需求可以<code>预先充分理解</code>。但经验显示，这个假设很多时候甚至可以说大多数时候是不切实际的。只有真正使用了软件、看到了软件对工作的影响，人们才会想明白自己到底需要什么。<br>&amp;emsp;&amp;emsp;应对未来变化的办法之一，就是在软件里植入灵活性机制。例如在编写一个函数时，开发者会考虑它是否有更通用的用途。为了应对开发者预期的应用场景，开发者预测可以给这个函数加上十多个参数，这些参数就是<code>灵活性机制</code>。但天下没有免费的午餐，把这些参数都加上的话，函数在当前的使用场景下就会非常复杂。另外，如果未来的需求变更并非以开发者期望的方式发生，已有的一堆参数可能会使新添参数更麻烦。此外，即便真的需求按照开发者的预期进行变更，但如果对灵活机制的设计不好，反而拖慢响应需求变化的速度。<br>&amp;emsp;&amp;emsp;有了重构技术，开发者就可以采取不同的策略。与其猜测未来需要哪些灵活性、需要什么机制来提供灵活性，不如只根据当前的需求来构造软件，同时把软件的设计质量做得很高。随着对用户需求的理解加深，开发者会对架构进行重构，使其能够应对新的需要。<br>&amp;emsp;&amp;emsp;这种设计方法有很多名字：<code>简单设计</code>、<code>增量式设计</code>或者<code>YAGNI(you arenʼt going to need it的缩写)</code>。YAGNI并不是<code>不做预先架构性思考</code>的意思，总有一些时候，如果缺少预先的思考，重构会难以开展。通俗地讲，YAGNI可以理解为<code>等一等，待到对问题理解更充分，再来着手解决</code>的一种<code>演进式架构</code>方式。</p><hr><h2 id="为什么重构会失败"><a href="#为什么重构会失败" class="headerlink" title="为什么重构会失败"></a>为什么重构会失败</h2><p>&amp;emsp;&amp;emsp;在前面，我提到了一次我自己亲身经历的、失败的重构。如果你已经花费了一点时间看完了本文的所有内容，那么你就不难理解为什么那次重构会以失败告终。<br>&amp;emsp;&amp;emsp;首先，在一开始决定如何达到预定的重构目标时就做了一个最为错误的选择。既然旧模块需要在长达几周的重构期间保持运行，那么<code>在旧模块上不断地小步修改让其逐渐向新的设计架构靠拢不失为一个很好的决策</code>。一方面，该模块的重构能随时暂停来响应增添新功能的需求，另一方面，则是在重构完成之后，不需要花费额外的时间去清理旧模块相关的代码。当然，即便是按照一开始的选择，按照新的设计架构加上一个新模块，也有比只是单纯加上功能开关更好的选择。例如使用前面提到的<code>Branch By Abstraction</code>，提供一个抽象层来隔离旧模块与各个外部业务模块的联系，然后借助旧模块来测试这一抽象层的稳定性，后面在开发新模块时，就只需要考虑如何实现这一抽象层提供的各个接口，而不需要在每个相关的外部业务模块里加上功能开关，侵染其原来的代码。<code>可以说，一开始没想到重构的方式，是重构失败的根本原因</code>。<br>&amp;emsp;&amp;emsp;其次，选择使用新模块来代替旧模块，而不是直接修改旧模块，就意味着<code>选择了重写而不是重构</code>。此时，旧模块上不断增加的新功能会使得重写的过程变成一个极其复杂的工作。因为既确保在旧模块上增加新功能时不会影响到新模块，又要在不影响旧模块的基础上在新模块上增加对应的新功能。<code>这大大加大了工作量，是重构失败的直接原因</code>。<br>&amp;emsp;&amp;emsp;最后，在重写时，缺少旧模块完善的功能文档以及测试用例，也就是在没有充分理解旧模块的遗留代码前提下就开始了重写工作。这无疑加大了重写的风险，因为无法确定在重写的过程中是否遗漏了某些重要的细节，也无法通过完善从测试用例来及时发现问题。更要命的是，为了减轻负担，尽快让新模块代替旧模块，还主动屏蔽了一些不知道具体有什么用的细节，让本来就风险很高的重写工作雪上加霜。因此，在最后的测试阶段，出现各种各样的小bug，也自然不是什么稀奇的事。<code>在没有充分了解遗留代码的前提下就贸然开始重写工作，是重构失败的重要原因</code>。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>重构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《土豆荣耀》重构笔记（二十三）打包游戏</title>
    <link href="/posts/374182d2/"/>
    <url>/posts/374182d2/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&amp;emsp;&amp;emsp;在<a href="https://asancai.github.io/tutorial/potato-glory/PotatoGloryTutorial-22/">上篇文章</a>中，我们实现了虚拟摇杆和按钮，完成了游戏所有的开发工作，是时候对游戏进行打包，在手机上进行测试了。</p><hr><h2 id="修改Player-Settings"><a href="#修改Player-Settings" class="headerlink" title="修改Player Settings"></a>修改Player Settings</h2><p>&amp;emsp;&amp;emsp;在进行打包前，我们需要修改一下游戏的<code>Player Settings</code>。首先，我们在顶部菜单栏选择<code>File-&gt;Build Setting</code>，然后点击<code>Player Settings...</code>按钮打开<code>Player Settings</code>窗口。</p><p>&amp;emsp;&amp;emsp;首先我们需要修改最上方的<code>Company Name</code>，这是apk的发布者信息，不能使用默认的<code>DefaultCompany</code>，必须修改，这里我们设置为<code>RainbowCyan</code>。</p><p>&amp;emsp;&amp;emsp;设置完<code>Company Name</code>后，我们还需要设置<code>ProductName</code>，这是apk安装到手机上之后显示的应用名称，可以使用中文，这里我们设置为<code>PotatoGloryTutorial</code>。然后，我们还需要设置<code>Default Icon</code>，这是apk安装到手机上之后显示的引用图标，这里我们设置为<code>Assets\Sprites</code>下的<code>title</code>图片，</p><p>&amp;emsp;&amp;emsp;接着，我们还需要修改<code>Resolution and Presentation</code>下的<code>Allowed Orentations for Auto Rotation</code>，因为我们的游戏是横屏游戏，因此我们需要取消<code>Portrait</code>和<code>Portrait Upside Down</code>的勾选。</p><p><img src="https://github.com/AsanCai/BlogImage/raw/master/PotatoGloryTutorial/Essay23/Image1.png" alt="Player Settings-Part1"></p><p>&amp;emsp;&amp;emsp;修改完<code>Resolution and Presentation</code>下的<code>Allowed Orentations for Auto Rotation</code>，我们还需要修改<code>Other Settings</code>下的<code>Package Name</code>。我们需要将默认值<code>com.Company.ProductName</code>中的<code>Company</code>修改为我们在<code>DefaultCompany</code>处填写的值，至于<code>ProductName</code>我们可以任意填写，可以填写在上面<code>ProductName</code>处填写的名称，也可以设置成别的。这里，我们将<code>Package Name</code>设置为<code>com.RainbowCyan.PotatoGloryTutorial</code>。</p><p>&amp;emsp;&amp;emsp;至于<code>Version</code>，这个是应用的版本号，我们可以自己随意填写，这里我们设置为<code>1.0</code>。</p><p>&amp;emsp;&amp;emsp;最后，我们还可以选择修改<code>Script Backend</code>。Unity默认的<code>Script Backend</code>为<code>Mono</code>，我们可以将其设置为<code>IL2CPP</code>，但如果设置为<code>IL2CPP</code>，我们需要配置<code>NDK</code>。这两种<code>Script Backend</code>的区别，可以参考<a href="https://www.rainbowcyan.com/game-development/Unity-IL2CPP/">Unity的IL2CPP</a>。如何配置<code>NDK</code>可以参考<a href="https://asancai.github.io/tutorial/potato-glory/PotatoGloryTutorial-2/">Unity的安装以及安卓环境的配置</a>这里我们使用默认的<code>Mono</code>即可。</p><p><img src="https://github.com/AsanCai/BlogImage/raw/master/PotatoGloryTutorial/Essay23/Image2.png" alt="Player Settings-Part2"></p><hr><h2 id="构建apk并测试"><a href="#构建apk并测试" class="headerlink" title="构建apk并测试"></a>构建apk并测试</h2><p>&amp;emsp;&amp;emsp;<code>Player Settings</code>设置完毕之后，我们开始构建apk。在顶部菜单栏选择<code>File-&gt;Build Setting</code>，然后点击<code>Build</code>按钮打开apk文件的保存窗口，这里我们将apk文件命名为<code>PotatoGloryTutorial.apk</code>，随意选择一个文件夹进行保存，可以看到Unity编辑器出现apk文件的构建进度条。</p><p><img src="https://github.com/AsanCai/BlogImage/raw/master/PotatoGloryTutorial/Essay23/Image3.png" alt="apk构建进度条"></p><p>&amp;emsp;&amp;emsp;构建完成之后，我们将apk文件发送至用于测试的Android手机，安装之后即可进行测试。</p><p>&amp;emsp;&amp;emsp;需要注意的是，如果我们有开启<code>开发者模式</code>的Android手机，我们也可以先开启<code>USB调试模式</code>，然后使用USB线将手机连接到电脑，并点击<code>Build And Run</code>让Unity为我们构建apk并将构建好的apk直接安装到手机上。</p><p>&amp;emsp;&amp;emsp;当然，有兴趣的读者可以点击<a href="https://gitee.com/AsanCai/Download/raw/master/apk/PotatoGloryTutorial.apk">安装包下载链接</a>下载体验我构建出来的安装包，也可以使用手机扫描二维码进行下载安装。</p><p><img src="https://github.com/AsanCai/BlogImage/raw/master/PotatoGloryTutorial/Essay23/Image4.png" alt="安装包下载二维码"></p><hr><h2 id="后言"><a href="#后言" class="headerlink" title="后言"></a>后言</h2><p>&amp;emsp;&amp;emsp;至此，我们的游戏就打包完成啦，快把安装包发给朋友们体验下吧。最后，本篇文章所做的修改，可以在<a href="https://github.com/AsanCai/PotatoGloryTutorial">PotatoGloryTutorial</a>这个仓库的<code>essay21</code>分支下看到，读者可以clone这个仓库到本地进行查看。</p><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://www.rainbowcyan.com/game-development/Unity-IL2CPP/">Unity的IL2CPP</a></li><li><a href="https://asancai.github.io/tutorial/potato-glory/PotatoGloryTutorial-2/">Unity的安装以及安卓环境的配置</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
      <category>《土豆荣耀》</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《土豆荣耀》重构笔记（二十二）实现虚拟摇杆和按钮</title>
    <link href="/posts/240d846e/"/>
    <url>/posts/240d846e/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&amp;emsp;&amp;emsp;到目前为止，我们已经实现了游戏的所有功能。但目前，我们仍然使用键盘和鼠标来操作角色的移动和攻击。为了能让游戏在手机上正常运行，我们需要实现<code>虚拟摇杆</code>和<code>按钮</code>，来替换键盘和鼠标输入。此外，为了减少代码的修改，且同时兼容PC端和手机端的使用，我们希望<code>虚拟摇杆</code>和<code>按钮</code>的输入值的获取方式和Unity提供的<code>Input类</code>类似。</p><p>&amp;emsp;&amp;emsp;注意到Unity提供的<a href="https://assetstore.unity.com/packages/essentials/asset-packs/standard-assets-32351">Standard Asstes</a>下面有一个名为<code>CrossPlatformInput</code>的插件，这个插件的作用是<code>进行跨平台输入适配</code>，因此我们可以参考<code>CrossPlatformInput</code>插件来实现我们的虚拟摇杆和按钮。</p><hr><h2 id="框架设计"><a href="#框架设计" class="headerlink" title="框架设计"></a>框架设计</h2><p>&amp;emsp;&amp;emsp;Unity提供的<code>Input</code>类为静态类，因此我们也需要提供一个用于管理<code>虚拟摇杆</code>和<code>按钮</code>输入的静态类，我们不妨将这个静态类命名为<code>InputManager</code>。此外，因为<code>虚拟摇杆</code>和<code>按钮</code>需要根据<code>玩家对UI进行的操作</code>来获得<code>输入</code>，所以我们需要先实现只用于处理输入的<code>VirtualAxis</code>和<code>VirtualButton</code>，然后在<code>VirtualAxis</code>和<code>VirtualButton</code>的基础上，加上<code>UI操作</code>来实现<code>虚拟摇杆</code>和<code>按钮</code>。</p><p><img src="https://github.com/AsanCai/BlogImage/raw/master/PotatoGloryTutorial/Essay22/Image1.png" alt="框架示意图"></p><p>&amp;emsp;&amp;emsp;此外，为了方便脚本的寻找，我们在<code>Assets\Scripts</code>文件夹下新建一个名为<code>Input</code>的文件夹，用于存放所有和实现虚拟摇杆和按钮有关的脚本。</p><hr><h2 id="实现VirtualAxis和VirtualButton"><a href="#实现VirtualAxis和VirtualButton" class="headerlink" title="实现VirtualAxis和VirtualButton"></a>实现VirtualAxis和VirtualButton</h2><p>&amp;emsp;&amp;emsp;在清楚了框架的设计之后，我们先来实现用于处理输入的<code>VirtualAxis</code>和<code>VirtualButton</code>类。在实现<code>VirtualAxis</code>和<code>VirtualButton</code>类之前，我们需要了解一下<code>VirtualAxis</code>和<code>VirtualButton</code>类需要管理哪些值。</p><p>&amp;emsp;&amp;emsp;通过前面对Unity提供的<code>Input</code>类的使用，我们知道，当我们使用<code>Axis</code>时，我们可以获得一个在<code>(-1, 1)</code>内连续变化的<code>float类型</code>值。而当我们使用<code>Button</code>时，我们可以获取三个分别代表<code>按钮刚刚被按下</code>、<code>按钮被持续按下</code>和<code>按钮刚刚被松开</code>的<code>bool 类型</code>值。</p><p>&amp;emsp;&amp;emsp;也就是说，<code>VirtualAxis</code>需要管理一个<code>float类型</code>的变量，而<code>VirtualButton</code>需要管理三个<code>bool类型</code>的变量。</p><p>&amp;emsp;&amp;emsp;了解了<code>VirtualAxis</code>和<code>VirtualButton</code>类需要管理的值之后，我们先来实现较为简单的<code>VirtualAxis</code>类。首先，我们在<code>Assets\Scripts\Input</code>文件夹下新建一个名为<code>VirtualAxis</code>的C#脚本，然后编辑<code>VirtualAxis.cs</code>如下：</p><figure class="highlight csharp"><figcaption><span>VirtualAxis.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">VirtualAxis</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">float</span> m_Value;<br><br>    <span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">VirtualAxis</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name</span>)</span> &#123;<br>        <span class="hljs-keyword">this</span>.Name = name;<br>    &#125;<br><br>    <span class="hljs-comment">// 更新当前的值</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params"><span class="hljs-built_in">float</span> <span class="hljs-keyword">value</span></span>)</span> &#123;<br>        m_Value = <span class="hljs-keyword">value</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 返回当前的值</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> <span class="hljs-title">GetValue</span>()</span> &#123;<br>        <span class="hljs-keyword">return</span> m_Value; <br>    &#125;<br><br>    <span class="hljs-comment">// 返回初始值</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> <span class="hljs-title">GetValueRaw</span>()</span> &#123;<br>        <span class="hljs-keyword">return</span> m_Value;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;接着，我们来实现较为复杂的<code>VirtualButton</code>类，我们在<code>Assets\Scripts\Input</code>文件夹下新建一个名为<code>VirtualButton</code>的C#脚本，然后编辑<code>VirtualButton.cs</code>如下：</p><figure class="highlight csharp"><figcaption><span>VirtualButton.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">VirtualButton</span> &#123;<br>    <span class="hljs-comment">// 按钮的名称</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>; &#125;<br><br>    <span class="hljs-comment">// 按下按钮的帧数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> m_LastPressedFrame = <span class="hljs-number">-5</span>;<br>    <span class="hljs-comment">// 释放按钮的帧数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> m_ReleasedFrame = <span class="hljs-number">-5</span>;<br>    <span class="hljs-comment">// 按钮是否处于被按压的状态</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">bool</span> m_Pressed;<br><br>    <span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">VirtualButton</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name</span>)</span> &#123;<br>        <span class="hljs-keyword">this</span>.Name = name;<br>    &#125;<br><br>    <span class="hljs-comment">// 按压按钮</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Pressed</span>()</span> &#123;<br>        <span class="hljs-keyword">if</span> (m_Pressed) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        m_Pressed = <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">// 记录第一次按压按钮时的帧数</span><br>        m_LastPressedFrame = Time.frameCount;<br>    &#125;<br><br>    <span class="hljs-comment">// 松开按钮</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Released</span>()</span> &#123;<br>        m_Pressed = <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">// 记录松开按钮时的帧数</span><br>        m_ReleasedFrame = Time.frameCount;<br>    &#125;<br><br>    <span class="hljs-comment">// 获取当前是否按压按钮</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">GetButton</span>()</span> &#123;<br>        <span class="hljs-keyword">return</span> m_Pressed;<br>    &#125;<br><br>    <span class="hljs-comment">// 获取当前是否刚刚按下按钮</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">GetButtonDown</span>()</span> &#123;<br>        <span class="hljs-keyword">return</span> (m_LastPressedFrame == Time.frameCount - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 获取当前是否刚刚松开按钮</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">GetButtonUp</span>()</span> &#123;<br>        <span class="hljs-keyword">return</span> (m_ReleasedFrame == Time.frameCount - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>代码说明：</p></blockquote><ol><li>这里我们使用类型为<code>bool</code>的<code>GetButtonDown</code>、<code>GetButton</code>和<code>GetBottonUp</code>函数来获取按钮当前是否处于<code>按钮刚刚被按下</code>、<code>按钮被持续按下</code>和<code>按钮刚刚被松开</code>状态</li><li>我们知道，<code>按钮刚刚被按下</code>和<code>按钮刚刚被松开</code>状态是一个短暂的状态，当按钮被按下时，<code>按钮刚刚被按下</code>状态只会持续一帧的时间，<code>按钮刚刚被松开</code>状态也一样。因此，我们使用了<code>m_LastPressedFrame</code>和<code>m_ReleasedFrame</code>来保存<code>按钮刚刚被按下</code>和<code>按钮刚刚被松开</code>的帧数，并通过分别比较<code>m_LastPressedFrame</code>、<code>m_ReleasedFrame</code>和<code>Time.frameCount</code>的帧数差来判断按钮当前是否为<code>按钮刚刚被按下</code>或者<code>按钮刚刚被松开</code>状态。</li></ol><hr><h2 id="实现用于管理的InputManager"><a href="#实现用于管理的InputManager" class="headerlink" title="实现用于管理的InputManager"></a>实现用于管理的InputManager</h2><p>&amp;emsp;&amp;emsp;实现完<code>VirtualAxis</code>和<code>VirtualButton</code>类之后，我们还需要实现用于管理<code>VirtualAxis</code>和<code>VirtualButton</code>类的静态类<code>InputManager</code>。我们在<code>Assets\Scripts\Input</code>文件夹下新建一个名为<code>InputManager</code>的C#脚本，然后编辑<code>InputManager.cs</code>如下：</p><figure class="highlight csharp"><figcaption><span>InputManager.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">InputManager</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Dictionary&lt;<span class="hljs-built_in">string</span>, VirtualAxis&gt; m_VirtualAxes;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Dictionary&lt;<span class="hljs-built_in">string</span>, VirtualButton&gt; m_VirtualButtons;<br><br><br>    <span class="hljs-comment">// 私有构造器</span><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-title">InputManager</span>()</span> &#123;<br>        m_VirtualAxes = <span class="hljs-keyword">new</span> Dictionary&lt;<span class="hljs-built_in">string</span>, VirtualAxis&gt;();<br>        m_VirtualButtons = <span class="hljs-keyword">new</span> Dictionary&lt;<span class="hljs-built_in">string</span>, VirtualButton&gt;();<br>    &#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">region</span> 用于管理的API</span><br>    <span class="hljs-comment">// 判断轴是否存在</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">AxisExists</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name</span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> m_VirtualAxes.ContainsKey(name);<br>    &#125;<br><br>    <span class="hljs-comment">// 判断按钮是否注册</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">ButtonExists</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name</span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> m_VirtualButtons.ContainsKey(name);<br>    &#125;<br><br>    <span class="hljs-comment">// 注册Axis</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">RegisterVirtualAxis</span>(<span class="hljs-params">VirtualAxis axis</span>)</span> &#123;<br>        <span class="hljs-comment">// 如果已经存在同名Axis，那么提示error</span><br>        <span class="hljs-keyword">if</span> (m_VirtualAxes.ContainsKey(axis.Name)) &#123;<br>            Debug.LogError(<span class="hljs-string">&quot;There is already a virtual axis named &quot;</span> + axis.Name + <span class="hljs-string">&quot; registered.&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 添加新轴</span><br>            m_VirtualAxes.Add(axis.Name, axis);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 注册Button</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">RegisterVirtualButton</span>(<span class="hljs-params">VirtualButton button</span>)</span> &#123;<br>        <span class="hljs-comment">// 如果已经存在同名Button，那么提示error</span><br>        <span class="hljs-keyword">if</span> (m_VirtualButtons.ContainsKey(button.Name)) &#123;<br>            Debug.LogError(<span class="hljs-string">&quot;There is already a virtual button named &quot;</span> + button.Name + <span class="hljs-string">&quot; registered.&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 添加新按钮</span><br>            m_VirtualButtons.Add(button.Name, button);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 注销Axis</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">UnRegisterVirtualAxis</span>(<span class="hljs-params">VirtualAxis axis</span>)</span> &#123;<br>        <span class="hljs-comment">// 删除指定的Axis</span><br>        <span class="hljs-keyword">if</span> (m_VirtualAxes.ContainsKey(axis.Name)) &#123;<br>            m_VirtualAxes.Remove(axis.Name);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 注销Button</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">UnRegisterVirtualButton</span>(<span class="hljs-params">VirtualButton button</span>)</span> &#123;<br>        <span class="hljs-comment">// 删除指定的Button</span><br>        <span class="hljs-keyword">if</span> (m_VirtualButtons.ContainsKey(button.Name)) &#123;<br>            m_VirtualButtons.Remove(button.Name);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 按下按钮</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SetButtonDown</span>(<span class="hljs-params">VirtualButton button</span>)</span> &#123;<br>        <span class="hljs-keyword">if</span>(InputManager.ButtonExists(button.Name)) &#123;<br>            button.Pressed();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>                Debug.LogError(<span class="hljs-string">&quot;There is not a virtual button named &quot;</span> + button.Name + <span class="hljs-string">&quot; registered.&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 松开按钮</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SetButtonUp</span>(<span class="hljs-params">VirtualButton button</span>)</span> &#123;<br>        <span class="hljs-keyword">if</span>(InputManager.ButtonExists(button.Name)) &#123;<br>            button.Released();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>                Debug.LogError(<span class="hljs-string">&quot;There is not a virtual button named &quot;</span> + button.Name + <span class="hljs-string">&quot; registered.&quot;</span>);<br>        &#125;<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">region</span> 用于获取输入的API</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">float</span> <span class="hljs-title">GetAxis</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name</span>)</span> &#123;<br>        <span class="hljs-keyword">if</span>(m_VirtualAxes.ContainsKey(name)) &#123;<br>            <span class="hljs-keyword">return</span> m_VirtualAxes[name].GetValue();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            Debug.LogError(<span class="hljs-string">&quot;There is not axis named &quot;</span> + name + <span class="hljs-string">&quot; registered.&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0f</span>;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">float</span> <span class="hljs-title">GetAxisRaw</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name</span>)</span> &#123;<br>        <span class="hljs-keyword">if</span>(m_VirtualAxes.ContainsKey(name)) &#123;<br>            <span class="hljs-keyword">return</span> m_VirtualAxes[name].GetValueRaw();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            Debug.LogError(<span class="hljs-string">&quot;There is not axis named &quot;</span> + name + <span class="hljs-string">&quot; registered.&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0f</span>;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">GetButton</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name</span>)</span> &#123;<br>        <span class="hljs-keyword">if</span>(m_VirtualButtons.ContainsKey(name)) &#123;<br>            <span class="hljs-keyword">return</span> m_VirtualButtons[name].GetButton();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            Debug.LogError(<span class="hljs-string">&quot;There is not button named &quot;</span> + name + <span class="hljs-string">&quot; registered.&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">GetButtonDown</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name</span>)</span> &#123;<br>        <span class="hljs-keyword">if</span>(m_VirtualButtons.ContainsKey(name)) &#123;<br>            <span class="hljs-keyword">return</span> m_VirtualButtons[name].GetButtonDown();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            Debug.LogError(<span class="hljs-string">&quot;There is not button named &quot;</span> + name + <span class="hljs-string">&quot; registered.&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">GetButtonUp</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name</span>)</span> &#123;<br>        <span class="hljs-keyword">if</span>(m_VirtualButtons.ContainsKey(name)) &#123;<br>            <span class="hljs-keyword">return</span> m_VirtualButtons[name].GetButtonUp();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            Debug.LogError(<span class="hljs-string">&quot;There is not button named &quot;</span> + name + <span class="hljs-string">&quot; registered.&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>代码说明：</p></blockquote><ol><li>我们知道，我们通常会使用多个<code>Axis</code>和<code>Button</code>，且我们通过<code>Name</code>来获取<code>Axis</code>和<code>Button</code>的输入值，因此我们需要使用<code>Dictionary</code>来管理<code>VirtualAxis</code>和<code>VirtualButton</code>，并将它们的<code>Name</code>设置为<code>Key</code></li><li><code>InputManager</code>是一个静态类，因此我们需要提供一个不带<code>访问符</code>的<code>静态构造器</code>，且所有函数和变量都应为<code>Static</code>，具体详情可以查阅<a href="https://wizardforcel.gitbooks.io/msdn-csharp/guide/21.html">C# 静态类</a></li><li><code>InputManager</code>提供了两类API，一类用于管理<code>VirtualAxis</code>和<code>VirtualButton</code>的API，另外一类则是用于在<code>Game Play</code>中获取输入的API</li></ol><hr><h2 id="实现虚拟摇杆"><a href="#实现虚拟摇杆" class="headerlink" title="实现虚拟摇杆"></a>实现虚拟摇杆</h2><p>&amp;emsp;&amp;emsp;实现了静态类<code>InputManager</code>之后，我们开始实现控制虚拟摇杆的<code>JoyStickHandler</code>。我们在<code>Assets\Scripts\Input</code>文件夹下新建一个名为<code>JoyStickHandler</code>的C#脚本，然后编辑<code>JoyStickHandler.cs</code>如下：</p><figure class="highlight csharp"><figcaption><span>JoyStickHandler.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><span class="hljs-keyword">using</span> UnityEngine.UI;<br><span class="hljs-keyword">using</span> UnityEngine.EventSystems;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">JoyStickHandler</span> : <span class="hljs-title">MonoBehaviour</span>, <span class="hljs-title">IPointerDownHandler</span>, <span class="hljs-title">IPointerUpHandler</span>, <span class="hljs-title">IDragHandler</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">enum</span> AxisOption &#123;<br>        <span class="hljs-comment">// 使用哪个轴</span><br>        Both,<span class="hljs-comment">// 使用两个轴</span><br>        Horizontal, <span class="hljs-comment">// 使用水平轴</span><br>        Vertical <span class="hljs-comment">// 使用数值轴</span><br>    &#125;<br><br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;虚拟摇杆的最大活动范围&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> Range = <span class="hljs-number">100</span>;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;是否根据屏幕的尺寸对虚拟摇杆的最大获得范围进行缩放&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> ScaleRange = <span class="hljs-literal">true</span>;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;使用哪个轴&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> AxisOption AxisToUse = AxisOption.Both;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;水平轴的名称&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> HorizontalAxisName = <span class="hljs-string">&quot;Horizontal&quot;</span>;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;数值轴的名称&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> VerticalAxisName = <span class="hljs-string">&quot;Vertical&quot;</span>;<br><br>    Vector3 m_StartPos;<br>    <span class="hljs-built_in">bool</span> m_UseHorizontalAxis;<br>    <span class="hljs-built_in">bool</span> m_UseVerticalAxis;<br>    VirtualAxis m_HorizontalVirtualAxis;<br>    VirtualAxis m_VerticalVirtualAxis;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Awake</span>()</span> &#123;<br>        <span class="hljs-comment">// 确保虚拟摇杆运动的位置一样</span><br>        <span class="hljs-keyword">if</span>(ScaleRange)&#123;<br>            CanvasScaler scaler = transform.root.GetComponent&lt;CanvasScaler&gt;();<br><br>            <span class="hljs-built_in">float</span> scaleX = Screen.width / scaler.referenceResolution.x;<br>            <span class="hljs-built_in">float</span> scaleY = Screen.height / scaler.referenceResolution.y;<br>            <br>            <span class="hljs-keyword">if</span>(scaleX &gt; scaleY) &#123;<br>                Range *= scaleY;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                Range *= scaleX;<br>            &#125;<br>        &#125;<br>        <br>        m_UseHorizontalAxis = (AxisToUse == AxisOption.Both || AxisToUse == AxisOption.Horizontal);<br>        m_UseVerticalAxis = (AxisToUse == AxisOption.Both || AxisToUse == AxisOption.Vertical);<br><br>        <span class="hljs-comment">// 启用时对轴进行注册</span><br>        <span class="hljs-keyword">if</span> (m_UseHorizontalAxis) &#123;<br>            m_HorizontalVirtualAxis = <span class="hljs-keyword">new</span> VirtualAxis(HorizontalAxisName);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (m_UseVerticalAxis) &#123;<br>            m_VerticalVirtualAxis = <span class="hljs-keyword">new</span> VirtualAxis(VerticalAxisName);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnEnable</span>()</span> &#123;<br>        <span class="hljs-comment">// 启用时对轴进行注册</span><br>        <span class="hljs-keyword">if</span> (m_UseHorizontalAxis) &#123;<br>            InputManager.RegisterVirtualAxis(m_HorizontalVirtualAxis);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (m_UseVerticalAxis) &#123;<br>            InputManager.RegisterVirtualAxis(m_VerticalVirtualAxis);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span> &#123;<br>        m_StartPos = transform.position;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDisable</span>()</span> &#123;<br>        <span class="hljs-comment">// 禁用时取消轴注册</span><br>        <span class="hljs-keyword">if</span> (m_UseHorizontalAxis) &#123;<br>            InputManager.UnRegisterVirtualAxis(m_HorizontalVirtualAxis);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (m_UseVerticalAxis) &#123;<br>            InputManager.UnRegisterVirtualAxis(m_VerticalVirtualAxis);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 更新摇杆的位置和轴的值</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">UpdateVirtualAxes</span>(<span class="hljs-params">Vector3 delta</span>)</span> &#123;<br>        transform.position = <span class="hljs-keyword">new</span> Vector3(<br>            m_StartPos.x + delta.x, <br>            m_StartPos.y + delta.y, <br>            m_StartPos.z + delta.z<br>        );<br><br>        <span class="hljs-comment">// 这里需要除以Range而不是归一化</span><br>        delta /= Range;<br><br>        <span class="hljs-keyword">if</span> (m_UseHorizontalAxis) &#123;<br>            m_HorizontalVirtualAxis.Update(delta.x);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (m_UseVerticalAxis) &#123;<br>            m_VerticalVirtualAxis.Update(delta.y);<br>        &#125;<br>    &#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">region</span>  接口函数</span><br>    <span class="hljs-comment">// 拖拽虚拟遥杆</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDrag</span>(<span class="hljs-params">PointerEventData data</span>)</span> &#123;<br>        Vector3 newPos = Vector3.zero;<br><br>        <span class="hljs-comment">// 更新水平轴的位置和值</span><br>        <span class="hljs-keyword">if</span> (m_UseHorizontalAxis) &#123;<br>            <span class="hljs-built_in">float</span> delta = data.position.x - m_StartPos.x;<br>            newPos.x = delta;<br>        &#125;<br><br><br>        <span class="hljs-keyword">if</span> (m_UseVerticalAxis) &#123;<br>            <span class="hljs-built_in">float</span> delta = data.position.y - m_StartPos.y;<br>            newPos.y = delta;<br>        &#125;<br><br>        <span class="hljs-comment">// 确保运动范围为半径为Range的圆</span><br>        <span class="hljs-keyword">if</span>(newPos.magnitude &gt; Range) &#123;<br>            newPos = newPos.normalized * Range;<br>        &#125;<br><br>        UpdateVirtualAxes(newPos);<br>    &#125;<br><br>    <span class="hljs-comment">// 松开虚拟摇杆</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPointerUp</span>(<span class="hljs-params">PointerEventData data</span>)</span> &#123;<br>        UpdateVirtualAxes(Vector3.zero);<br>    &#125;<br><br>    <span class="hljs-comment">// 点击虚拟摇杆</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPointerDown</span>(<span class="hljs-params">PointerEventData data</span>)</span> &#123;<br>        <br>    &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>代码说明：</p></blockquote><ol><li><code>JoyStickHandler.cs</code>脚本需要附加到<code>Game Object</code>上，因此<code>JoyStickHandler</code>类需要继承<code>MonoBehaviour</code></li><li>根据前面的框架设计，<code>JoyStickHandler</code>类除了要使用<code>VirtualAxis</code>，还需要根据用户对UI的操作来获取输入，因此我们需要让<code>JoyStickHandler</code>实现位于<code>UnityEngine.EventSystems</code>命名空间下的<code>IPointerDownHandler</code>、<code>IPointerUpHandler</code>和<code>IDragHandler</code>接口，从而获取UI的<code>按下</code>、<code>松开</code>和<code>拖拽</code>事件</li><li>当我们勾选<code>ScaleRange</code>时，我们需要根据屏幕尺寸对<code>Range</code>进行缩放，从而保证在不同尺寸的屏幕上，摇杆移动的最大距离一致</li><li>为了减少<code>InputManager</code>的管理量，当虚拟摇杆被禁用时，我们需要<code>注销对应的Axis</code>，当虚拟摇杆被启用时，我们在重新<code>注册对应的Axis</code></li></ol><hr><h2 id="实现按钮"><a href="#实现按钮" class="headerlink" title="实现按钮"></a>实现按钮</h2><p>&amp;emsp;&amp;emsp;实现了虚拟摇杆之后，我们接着实现控制按钮的<code>ButtonHandler</code>。我们在<code>Assets\Scripts\Input</code>文件夹下新建一个名为<code>ButtonHandler</code>的C#脚本，然后编辑<code>ButtonHandler.cs</code>如下：</p><figure class="highlight csharp"><figcaption><span>ButtonHandler.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><span class="hljs-keyword">using</span> UnityEngine.UI;<br><span class="hljs-keyword">using</span> UnityEngine.EventSystems;<br><br>[<span class="hljs-meta">RequireComponent(typeof(Image))</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ButtonHandler</span> : <span class="hljs-title">MonoBehaviour</span>, <span class="hljs-title">IPointerDownHandler</span>, <span class="hljs-title">IPointerUpHandler</span> &#123;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;激活按钮使用的名字&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;按钮松开时显示的图片&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> Sprite NormalImage;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;按钮被按下时显示的图片&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> Sprite ActiveImage;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;按钮被禁用时显示的图片&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> Sprite DisableImage;<br><br>    <span class="hljs-keyword">private</span> Image m_CurrentImage;<br>    <span class="hljs-keyword">private</span> VirtualButton m_Button;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Awake</span>()</span> &#123;<br>        m_CurrentImage = GetComponent&lt;Image&gt;();<br>        <span class="hljs-comment">// 创建按钮</span><br>        m_Button = <span class="hljs-keyword">new</span> VirtualButton(Name);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnEnable</span>()</span> &#123;<br>        InputManager.RegisterVirtualButton(m_Button);<br>        <span class="hljs-keyword">if</span>(NormalImage != <span class="hljs-literal">null</span>) &#123;<br>            m_CurrentImage.sprite = NormalImage;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDisable</span>()</span> &#123;<br>        InputManager.UnRegisterVirtualButton(m_Button);<br>        <span class="hljs-keyword">if</span>(DisableImage != <span class="hljs-literal">null</span>) &#123;<br>            m_CurrentImage.sprite = DisableImage;<br>        &#125;<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">region</span>  接口函数</span><br>    <span class="hljs-comment">// 松开虚拟摇杆</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPointerUp</span>(<span class="hljs-params">PointerEventData data</span>)</span> &#123;<br>        InputManager.SetButtonUp(m_Button);<br><br>        <span class="hljs-keyword">if</span>(NormalImage != <span class="hljs-literal">null</span>) &#123;<br>            m_CurrentImage.sprite = NormalImage;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 点击虚拟摇杆</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPointerDown</span>(<span class="hljs-params">PointerEventData data</span>)</span> &#123;<br>        InputManager.SetButtonDown(m_Button);<br><br>        <span class="hljs-keyword">if</span>(ActiveImage != <span class="hljs-literal">null</span>) &#123;<br>            m_CurrentImage.sprite = ActiveImage;<br>        &#125;<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>代码说明：</p></blockquote><ol><li><code>ButtonHandler.cs</code>脚本需要附加到<code>Game Object</code>上，因此<code>ButtonHandler</code>类需要继承<code>MonoBehaviour</code></li><li>因为按钮不可以被拖拽，因此我们只需要实现位于<code>UnityEngine.EventSystems</code>命名空间下的<code>IPointerDownHandler</code>和<code>IPointerUpHandler</code>接口</li><li>为了减少<code>InputManager</code>的管理量，当按钮被禁用时，我们需要<code>注销对应的Button</code>，当按钮被启用时，我们在重新<code>注册对应的Button</code></li><li>在这里，我们默认<code>Button</code>都需要使用<code>Image</code>，<code>可以根据自己的具体需求来拓展</code></li></ol><hr><h2 id="为游戏场景添加虚拟摇杆和按钮"><a href="#为游戏场景添加虚拟摇杆和按钮" class="headerlink" title="为游戏场景添加虚拟摇杆和按钮"></a>为游戏场景添加虚拟摇杆和按钮</h2><p>&amp;emsp;&amp;emsp;按钮和虚拟摇杆都实现了之后，我们开始为游戏场景添加虚拟摇杆和按钮。为了和游戏场景的UI区分开来，我们需要另外创建一个用于绘制虚拟摇杆和按钮的Canvas。</p><blockquote><p>创建绘制虚拟摇杆和按钮的Canvas的步骤：</p></blockquote><ol><li>在游戏场景中新建一个Canvas，并将其重命名为<code>InputCanvas</code></li><li>接着修改<code>InputCanvas</code>下<code>Canvas Scaler</code>组件<blockquote><blockquote><p><code>Canvas Scaler</code>组件的属性</p></blockquote></blockquote><ul><li><code>UI Scale Mode</code>: <code>Scale With Screen Size</code></li><li><code>Reference Resolution</code>: <code>X(1920), Y(1080)</code></li><li><code>Screen Match Mode</code>: <code>Match Width or Height</code></li><li><code>Match</code>: <code>0.5</code></li></ul></li><li>最后，我们需要确保原先的<code>UICanvas</code>绘制在<code>InputCanvas</code>之上，因此我们需要修改<code>UICanvas</code>上<code>Canvas</code>组件的<code>Sort Order</code>属性为<code>1</code></li></ol><p>&amp;emsp;&amp;emsp;创建好绘制虚拟摇杆和按钮的Canvas之后，我们先来添加虚拟摇杆。</p><blockquote><p>添加虚拟摇杆的步骤如下：</p></blockquote><ol><li>在<code>InputCanvas</code>下创建一个<code>Image</code>，然后将其重命名为<code>JoyStickBackground</code><blockquote><blockquote><p><code>JoyStickBackground</code>物体需要修改的组件属性：</p></blockquote></blockquote><ul><li><code>Rect Transform</code>:<ul><li><code>Anchors</code>: 点击<code>Rect Transform</code>组件左上角的方框，然后选择<code>bottom-left</code></li><li><code>PosX</code>: 250</li><li><code>PosY</code>: 210</li><li><code>Width</code>: 300</li><li><code>Height</code>: 300</li></ul></li><li><code>Image</code>: <ul><li><code>Source Image</code>: <code>Assets\Sprites\UI</code>文件夹下的<code>RadialJoy_Area</code>图片</li><li><code>Color</code>: (255, 255, 255, 255)</li></ul></li></ul></li><li>在<code>JoyStickBackground</code>下创建一个<code>Image</code>，然后将其重命名为<code>JoyStick</code>，并在<code>JoyStick</code>物体上添加<code>JoyStickHandler.cs</code>脚本<blockquote><blockquote><p><code>JoyStick</code>物体需要修改的组件属性：</p></blockquote></blockquote><ul><li><code>Rect Transform</code>:<ul><li><code>PosX</code>: 0</li><li><code>PosY</code>: 0</li><li><code>Width</code>: 150</li><li><code>Height</code>: 150</li></ul></li><li><code>Image</code>: <ul><li><code>Source Image</code>: <code>Assets\Sprites\UI</code>文件夹下的<code>RadialJoy_Touch</code>图片</li><li><code>Color</code>: (255, 255, 255, 255)</li></ul></li><li><code>JoyStickHandler (Script)</code><ul><li><code>Range</code>: 100</li><li><code>Scale Range</code>: true</li><li><code>Axis To Use</code>: Both</li><li><code>Horizontal Axis Name</code>: <code>Horizontal</code></li><li><code>Vertical Axis Name</code>: <code>Vertical</code></li></ul></li></ul></li></ol><p>&amp;emsp;&amp;emsp;添加完虚拟摇杆之后，我们继续添加按钮</p><blockquote><p>添加按钮的步骤：</p></blockquote><ol><li>在<code>InputCanvas</code>下创建一个<code>Image</code>，然后将其重命名为<code>Fire1Button</code>，并在<code>Fire1Button</code>物体上添加<code>ButtonHandler.cs</code>脚本<blockquote><blockquote><p><code>Fire1Button</code>物体需要修改的组件属性：</p></blockquote></blockquote><ul><li><code>Rect Transform</code>:<ul><li><code>Anchors</code>: 点击<code>Rect Transform</code>组件左上角的方框，然后选择<code>bottom-right</code></li><li><code>PosX</code>: -160</li><li><code>PosY</code>: 140</li><li><code>Width</code>: 200</li><li><code>Height</code>: 200</li></ul></li><li><code>Image</code>: <ul><li><code>Source Image</code>: <code>Assets\Sprites\UI</code>文件夹下的<code>Button_normal</code>图片</li><li><code>Color</code>: (255, 255, 255, 255)</li></ul></li><li><code>ButtonHandler (Script)</code><ul><li><code>Name</code>: <code>Fire1</code></li><li><code>Normal Image</code>: <code>Assets\Sprites\UI</code>文件夹下的<code>Button_normal</code>图片</li><li><code>Active Image</code>: <code>Assets\Sprites\UI</code>文件夹下的<code>Button_active</code>图片</li><li><code>Diasble Image</code>: <code>Assets\Sprites\UI</code>文件夹下的<code>Button_normal</code>图片</li></ul></li></ul></li><li>在<code>Fire1Button</code>物体上创建一个<code>Image</code><blockquote><blockquote><p><code>Image</code>物体需要修改的组件属性：</p></blockquote></blockquote><ul><li><code>Rect Transform</code>:<ul><li><code>PosX</code>: 0</li><li><code>PosY</code>: 0</li><li><code>Width</code>: 140</li><li><code>Height</code>: 60</li></ul></li><li><code>Image</code>: <ul><li><code>Source Image</code>: <code>Assets\Sprites\Props</code>文件夹下的<code>part_rocket</code>图片</li><li><code>Color</code>: (255, 255, 255, 255)</li></ul></li></ul></li><li>复制三次<code>Fire1Button</code>物体得到<code>Fire1Button (1)</code>、<code>Fire1Button (2)</code>和<code>Fire1Button (3)</code>物体</li><li>将<code>Fire1Button (1)</code>重命名为<code>JumpButton</code><blockquote><blockquote><p><code>JumpButton</code>物体需要修改的组件属性：</p></blockquote></blockquote><ul><li><code>Rect Transform</code>:<ul><li><code>PosX</code>: -380</li><li><code>PosY</code>: 140</li><li><code>Width</code>: 150</li><li><code>Height</code>: 150</li></ul></li><li><code>ButtonHandler (Script)</code><ul><li><code>Name</code>: <code>Jump</code></li></ul></li></ul></li><li>在<code>JumpButton</code>物体上创建一个<code>Text</code>，并删除<code>JumpButton</code>物体下的<code>Image</code>子物体<blockquote><blockquote><p><code>Text</code>物体需要修改的组件属性：</p></blockquote></blockquote><ul><li><code>Rect Transform</code>:<ul><li><code>Anchors</code>: 点击<code>Rect Transform</code>组件左上角的方框，然后选择<code>strentch-strentch</code></li><li><code>Left</code>: 0</li><li><code>Top</code>: 0</li><li><code>Right</code>: 0</li><li><code>Bottom</code>: 0</li></ul></li><li><code>Text</code>: <ul><li><code>Text</code>: <code>Jump</code></li><li><code>Font</code>: <code>Assets\Fonts</code>下的<code>BradBunR</code>字体文件</li><li><code>Font Size</code>: 58</li><li><code>Alignment</code>: 水平居中，垂直居中</li><li><code>Color</code>: (50, 50, 50, 255)</li></ul></li></ul></li><li>将<code>Fire1Button (2)</code>重命名为<code>Fire2Button</code><blockquote><blockquote><p><code>Fire2Button</code>物体需要修改的组件属性：</p></blockquote></blockquote><ul><li><code>Rect Transform</code>:<ul><li><code>PosX</code>: -351.6</li><li><code>PosY</code>: 295.6</li><li><code>Width</code>: 150</li><li><code>Height</code>: 150</li></ul></li><li><code>ButtonHandler (Script)</code><ul><li><code>Name</code>: <code>Fire2</code></li></ul></li></ul></li><li>接着，我们修改<code>Fire2Button</code>物体下的<code>Image</code>子物体<blockquote><blockquote><p><code>Image</code>物体需要修改的组件属性：</p></blockquote></blockquote><ul><li><code>Rect Transform</code>:<ul><li><code>PosX</code>: 0</li><li><code>PosY</code>: 0</li><li><code>Width</code>: 100</li><li><code>Height</code>: 100</li></ul></li><li><code>Image</code>: <ul><li><code>Source Image</code>: <code>Assets\Sprites\Props</code>文件夹下的<code>prop_bomb</code>图片</li></ul></li></ul></li><li>将<code>Fire1Button (3)</code>重命名为<code>Fire3Button</code><blockquote><blockquote><p><code>Fire3Button</code>物体需要修改的组件属性：</p></blockquote></blockquote><ul><li><code>Rect Transform</code>:<ul><li><code>PosX</code>: -160</li><li><code>PosY</code>: 360</li><li><code>Width</code>: 150</li><li><code>Height</code>: 150</li></ul></li><li><code>ButtonHandler (Script)</code><ul><li><code>Name</code>: <code>Fire3</code></li></ul></li></ul></li><li>最后，我们修改<code>Fire1Button (3)</code>物体下的<code>Image</code>子物体<blockquote><blockquote><p><code>Image</code>物体需要修改的组件属性：</p></blockquote></blockquote><ul><li><code>Rect Transform</code>:<ul><li><code>PosX</code>: 0</li><li><code>PosY</code>: 0</li><li><code>Width</code>: 110</li><li><code>Height</code>: 60</li></ul></li><li><code>Image</code>: <ul><li><code>Source Image</code>: <code>Assets\Sprites\Character</code>文件夹下<code>char_hero_beanMan</code>图集切割出来的<code>bazooka</code>图片</li></ul></li></ul></li></ol><p>&amp;emsp;&amp;emsp;添加完虚拟摇杆和按钮之后的效果图如下所示:</p><p><img src="https://github.com/AsanCai/BlogImage/raw/master/PotatoGloryTutorial/Essay22/Image2.png" alt="添加完虚拟摇杆和按钮之后的效果图"></p><hr><h2 id="使用虚拟摇杆和按钮"><a href="#使用虚拟摇杆和按钮" class="headerlink" title="使用虚拟摇杆和按钮"></a>使用虚拟摇杆和按钮</h2><p>&amp;emsp;&amp;emsp;添加完虚拟摇杆和按钮之后，我们需要将之前使用Unity提供<code>Input类</code>来获取输入的脚本改为使用<code>InputManager</code>类来获取输入。首先，我们修改<code>Assets\Scripts\Player</code>文件夹下的<code>PlayerAttack.cs</code>:</p><figure class="highlight csharp"><figcaption><span>PlayerAttack.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-comment">// [RequireComponent(typeof(Animator))]</span><br>[<span class="hljs-meta">RequireComponent(typeof(PlayerController))</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PlayerAttack</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;导弹Prefab&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> Missile MissilePrefab;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;导弹发射点&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> Transform ShootingPoint;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;发射导弹的音效&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> AudioClip ShootEffect;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;炸弹Prefab&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> Rigidbody2D BombPrefab;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;使用火箭筒抛射炸弹的力&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> ProjectileBombForce = <span class="hljs-number">1000f</span>;<br><br>    <span class="hljs-comment">// private Animator m_Animator;</span><br>    <span class="hljs-keyword">private</span> PlayerController m_PlayerCtrl;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Awake</span>()</span> &#123;<br>        <span class="hljs-comment">// 获取引用</span><br>        <span class="hljs-comment">// m_Animator = GetComponent&lt;Animator&gt;();</span><br>        m_PlayerCtrl = GetComponent&lt;PlayerController&gt;();<br><br>        <span class="hljs-comment">// 检查关键属性是否赋值</span><br>        <span class="hljs-keyword">if</span>(MissilePrefab == <span class="hljs-literal">null</span>) &#123;<br>            Debug.LogError(<span class="hljs-string">&quot;请设置MissilePrefab&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(ShootingPoint == <span class="hljs-literal">null</span>) &#123;<br>            Debug.LogError(<span class="hljs-string">&quot;请设置ShootingPoint&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(BombPrefab == <span class="hljs-literal">null</span>) &#123;<br>            Debug.LogError(<span class="hljs-string">&quot;请设置BombPrefab&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>()</span> &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> UNITY_STANDALONE                                //PC端使用Input来获取输入</span><br>        <span class="hljs-keyword">if</span> (Input.GetButtonDown(<span class="hljs-string">&quot;Fire1&quot;</span>)) &#123;<br>            <span class="hljs-comment">// 发射导弹</span><br>            Fire();<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (Input.GetButtonDown(<span class="hljs-string">&quot;Fire2&quot;</span>)) &#123;<br>            <span class="hljs-comment">// 放置炸弹</span><br>            LayBomb();<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (Input.GetButtonDown(<span class="hljs-string">&quot;Fire3&quot;</span>)) &#123;<br>            <span class="hljs-comment">// 抛射炸弹</span><br>            ProjectileBomb();<br>        &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> UNITY_IOS || UNITY_ANDROID                    //移动端使用InputManager来获取输入</span><br>        <span class="hljs-keyword">if</span> (InputManager.GetButtonDown(<span class="hljs-string">&quot;Fire1&quot;</span>)) &#123;<br>            <span class="hljs-comment">// 发射导弹</span><br>            Fire();<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (InputManager.GetButtonDown(<span class="hljs-string">&quot;Fire2&quot;</span>)) &#123;<br>            <span class="hljs-comment">// 放置炸弹</span><br>            LayBomb();<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (InputManager.GetButtonDown(<span class="hljs-string">&quot;Fire3&quot;</span>)) &#123;<br>            <span class="hljs-comment">// 抛射炸弹</span><br>            ProjectileBomb();<br>        &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    &#125;<br><br>    <span class="hljs-comment">// 发射导弹</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Fire</span>()</span> &#123;<br>        <span class="hljs-comment">// // 播放射击动画</span><br>        <span class="hljs-comment">// m_Animator.SetTrigger(&quot;Shoot&quot;);</span><br><br>        <span class="hljs-comment">// 播放射击音效</span><br>        AudioSource.PlayClipAtPoint(ShootEffect, ShootingPoint.position);<br><br>        <span class="hljs-comment">// 创建导弹</span><br>        Missile instance = Instantiate(MissilePrefab, ShootingPoint.position, Quaternion.identity) <span class="hljs-keyword">as</span> Missile;<br><br>        <span class="hljs-comment">// 如果角色跟导弹的朝向不一致，就翻转导弹</span><br>        <span class="hljs-keyword">if</span>(m_PlayerCtrl.FacingRight ^ instance.FacingRight) &#123;<br>            instance.Flip();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 放置炸弹</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">LayBomb</span>()</span> &#123;<br>        <span class="hljs-comment">// 判断当前是否至少有一颗炸弹可以释放</span><br>        <span class="hljs-keyword">if</span>(GameStateManager.Instance.BombManagerInstance.ReleaseBomb(<span class="hljs-number">1</span>) == <span class="hljs-literal">false</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 放置炸弹</span><br>        Instantiate(BombPrefab, <span class="hljs-keyword">this</span>.transform.position, Quaternion.identity);<br>    &#125;<br><br>    <span class="hljs-comment">// 抛射炸弹</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ProjectileBomb</span>()</span> &#123;<br>        <span class="hljs-comment">// 判断当前是否至少有一颗炸弹可以释放</span><br>        <span class="hljs-keyword">if</span>(GameStateManager.Instance.BombManagerInstance.ReleaseBomb(<span class="hljs-number">1</span>) == <span class="hljs-literal">false</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 抛射炸弹</span><br>        Rigidbody2D body = Instantiate(BombPrefab, ShootingPoint.position, Quaternion.identity) <span class="hljs-keyword">as</span> Rigidbody2D;<br>        <span class="hljs-keyword">if</span>(m_PlayerCtrl.FacingRight) &#123;<br>            body.AddForce(Vector2.right * ProjectileBombForce);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            body.AddForce(Vector2.left * ProjectileBombForce);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;首先，我们修改<code>Assets\Scripts\Player</code>文件夹下的<code>PlayerController.cs</code>: </p><figure class="highlight csharp"><figcaption><span>PlayerController.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br>[<span class="hljs-meta">RequireComponent(typeof(Rigidbody2D))</span>]<br>[<span class="hljs-meta">RequireComponent(typeof(Animator))</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PlayerController</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;角色初始朝向是否朝向右边&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> FacingRight = <span class="hljs-literal">true</span>;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;移动时角色加速的力大小&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> MoveForce = <span class="hljs-number">365f</span>;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;角色移动的最大速度&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> MaxSpeed = <span class="hljs-number">5f</span>;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;跳跃时向上加速的力大小&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> JumpForce = <span class="hljs-number">1000f</span>;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;检测角色是否落地&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> Transform GroundCheck;<br><br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;跳跃音效&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> AudioClip[] JumpClips;<br><br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;显示血量条的物体&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> Transform HealthBarDisplay;<br><br>    <span class="hljs-comment">// 获取用户输入</span><br>    <span class="hljs-keyword">private</span> Vector2 m_Input;<br>    <span class="hljs-comment">// 记录角色当前是否处于准备跳跃状态</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">bool</span> m_IsReadyToJump;<br>    <span class="hljs-comment">// 记录角色当前是否正处于跳跃状态</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">bool</span> m_IsJumping;<br>    <span class="hljs-comment">// 记录角色当前是否处于着地状态</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">bool</span> m_GroundedStatus;<br><br>    <span class="hljs-comment">// 组件引用变量</span><br>    <span class="hljs-keyword">private</span> Rigidbody2D m_Rigidbody2D;<br>    <span class="hljs-keyword">private</span> Animator m_Animator;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Awake</span>()</span> &#123;<br>        <span class="hljs-comment">// 获取组件引用</span><br>        m_Rigidbody2D = GetComponent&lt;Rigidbody2D&gt;();<br>        m_Animator = GetComponent&lt;Animator&gt;();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span> &#123;<br>        <span class="hljs-comment">// 监测变量是否正确赋值</span><br>        <span class="hljs-keyword">if</span>(GroundCheck == <span class="hljs-literal">null</span>) &#123;<br>            Debug.LogError(<span class="hljs-string">&quot;请先设置GroundCheck&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 初始化变量</span><br>        m_Input = <span class="hljs-keyword">new</span> Vector2();<br>        m_IsReadyToJump = <span class="hljs-literal">false</span>;<br>        m_IsJumping = <span class="hljs-literal">false</span>;<br>        m_GroundedStatus = <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>()</span> &#123;<br>        <span class="hljs-comment">// 通过检测角色和groundCheck之间是否存在Ground层的物体来判断当前是否落地</span><br>        m_GroundedStatus = Physics2D.Linecast(<br>            transform.position,<br>            GroundCheck.position,<br>            LayerMask.GetMask(<span class="hljs-string">&quot;Obstacle&quot;</span>)<br>        );<br>        <br>        <span class="hljs-comment">// 设置动画状态机控制参数</span><br>        m_Animator.SetBool(<span class="hljs-string">&quot;Grounded&quot;</span>, m_GroundedStatus);<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> UNITY_STANDALONE                                //PC端使用Input来获取输入</span><br>        <span class="hljs-comment">// 着地时，如果当前不处于跳跃状态且按下了跳跃键，进入准备跳跃状态</span><br>        <span class="hljs-keyword">if</span>(m_GroundedStatus &amp;&amp; !m_IsJumping &amp;&amp; Input.GetButtonDown(<span class="hljs-string">&quot;Jump&quot;</span>)) &#123;<br>            m_IsReadyToJump = <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        m_Input.x = Input.GetAxis(<span class="hljs-string">&quot;Horizontal&quot;</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> UNITY_IOS || UNITY_ANDROID                    //移动端使用InputManager来获取输入</span><br>        <span class="hljs-comment">// 着地时，如果当前不处于跳跃状态且按下了跳跃键，进入准备跳跃状态</span><br>        <span class="hljs-keyword">if</span>(m_GroundedStatus &amp;&amp; !m_IsJumping &amp;&amp; InputManager.GetButtonDown(<span class="hljs-string">&quot;Jump&quot;</span>)) &#123;<br>            m_IsReadyToJump = <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        m_Input.x = InputManager.GetAxis(<span class="hljs-string">&quot;Horizontal&quot;</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>        <span class="hljs-comment">// 刚刚落地，退出跳跃状态</span><br>        <span class="hljs-keyword">if</span>(m_GroundedStatus &amp;&amp; m_IsJumping) &#123;<br>            m_IsJumping = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">FixedUpdate</span>()</span> &#123;<br>        <span class="hljs-comment">//获取水平输入</span><br>        <span class="hljs-built_in">float</span> h = m_Input.x;<br><br>        <span class="hljs-comment">// 设置动画状态机控制参数</span><br>        m_Animator.SetFloat(<span class="hljs-string">&quot;Speed&quot;</span>, Mathf.Abs(h));<br><br>        <span class="hljs-comment">// 若h * m_Rigidbody2D.velocity.x为正数且小于MaxSpeed，表示需要继续加速</span><br>        <span class="hljs-comment">// 若h * m_Rigidbody2D.velocity.x为负数，则表示需要反向加速</span><br>        <span class="hljs-keyword">if</span>(h * m_Rigidbody2D.velocity.x &lt; MaxSpeed) &#123;<br>            m_Rigidbody2D.AddForce(Vector2.right * h * MoveForce);<br>        &#125;<br><br>        <span class="hljs-comment">//设置物体速度的阈值</span><br>        <span class="hljs-keyword">if</span>(Mathf.Abs(m_Rigidbody2D.velocity.x) &gt; MaxSpeed) &#123;<br>            m_Rigidbody2D.velocity = <span class="hljs-keyword">new</span> Vector2(<br>                Mathf.Sign(m_Rigidbody2D.velocity.x) * MaxSpeed,<br>                m_Rigidbody2D.velocity.y<br>            );<br>        &#125;<br><br>        <span class="hljs-comment">//判断当前是否需要转向</span><br>        <span class="hljs-keyword">if</span>(h &gt; <span class="hljs-number">0</span> &amp;&amp; !FacingRight) &#123;<br>            Flip();<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(h &lt; <span class="hljs-number">0</span> &amp;&amp; FacingRight) &#123;<br>            Flip();<br>        &#125;<br><br>        <span class="hljs-comment">// 跳跃</span><br>        <span class="hljs-keyword">if</span>(m_IsReadyToJump) &#123;<br>            Jump();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Jump</span>()</span> &#123;<br>        <span class="hljs-comment">// 进入跳跃状态</span><br>        m_IsJumping = <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-comment">// 设置一个竖直向上的力</span><br>        m_Rigidbody2D.AddForce(<span class="hljs-keyword">new</span> Vector2(<span class="hljs-number">0f</span>, JumpForce));<br><br>        <span class="hljs-comment">// 设置动画状态机控制参数</span><br>        m_Animator.SetTrigger(<span class="hljs-string">&quot;Jump&quot;</span>);<br><br>        <span class="hljs-comment">// 退出准备跳跃状态，避免重复跳跃</span><br>        m_IsReadyToJump = <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-comment">//随机在角色当前所处的位置播放一个跳跃的音频</span><br>        <span class="hljs-keyword">if</span>(JumpClips.Length &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">int</span> i = Random.Range(<span class="hljs-number">0</span>, JumpClips.Length);<br>            AudioSource.PlayClipAtPoint(JumpClips[i], transform.position);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Flip</span>()</span> &#123;<br>        <span class="hljs-comment">// 修改当前朝向</span><br>        FacingRight = !FacingRight;<br><br>        <span class="hljs-comment">// 修改scale的x分量实现转向</span><br>        <span class="hljs-keyword">this</span>.transform.localScale = Vector3.Scale(<br>            <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>),<br>            <span class="hljs-keyword">this</span>.transform.localScale<br>        );<br><br>        <span class="hljs-keyword">if</span>(HealthBarDisplay != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 在角色转向时翻转HealthBarDisplay，确保HealthBarDisplay不随角色转向而翻转</span><br>            HealthBarDisplay.localScale = Vector3.Scale(<br>                <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>),<br>                HealthBarDisplay.localScale<br>            );<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            Debug.LogWarning(<span class="hljs-string">&quot;请设置HealthBarDisplay&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>代码说明：</p></blockquote><ol><li>因为<code>PlayController</code>没有使用到<code>m_AduioScoure</code>成员变量，因此我们将和这个变量有关的代码全部删除</li><li>之前我们在<code>FixedUpdate</code>中获取<code>Horizontal Axis</code>的输入，通常来说，获取输入这一操作应该在<code>Update</code>函数中执行，因此我们新增一个<code>m_Input</code>在<code>Update</code>中获取输入，然后在<code>FixedUpdate</code>函数中使用<code>m_Input</code></li></ol><p>&amp;emsp;&amp;emsp;修改完毕之后，运行游戏，发现当我们拖拽虚拟摇杆的时候，角色可以左右移动。当我们点击按钮的时候，角色会根据我们点击的按钮执行相应的操作。</p><hr><h2 id="后言"><a href="#后言" class="headerlink" title="后言"></a>后言</h2><p>&amp;emsp;&amp;emsp;至此，我们就已经完成了实现虚拟摇杆和按钮的全部工作。需要说明的是，我们<code>InputManager</code>并没有<code>根据当前的平台自动来判断是否需要显示虚拟摇杆和按钮</code>的功能，我们可以根据自己的具体需求自行进行拓展。最后，本篇文章所做的修改，可以在<a href="https://github.com/AsanCai/PotatoGloryTutorial">PotatoGloryTutorial</a>这个仓库的<code>essay20</code>分支下看到，读者可以clone这个仓库到本地进行查看。</p><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://assetstore.unity.com/packages/essentials/asset-packs/standard-assets-32351">Standard Asstes</a></li><li><a href="https://wizardforcel.gitbooks.io/msdn-csharp/guide/21.html">C# 静态类</a></li><li><a href="https://docs.unity3d.com/ScriptReference/EventSystems.IPointerDownHandler.html">IPointerDownHandler接口</a></li><li><a href="https://docs.unity3d.com/ScriptReference/EventSystems.IPointerUpHandler.html">IPointerUpHandler接口</a></li><li><a href="https://docs.unity3d.com/ScriptReference/EventSystems.IDragHandler.html">IDragHandler接口</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
      <category>《土豆荣耀》</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《土豆荣耀》重构笔记（二十一）制作游戏菜单场景</title>
    <link href="/posts/15dea16/"/>
    <url>/posts/15dea16/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&amp;emsp;&amp;emsp;到目前为止，我们游戏中只有一个游戏场景，我们还需要制作一个游戏菜单场景，让玩家可以选择开始游戏。</p><hr><h2 id="创建游戏菜单场景"><a href="#创建游戏菜单场景" class="headerlink" title="创建游戏菜单场景"></a>创建游戏菜单场景</h2><p>&amp;emsp;&amp;emsp;首先，我们在顶部菜单栏选择<code>File-&gt;New Scene</code>，然后按快捷键<code>Ctrl + S</code>将创建的场景保存至<code>Assets\Scenes</code>文件夹下，并将其命名为<code>GameMenuScene</code>。接着，我们创建一个用于绘制UI的Canvas：</p><blockquote><p>创建Canvas的步骤如下：</p></blockquote><ol><li>在<code>Hierarchy</code>窗口中右击鼠标，选择<code>UI-&gt;Canvas</code>在场景中新建一个<code>Canvas</code>，然后将其重命名为<code>UICanvas</code></li><li>接着修改<code>UICanvas</code>下<code>Canvas Scaler</code>组件<blockquote><p><code>Canvas Scaler</code>组件的属性</p></blockquote><ul><li><code>UI Scale Mode</code>: <code>Scale With Screen Size</code></li><li><code>Reference Resolution</code>: <code>X(1920), Y(1080)</code></li><li><code>Screen Match Mode</code>: <code>Match Width or Height</code></li><li><code>Match</code>: <code>0.5</code></li></ul></li></ol><p>&amp;emsp;&amp;emsp;创建完<code>UICanvas</code>之后，我们开始添加UI，添加UI的步骤如下：</p><blockquote><p>添加<code>UI</code>的步骤：</p></blockquote><ol><li>在<code>UICanvas</code>物体下新建一个<code>Panel</code>，然后将其重名为<code>BackgroundPanel</code>，然后删除<code>BackgroundPanel</code>的<code>Image</code>组件</li><li>在<code>BackgroundPanel</code>物体下新建一个<code>Panel</code>，然后其重名为<code>Background</code><blockquote><blockquote><p><code>Background</code>物体需要修改的组件属性：</p></blockquote></blockquote><ul><li><code>Image</code>: <ul><li><code>Source Image</code>: <code>Assets\Sprites\Environment</code>文件夹下的<code>env_bg</code>图片</li><li><code>Color</code>: (255, 255, 255, 255)</li></ul></li></ul></li><li>在<code>BackgroundPanel</code>物体下新建一个<code>Panel</code>，然后其重名为<code>Gherkin</code><blockquote><blockquote><p><code>Gherkin</code>物体需要修改的组件属性：</p></blockquote></blockquote><ul><li><code>Image</code>: <ul><li><code>Source Image</code>: <code>Assets\Sprites\Environment</code>文件夹下的<code>env_Gherkin</code>图片</li><li><code>Color</code>: (255, 255, 255, 255)</li></ul></li></ul></li><li>在<code>BackgroundPanel</code>物体下新建一个<code>Panel</code>，然后其重名为<code>BigBen</code><blockquote><blockquote><p><code>BigBen</code>物体需要修改的组件属性：</p></blockquote></blockquote><ul><li><code>Image</code>: <ul><li><code>Source Image</code>: <code>Assets\Sprites\Environment</code>文件夹下的<code>env_BigBen</code>图片</li><li><code>Color</code>: (255, 255, 255, 255)</li></ul></li></ul></li><li>在<code>BackgroundPanel</code>物体下新建一个<code>Panel</code>，然后其重名为<code>Bank</code><blockquote><blockquote><p><code>Bank</code>物体需要修改的组件属性：</p></blockquote></blockquote><ul><li><code>Image</code>: <ul><li><code>Source Image</code>: <code>Assets\Sprites\Environment</code>文件夹下的<code>env_Bank</code>图片</li><li><code>Color</code>: (255, 255, 255, 255)</li></ul></li></ul></li><li>在<code>BackgroundPanel</code>物体下新建一个<code>Panel</code>，然后其重名为<code>River</code><blockquote><blockquote><p><code>River</code>物体需要修改的组件属性：</p></blockquote></blockquote><ul><li><code>Rect Transform</code>:<ul><li><code>Left</code>: 0</li><li><code>Top</code>: 1000</li><li><code>Right</code>: 0</li><li><code>Bottom</code>: 0</li></ul></li><li><code>Image</code>: <ul><li><code>Source Image</code>: <code>Assets\Sprites\Environment</code>文件夹下的<code>env_RiverBase</code>图片</li><li><code>Color</code>: (255, 255, 255, 255)</li></ul></li></ul></li><li>在<code>UICanvas</code>物体下新建一个<code>Image</code>，然后其重名为<code>OptionWindow</code><blockquote><blockquote><p><code>OptionWindow</code>物体需要修改的组件属性：</p></blockquote></blockquote><ul><li><code>Rect Transform</code>:<ul><li><code>Anchors</code>: 点击<code>Rect Transform</code>组件左上角的方框，然后选择<code>middle-left</code></li><li><code>PosX</code>: 500</li><li><code>PosY</code>: -55</li><li><code>Width</code>: 540</li><li><code>Height</code>: 720</li></ul></li><li><code>Image</code>: <ul><li><code>Source Image</code>: <code>Assets\Sprites\UI</code>文件夹下的<code>SF Window</code>图片</li><li><code>Color</code>: (8, 68, 225, 110)</li></ul></li></ul></li><li>在<code>OptionWindow</code>物体下新建一个<code>Button</code>，然后其重名为<code>StartButton</code><blockquote><blockquote><p><code>StartButton</code>物体需要修改的组件属性：</p></blockquote></blockquote><ul><li><code>Rect Transform</code>:<ul><li><code>PosX</code>: 0</li><li><code>PosY</code>: 110</li><li><code>Width</code>: 320</li><li><code>Height</code>: 120</li></ul></li><li><code>Image</code>:<ul><li><code>Source Image</code>: <code>Assets\Sprites\UI</code>文件夹下的<code>SF Button</code>图片</li></ul></li></ul></li><li>修改<code>StartButton</code>物体下的子物体<code>Text</code><blockquote><blockquote><p><code>Text</code>物体需要修改的组件属性：</p></blockquote></blockquote><ul><li><code>Text</code>:<ul><li><code>Text</code>: <code>Start</code></li><li><code>Font</code>: <code>Assets\Fonts</code>下的<code>BradBunR</code>字体文件</li><li><code>Font Size</code>: 80</li><li><code>Color</code>: (255, 255, 255, 255)</li></ul></li></ul></li><li>在<code>OptionWindow</code>物体下新建一个<code>Button</code>，然后其重名为<code>ExitButton</code><blockquote><blockquote><p><code>ExitButton</code>物体需要修改的组件属性：</p></blockquote></blockquote><ul><li><code>Rect Transform</code>:<ul><li><code>PosX</code>: 0</li><li><code>PosY</code>: -110</li><li><code>Width</code>: 320</li><li><code>Height</code>: 120</li></ul></li><li><code>Image</code>:<ul><li><code>Source Image</code>: <code>Assets\Sprites\UI</code>文件夹下的<code>SF Button</code>图片</li></ul></li></ul></li><li>修改<code>ExitButton</code>物体下的子物体<code>Text</code><blockquote><blockquote><p><code>Text</code>物体需要修改的组件属性：</p></blockquote></blockquote><ul><li><code>Text</code>:<ul><li><code>Text</code>: <code>Exit</code></li><li><code>Font</code>: <code>Assets\Fonts</code>下的<code>BradBunR</code>字体文件</li><li><code>Font Size</code>: 80</li><li><code>Color</code>: (255, 255, 255, 255)</li></ul></li></ul></li><li>在<code>UICanvas</code>物体下新建一个<code>Text</code>，然后其重名为<code>Title</code><blockquote><blockquote><p><code>Title</code>物体需要修改的组件属性：</p></blockquote></blockquote><ul><li><code>Rect Transform</code>:<ul><li><code>Anchors</code>: 点击<code>Rect Transform</code>组件左上角的方框，然后选择<code>top-center</code></li><li><code>PosX</code>: 0</li><li><code>PosY</code>: -100</li><li><code>Width</code>: 600</li><li><code>Height</code>: 180</li></ul></li><li><code>Text</code>:<ul><li><code>Text</code>: <code>Potato Glory</code></li><li><code>Font</code>: <code>Assets\Fonts</code>下的<code>BradBunR</code>字体文件</li><li><code>Font Size</code>: 120</li><li><code>Alignment</code>: 水平居中，垂直居中</li><li><code>Color</code>: (255, 255, 255, 255)</li></ul></li></ul></li><li>在<code>UICanvas</code>物体下新建一个<code>Text</code>，然后其重名为<code>Author</code><blockquote><blockquote><p><code>Author</code>物体需要修改的组件属性：</p></blockquote></blockquote><ul><li><code>Rect Transform</code>:<ul><li><code>Anchors</code>: 点击<code>Rect Transform</code>组件左上角的方框，然后选择<code>bottom-right</code></li><li><code>PosX</code>: -200</li><li><code>PosY</code>: 115</li><li><code>Width</code>: 340</li><li><code>Height</code>: 80</li></ul></li><li><code>Text</code>:<ul><li><code>Text</code>: <code>@RainbowCyan</code></li><li><code>Font</code>: <code>Assets\Fonts</code>下的<code>BradBunR</code>字体文件</li><li><code>Font Size</code>: 60</li><li><code>Alignment</code>: 水平居中，垂直居中</li><li><code>Color</code>: (119, 119, 119, 255)</li></ul></li></ul></li></ol><p>&amp;emsp;&amp;emsp;至此，我们就完成了游戏菜单场景的UI制作，其效果图如下：</p><p><img src="https://github.com/AsanCai/BlogImage/raw/master/PotatoGloryTutorial/Essay21/Image1.png" alt="添加UI之后的游戏菜单场景"></p><hr><h2 id="在UI上添加能动的物体"><a href="#在UI上添加能动的物体" class="headerlink" title="在UI上添加能动的物体"></a>在UI上添加能动的物体</h2><p>&amp;emsp;&amp;emsp;添加完游戏菜单场景的UI之后，我们发现整个界面的右边比较空旷，影响美感，因此我们希望能在右边加上一些会动的物体来装饰界面。因为加入的物体需要能动，使用Unity提供的UI难以实现，所以我们选择可以使用动画的<code>GameObject</code>作为我们的<code>装饰物</code>。</p><blockquote><p>添加<code>装饰物</code>的步骤：</p></blockquote><ol><li>在场景中新建一个名为<code>Decoration</code>的<code>Empty GameObject</code>，并将其<code>Position</code>设置为<code>(0, 0, 0)</code></li><li>将<code>Assets\Prefabs\Character</code>文件夹下的<code>Player</code>这一Prefab拖拽到<code>Decoration</code>物体上成为其子物体<blockquote><blockquote><p>对<code>Player</code>物体的操作如下：</p></blockquote></blockquote><ol><li>设置<code>Position</code>为<code>(0.53, -0.85, 0)</code>，<code>Rotation</code>为<code>(0, 0, 14.5)</code></li><li>移除<code>Player</code>物体上除了<code>Animator</code>组件外，的其他所有组件<code>（有依赖关系，注意先移除脚本，再移除其他组件）</code></li><li>删除<code>Player</code>物体下的<code>HealthBarDisplay</code>、<code>GroundCheck</code>和<code>GroundCheck</code>子物体</li></ol></li><li>将<code>Assets\Prefabs\Character</code>文件夹下的<code>AlienSlug</code>这一Prefab拖拽到<code>Decoration</code>物体上成为其子物体<blockquote><blockquote><p>对<code>AlienSlug</code>物体的操作如下：</p></blockquote></blockquote><ol><li>设置<code>Position</code>为<code>(2.84, 1.31, 0)</code>，<code>Scale</code>为<code>(-1, 1, 1)</code></li><li>移除<code>AlienSlug</code>物体上除了<code>Animator</code>组件外，的其他所有组件<code>（有依赖关系，注意先移除脚本，再移除其他组件）</code></li><li>删除<code>AlienSlug</code>物体下的<code>FrontCheck</code>子物体</li></ol></li><li>将<code>Assets\Prefabs\Character</code>文件夹下的<code>AlienShip</code>这一Prefab拖拽到<code>Decoration</code>物体上成为其子物体<blockquote><blockquote><p>对<code>AlienShip</code>物体的操作如下：</p></blockquote></blockquote><ol><li>设置<code>Position</code>为<code>(6.3, 1.6, 0)</code>，<code>Scale</code>为<code>(-1, 1, 1)</code></li><li>移除<code>AlienShip</code>物体上除了<code>Animator</code>组件外，的其他所有组件<code>（有依赖关系，注意先移除脚本，再移除其他组件）</code></li><li>删除<code>AlienShip</code>物体下的<code>FrontCheck</code>子物体</li></ol></li><li>将<code>Assets\Sprites\Environment</code>文件夹下的<code>env_PlatformUfo</code>图片拖拽到<code>Decoration</code>物体上成为其子物体<blockquote><blockquote><p>对<code>env_PlatformUfo</code>物体的操作如下：</p></blockquote></blockquote><ol><li>设置<code>Position</code>为<code>(5.32, -0.72, 0)</code>，<code>Rotation</code>为<code>(0, 0, 18.2)</code>，<code>Scale</code>为<code>(0.2, 0.2, 0.2)</code></li></ol></li><li>将<code>Assets\Sprites\Environment</code>文件夹下的<code>env_UfoLegs</code>图片拖拽到<code>env_PlatformUfo</code>物体上成为其子物体<blockquote><blockquote><p>对<code>env_UfoLegs</code>物体的操作如下：</p></blockquote></blockquote><ol><li>设置<code>Position</code>为<code>(0, 3.8, 0)</code>，<code>Rotation</code>为<code>(0, 0, 0)</code>，<code>Scale</code>为<code>(1, 1, 1)</code></li></ol></li></ol><p>&amp;emsp;&amp;emsp;添加完毕之后，我们发现在<code>Game</code>窗口中看不到我们添加的<code>GameObject</code>。如何让<code>GameObject</code>显示在Canvas之上？这里，我们想到了前面提到的<a href="https://docs.unity3d.com/Manual/UICanvas.html">Canvas绘制方式</a>中的<code>Screen Space - Camera</code>。因此，我们需要将<code>UICanvas</code>物体上<code>Canvas</code>组件的<code>Render Mode</code>设置为<code>Screen Space - Camera</code>，并将<code>Canvas</code>组件的<code>Render Camera</code>设置为场景中的<code>Main Camera</code>。最后，我们发现装饰物偏大，因此我们将<code>Main Camera</code>物体上<code>Camera</code>组件的<code>Size</code>设置为<code>6.8</code>。此时，我们发现已经能在<code>Game</code>窗口中看到我们添加的<code>GameObject</code>了。</p><p><img src="https://github.com/AsanCai/BlogImage/raw/master/PotatoGloryTutorial/Essay21/Image2.png" alt="添加GameObject之后的游戏菜单场景"></p><hr><h2 id="加入控制代码"><a href="#加入控制代码" class="headerlink" title="加入控制代码"></a>加入控制代码</h2><p>&amp;emsp;&amp;emsp;在场景中添加<code>GameObject</code>作为装饰物之后，我们还需要添加控制代码。首先，我们在<code>Assets\Scrpits\Manager</code>文件夹下创建一个名为<code>MenuSceneManager</code>的C#脚本，然后编辑<code>MenuSceneManager.cs</code>:</p><figure class="highlight csharp"><figcaption><span>MenuSceneManager.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><span class="hljs-keyword">using</span> UnityEngine.SceneManagement;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MenuSceneManager</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br>    <span class="hljs-comment">// 加载SinglePlayerGameScene场景开始游戏</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">StartGame</span>()</span> &#123;<br>        SceneManager.LoadScene(<span class="hljs-string">&quot;SinglePlayerGameScene&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 退出应用</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ExitGame</span>()</span> &#123;<br>        Application.Quit();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;编辑完<code>MenuSceneManager.cs</code>之后，我们在场景中创建一个名为<code>MenuSceneManager</code>的<code>Empty GameObject</code>，然后为<code>MenuSceneManager</code>添加<code>MenuSceneManager.cs</code>。接着，我们来设置<code>OptionWindow</code>物体的子物体<code>StartButton</code>的点击事件。</p><blockquote><p><code>StartButton</code>点击事件的设置步骤：</p></blockquote><ol><li>选中<code>StartButton</code>物体，然后点击其<code>Button</code>组件上<code>On Click()</code>下的<code>+</code>号增加一个<code>空点击事件</code></li><li>将场景中的<code>MenuSceneManager</code>拖拽至<code>On Click()</code>下的<code>GameObject</code>赋值框处</li><li>点击<code>No Function</code>下拉菜单，选择<code>MenuSceneManager</code>下的<code>StartGame函数</code></li></ol><p><img src="https://github.com/AsanCai/BlogImage/raw/master/PotatoGloryTutorial/Essay21/Image3.png" alt="设置StartButton的点击事件"></p><p>&amp;emsp;&amp;emsp;最后，我们按照相同的步骤，将<code>OptionWindow</code>物体的子物体<code>ExitButton</code>的点击事件设置为<code>MenuSceneManager</code>下的<code>ExitGame函数</code></p><hr><h2 id="修改GameStateManager-cs并修改BuildSetting"><a href="#修改GameStateManager-cs并修改BuildSetting" class="headerlink" title="修改GameStateManager.cs并修改BuildSetting"></a>修改GameStateManager.cs并修改BuildSetting</h2><p>&amp;emsp;&amp;emsp;在<a href="https://asancai.github.io/tutorial/potato-glory/PotatoGloryTutorial-20/">前面的文章</a>中，因为我们还没有创建游戏菜单场景，所有<code>GameStateManager.cs</code>中用于返回游戏菜单场景的<code>Back函数</code>我们留空了。现在我们已经创建好了游戏菜单场景，因此我们需要补全<code>GameStateManager.cs</code>的<code>Back函数</code>：</p><figure class="highlight csharp"><figcaption><span>GameStateManager.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs csharp">...<br><br>[<span class="hljs-meta">RequireComponent(typeof(AudioSource))</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">GameStateManager</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br>    ...<br><br><span class="hljs-meta">#<span class="hljs-keyword">region</span>  外部调用函数</span><br>    ...<br><br>    <span class="hljs-comment">// 返回主菜单</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Back</span>()</span> &#123;<br>        <span class="hljs-comment">// 恢复游戏的Time.timeScale</span><br>        Time.timeScale = <span class="hljs-number">1f</span>;<br><br>        SceneManager.LoadScene(<span class="hljs-string">&quot;GameMenuScene&quot;</span>);<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;修改完成之后，我们运行游戏，点击<code>Start</code>按钮，发现场景并没有跳转。这是因为我们还没有将我们创建好的<code>GameMenuScene</code>和<code>SinglePlayerGameScene</code>添加至<code>Build Setting</code>中。选择顶部菜单栏的<code>File-&gt;Build Settings...</code>打开<code>Build Setting</code>窗口，然后同时选中<code>Assets\Scenes</code>文件夹下的<code>GameMenuScene</code>和<code>SinglePlayerGameScene</code>将它们拖拽至<code>Build Setting</code>窗口的<code>Scenes In Build</code>处<code>(游戏运行时，会默认加载下标为0的场景，因此我们要确保GameMenuScene的下标为0)</code>。</p><p><img src="https://github.com/AsanCai/BlogImage/raw/master/PotatoGloryTutorial/Essay21/Image4.png" alt="将创建好的场景添加到Build Setting"></p><p>&amp;emsp;&amp;emsp;再次运行游戏，点击<code>Start</code>按钮，此时场景跳转到<code>SinglePlayerGameScene</code>场景。在<code>SinglePlayerGameScene</code>中点击<code>BackButton</code>按钮，然后再点击<code>Yes</code>按钮，场景则跳转回<code>GameMenuScene</code>场景。</p><hr><h2 id="后言"><a href="#后言" class="headerlink" title="后言"></a>后言</h2><p>&amp;emsp;&amp;emsp;至此，我们就已经完成了制作游戏菜单场景的所有工作。最后，本篇文章所做的修改，可以在<a href="https://github.com/AsanCai/PotatoGloryTutorial">PotatoGloryTutorial</a>这个仓库的<code>essay19</code>分支下看到，读者可以clone这个仓库到本地进行查看。</p>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
      <category>《土豆荣耀》</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《土豆荣耀》重构笔记（二十）为游戏场景添加UI</title>
    <link href="/posts/908f0d6b/"/>
    <url>/posts/908f0d6b/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&amp;emsp;&amp;emsp;在<a href="https://asancai.github.io/tutorial/potato-glory/PotatoGloryTutorial-19/">上篇文章</a>中，我们已经实现了<code>游戏主逻辑管理器</code>，并加入了游戏的胜负条件。但在游戏中，玩家并不能清晰地知道当前自己<code>获得了多少分数</code>、<code>游戏胜利的目标分数是多少</code>以及<code>当前还能释放多少颗炸弹</code>，我们需要加入UI进行提示。</p><hr><h2 id="加入BombManager"><a href="#加入BombManager" class="headerlink" title="加入BombManager"></a>加入BombManager</h2><p>&amp;emsp;&amp;emsp;在前面的文章中，因为我们还没有实现<code>游戏主逻辑管理器</code>，为了方便测试，我们直接在<code>PlayerAttack.cs</code>里面实现<code>管理炸弹数量</code>和<code>释放炸弹</code>的功能。因为<code>PlayerAttack.cs</code>的职责是<code>释放炸弹和导弹</code>，因此，我们需要将<code>管理炸弹数量</code>的代码从<code>PlayerAttack.cs</code>中抽取出来，并创建一个<code>Manager</code>来负责<code>管理炸弹数量</code>的工作。</p><p>&amp;emsp;&amp;emsp;首先，我们在<code>Assets\Scripts\Manager</code>文件夹下创建一个名为<code>BombManager</code>的C#脚本，然后编辑<code>BombManager.cs</code>如下：</p><figure class="highlight csharp"><figcaption><span>BombManager.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br>[<span class="hljs-meta">Serializable</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">BombManager</span> &#123;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;炸弹的初始数量&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> InitBombNumber = <span class="hljs-number">4</span>;<br><br>    <span class="hljs-comment">// 当前的炸弹数量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> m_CurrentBombNumber;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Init</span>()</span> &#123;<br>        m_CurrentBombNumber = InitBombNumber;<br>    &#125;<br><br>    <span class="hljs-comment">// 释放炸弹</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">ReleaseBomb</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> bombNum</span>)</span> &#123;<br>        <span class="hljs-built_in">int</span> temp = m_CurrentBombNumber - bombNum;<br><br>        <span class="hljs-keyword">if</span>(temp &gt;= <span class="hljs-number">0</span>) &#123;<br>            m_CurrentBombNumber = temp;<br>            <br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 拾取炸弹</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PickupBomb</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> bombNum</span>)</span> &#123;<br>        m_CurrentBombNumber += bombNum;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;接着，还需要在<code>GameStateManager.cs</code>中添加对<code>BombManager.cs</code>的管理代码：</p><figure class="highlight csharp"><figcaption><span>GameStateManager.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs csharp">[<span class="hljs-meta">RequireComponent(typeof(AudioSource))</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">GameStateManager</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br>    ...<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;ScoreManager的实例&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> ScoreManager ScoreManagerInstance = <span class="hljs-keyword">new</span> ScoreManager();<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;BombManager的实例&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> BombManager BombManagerInstance = <span class="hljs-keyword">new</span> BombManager();<br><br>    ...<br><br>    <span class="hljs-comment">// 游戏初始化</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">GameInit</span>()</span> &#123;<br>        <span class="hljs-comment">// 执行一些游戏预操作，例如初始化其他Manager、播放过场动画和进行倒计时等</span><br>        ScoreManagerInstance.Init();<br>        BombManagerInstance.Init();<br><br>        <span class="hljs-comment">// 进入游戏开始状态</span><br>        m_CurrentState = GameState.Start;<br>    &#125;<br><br>    <span class="hljs-comment">// 游戏结束</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">GameEnd</span>()</span> &#123;<br>        <span class="hljs-comment">// 停止播放背景音乐</span><br>        m_AudioSource.Stop();<br>        m_AudioSource.loop = <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-comment">// 让管理器停止工作</span><br>        ScoreManagerInstance.Stop();<br>        BombManagerInstance.Stop();<br><br>        <span class="hljs-built_in">float</span> delay = <span class="hljs-number">0f</span>;<br>        <span class="hljs-comment">// 播放胜利或者失败的音效</span><br>        <span class="hljs-keyword">if</span>(m_GameResult) &#123;<br>            <span class="hljs-keyword">if</span>(GameWinClip != <span class="hljs-literal">null</span>) &#123;<br>                AudioSource.PlayClipAtPoint(GameWinClip, <span class="hljs-keyword">this</span>.transform.position);<br>                delay = GameWinClip.length;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                Debug.LogError(<span class="hljs-string">&quot;请设置GameWinClip&quot;</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span>(GameLoseClip != <span class="hljs-literal">null</span>) &#123;<br>                AudioSource.PlayClipAtPoint(GameLoseClip, <span class="hljs-keyword">this</span>.transform.position);<br>                delay = GameLoseClip.length;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                Debug.LogError(<span class="hljs-string">&quot;请设置GameLoseClip&quot;</span>);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 播放完音效之后，删除场景中的所有Generator</span><br>        Destroy(Generator, delay);<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;修改完<code>GameStateManager.cs</code>之后，我们还需要删除<code>PlayerAttack.cs</code>中<code>管理炸弹数量</code>的代码，并使用<code>BombManager</code>提供的<code>ReleaseBomb函数</code>来<code>释放炸弹</code>：</p><figure class="highlight csharp"><figcaption><span>PlayerAttack.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-comment">// [RequireComponent(typeof(Animator))]</span><br>[<span class="hljs-meta">RequireComponent(typeof(PlayerController))</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PlayerAttack</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;导弹Prefab&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> Missile MissilePrefab;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;导弹发射点&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> Transform ShootingPoint;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;发射导弹的音效&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> AudioClip ShootEffect;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;炸弹Prefab&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> Rigidbody2D BombPrefab;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;使用火箭筒抛射炸弹的力&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> ProjectileBombForce = <span class="hljs-number">1000f</span>;<br><br>    <span class="hljs-comment">// private Animator m_Animator;</span><br>    <span class="hljs-keyword">private</span> PlayerController m_PlayerCtrl;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Awake</span>()</span> &#123;<br>        <span class="hljs-comment">// 获取引用</span><br>        <span class="hljs-comment">// m_Animator = GetComponent&lt;Animator&gt;();</span><br>        m_PlayerCtrl = GetComponent&lt;PlayerController&gt;();<br><br>        <span class="hljs-comment">// 检查关键属性是否赋值</span><br>        <span class="hljs-keyword">if</span>(MissilePrefab == <span class="hljs-literal">null</span>) &#123;<br>            Debug.LogError(<span class="hljs-string">&quot;请设置MissilePrefab&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(ShootingPoint == <span class="hljs-literal">null</span>) &#123;<br>            Debug.LogError(<span class="hljs-string">&quot;请设置ShootingPoint&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(BombPrefab == <span class="hljs-literal">null</span>) &#123;<br>            Debug.LogError(<span class="hljs-string">&quot;请设置BombPrefab&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>()</span> &#123;<br>        <span class="hljs-keyword">if</span> (Input.GetButtonDown(<span class="hljs-string">&quot;Fire1&quot;</span>)) &#123;<br>            <span class="hljs-comment">// 发射导弹</span><br>            Fire();<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (Input.GetButtonDown(<span class="hljs-string">&quot;Fire2&quot;</span>)) &#123;<br>            <span class="hljs-comment">// 放置炸弹</span><br>            LayBomb();<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (Input.GetButtonDown(<span class="hljs-string">&quot;Fire3&quot;</span>)) &#123;<br>            <span class="hljs-comment">// 抛射炸弹</span><br>            ProjectileBomb();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 发射导弹</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Fire</span>()</span> &#123;<br>        <span class="hljs-comment">// // 播放射击动画</span><br>        <span class="hljs-comment">// m_Animator.SetTrigger(&quot;Shoot&quot;);</span><br><br>        <span class="hljs-comment">// 播放射击音效</span><br>        AudioSource.PlayClipAtPoint(ShootEffect, ShootingPoint.position);<br><br>        <span class="hljs-comment">// 创建导弹</span><br>        Missile instance = Instantiate(MissilePrefab, ShootingPoint.position, Quaternion.identity) <span class="hljs-keyword">as</span> Missile;<br><br>        <span class="hljs-comment">// 如果角色跟导弹的朝向不一致，就翻转导弹</span><br>        <span class="hljs-keyword">if</span>(m_PlayerCtrl.FacingRight ^ instance.FacingRight) &#123;<br>            instance.Flip();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 放置炸弹</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">LayBomb</span>()</span> &#123;<br>        <span class="hljs-comment">// 判断当前是否至少有一颗炸弹可以释放</span><br>        <span class="hljs-keyword">if</span>(GameStateManager.Instance.BombManagerInstance.ReleaseBomb(<span class="hljs-number">1</span>) == <span class="hljs-literal">false</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 放置炸弹</span><br>        Instantiate(BombPrefab, <span class="hljs-keyword">this</span>.transform.position, Quaternion.identity);<br>    &#125;<br><br>    <span class="hljs-comment">// 抛射炸弹</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ProjectileBomb</span>()</span> &#123;<br>        <span class="hljs-comment">// 判断当前是否至少有一颗炸弹可以释放</span><br>        <span class="hljs-keyword">if</span>(GameStateManager.Instance.BombManagerInstance.ReleaseBomb(<span class="hljs-number">1</span>) == <span class="hljs-literal">false</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 抛射炸弹</span><br>        Rigidbody2D body = Instantiate(BombPrefab, ShootingPoint.position, Quaternion.identity) <span class="hljs-keyword">as</span> Rigidbody2D;<br>        <span class="hljs-keyword">if</span>(m_PlayerCtrl.FacingRight) &#123;<br>            body.AddForce(Vector2.right * ProjectileBombForce);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            body.AddForce(Vector2.left * ProjectileBombForce);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;最后，我们还需要在<code>AmmunitionBoxPickup.cs</code>中使用<code>BombManager</code>提供的<code>PickupBomb函数</code>来<code>拾取炸弹</code>：</p><figure class="highlight csharp"><figcaption><span>AmmunitionBoxPickup.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs csharp">[<span class="hljs-meta">RequireComponent(typeof(CircleCollider2D))</span>]<br>[<span class="hljs-meta">RequireComponent(typeof(BoxCollider2D))</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AmmunitionBoxPickup</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br>...<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnTriggerEnter2D</span>(<span class="hljs-params">Collider2D collision</span>)</span> &#123;<br>        <span class="hljs-comment">// 接触到地面</span><br>        <span class="hljs-keyword">if</span> (collision.tag == <span class="hljs-string">&quot;Ground&quot;</span> &amp;&amp; !m_Landed) &#123;<br>            m_Landed = <span class="hljs-literal">true</span>;<br><br>            <span class="hljs-comment">// 脱离降落伞</span><br>            transform.parent = <span class="hljs-literal">null</span>;<br>            gameObject.AddComponent&lt;Rigidbody2D&gt;();<br><br>            <span class="hljs-comment">// 播放降落伞的落地动画</span><br>            m_Animator.SetTrigger(<span class="hljs-string">&quot;Landing&quot;</span>);<br><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 被角色拾取</span><br>        <span class="hljs-keyword">if</span>(collision.tag == <span class="hljs-string">&quot;Player&quot;</span>) &#123;<br>            <span class="hljs-comment">// 增加炸弹数</span><br>            GameStateManager.Instance.BombManagerInstance.PickupBomb(BombAmount);<br><br>            <span class="hljs-comment">// 播放拾取音效</span><br>            AudioSource.PlayClipAtPoint(PickupEffect, transform.position);<br><br>            <span class="hljs-comment">// 销毁整个物体</span><br>            Destroy(transform.root.gameObject);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;运行游戏，可以看到此时我们能正常<code>释放和拾取炸弹</code>。至此，代码重构完成，后面我们就可以在<code>BombManager</code>中对<code>和炸弹有关的UI</code>进行管理了。</p><hr><h2 id="创建Canvas"><a href="#创建Canvas" class="headerlink" title="创建Canvas"></a>创建Canvas</h2><p>&amp;emsp;&amp;emsp;添加完<code>BombManager</code>之后，我们开始添加UI的工作。在Unity中，<code>Canvas控制UI的绘制和缩放</code>。只有成为Canvas的子物体，UI才能够被正常绘制，且Canvas会按照<code>从上到下的顺序</code>来绘制它的子物体，也就是上面的UI会被下面的UI覆盖。此外，根据<a href="https://docs.unity3d.com/Manual/UICanvas.html">Canvas的说明文档</a>，我们知道Unity的Canvas有三种绘制的方式，它们的区别如下：</p><blockquote><p>Canvas三种绘制的方式：</p></blockquote><ol><li><code>Screen Space - Overlay</code>: 这是Canvas<code>默认的绘制方式</code>。使用<code>Screen Space - Overlay</code>的绘制方式，Canvas<code>不受场景摄像机的影响，直接在屏幕上进行绘制</code>，且<code>在不同的屏幕分辨率下，Canvas会自动适配屏幕的分辨率大小</code>。由于Canvas不受摄像机影响，所以整个过程Canvas都是保持静态的，也就<code>不需要重新计算Canvas的位置和角度</code>，是一种优化性较好的绘制方式。</li><li><code>Screen Space - Camera</code>: 使用<code>Screen Space - Camera</code>的绘制方式，我们需要<code>先选择用于绘制Canvas的摄像机</code>，然后<code>Canvas会被绘制在选定的摄像机最上方</code>。因此，我们可以通过调整用于绘制Canvas的摄像机的属性来实现<code>UI界面的三维翻转</code>和<code>让三维物体显示在UI界面之上</code>等功能。此外，<code>当用于渲染Canvas的摄像机的视口大小发生变化时，Canvas也会自动进行适配</code>。</li><li><code>World Space</code>：使用<code>World Space</code>的绘制方式，Unity会将Canvas当成<code>普通三维物体</code>进行处理。</li></ol><p>&amp;emsp;&amp;emsp;接着，根据<a href="https://docs.unity3d.com/Manual/script-CanvasScaler.html">CanvasScaler的说明文档</a>，我们知道当Canvas进行缩放时，它在绘制UI时有<code>三种对UI进行缩放</code>的方式。在介绍这三种缩放方式之前，我们需要先清楚<code>Unity的UI单位和像素的区别</code>。当我们在Unity里编辑UI的时候，UI的<code>Width</code>和<code>Height</code>使用的是Unity的<code>UI单位</code>，当UI被绘制到屏幕上的时候，UI使用的是<code>像素</code>。了解了<code>Unity的UI单位和像素的区别</code>之后，我们接着了解一下Canvas对UI进行缩放的三种方式的区别：</p><blockquote><p>Canvas对UI进行缩放的三种方式：</p></blockquote><ol><li><code>Constant Pixel Size</code>：在不同尺寸的屏幕上，UI组件会占用相同数量的像素。当<code>ScaleFactor</code>的值为<code>x</code>时，1UI单位等于x个像素。此外，采用这种缩放方式，同样的UI在手机上会比在电脑上小很多，因为手机屏幕的<code>DPI（Dots Per Inch，每英寸点数）</code>，也就是<code>像素密度</code>要远远大于电脑。</li><li><code>Scale With Screen Size</code>：让UI根据屏幕尺寸的大小变化进行缩放，因此我们需要先设置一个用于参考的<code>屏幕尺寸基准值</code></li><li><code>Constant Physical Size</code>：无论屏幕尺寸多大，都让UI保持一样的物理尺寸大小（像素值会变化），如果我们希望在任意的设备上，自己手掌地方图片都可以和你的手掌完全重合，可以采用这种模式</li></ol><p>&amp;emsp;&amp;emsp;在了解了Canvas的绘制方式和对UI的缩放方式之后，我们开始为我们的游戏创建一个用于绘制UI的Canvas：</p><blockquote><p>创建Canvas的步骤如下：</p></blockquote><ol><li>在<code>Hierarchy</code>窗口中右击鼠标，选择<code>UI-&gt;Canvas</code>在场景中新建一个<code>Canvas</code>，然后将其重命名为<code>UICanvas</code></li><li>接着我们对<code>UICanvas</code>下<code>Canvas Scaler</code>组件的设置进行修改<blockquote><blockquote><ol><li>选择<code>UI Scale Mode</code>为<code>Scale With Screen Size</code>，让我们的UI根据屏幕尺寸的变化进行缩放，保证我们的UI在不同尺寸的手机上看起来都差不多</li><li>因为我们预设的屏幕分辨率为<code>1920 X 1080</code>，所以我们设置<code>Reference Resolution</code>为<code>X(1920), Y(1080)</code></li><li>设置<code>Screen Match Mode</code>为<code>Match Width or Height</code>，让Unity根据<code>分辨率的宽和高</code>的<code>权重</code>来缩放Canvas</li><li>我们希望Canvas能同时考虑<code>分辨率的宽和高的变化</code>来缩放UI，因此我们设置<code>Match</code>为<code>0.5</code>（<code>0表示只考虑宽，1表示只考虑高</code>）</li></ol></blockquote></blockquote></li></ol><hr><h2 id="添加提示UI"><a href="#添加提示UI" class="headerlink" title="添加提示UI"></a>添加提示UI</h2><p>&amp;emsp;&amp;emsp;添加完<code>BombManager</code>之后，我们在场景里面添加<code>提示UI</code>，添加<code>提示UI</code>的步骤如下：</p><blockquote><p>添加<code>提示UI</code>的步骤：</p></blockquote><ol><li>在<code>UICanvas</code>物体下新建一个<code>Image</code>，然后将其重名为<code>BombUI</code><blockquote><blockquote><p><code>BombUI</code>物体需要修改的组件属性：</p></blockquote></blockquote><ul><li><code>Rect Transform</code>:<ul><li><code>Anchors</code>: 点击<code>Rect Transform</code>组件左上角的方框，然后选择<code>top-left</code></li><li><code>PosX</code>: 160</li><li><code>PosY</code>: -100</li><li><code>Width</code>: 150</li><li><code>Height</code>: 150</li></ul></li><li><code>Image</code>: <ul><li><code>Source Image</code>: <code>Assets\Sprites\Props</code>文件夹下的<code>prop_crate_ammo</code>图片</li><li><code>Color</code>: (255, 255, 255, 200)</li></ul></li></ul></li><li>在<code>BombUI</code>物体下新建一个<code>Text</code>，然后将其重命名为<code>BombNumberText</code><blockquote><blockquote><p><code>BombNumberText</code>物体需要修改的组件属性：</p></blockquote></blockquote><ul><li><code>Rect Transform</code>:<ul><li><code>PosX</code>: -3.5</li><li><code>PosY</code>: -10</li><li><code>Width</code>: 200</li><li><code>Height</code>: 160</li></ul></li><li><code>Text</code>: <ul><li><code>Text</code>: <code>0</code></li><li><code>Font</code>: <code>Assets\Fonts</code>下的<code>BradBunR</code>字体文件</li><li><code>Font Size</code>: 80</li><li><code>Alignment</code>: 水平居中，垂直居中</li></ul></li></ul></li><li>在<code>UICanvas</code>物体下新建一个<code>Text</code>，然后将其重名为<code>TargetScoreLabel</code><blockquote><blockquote><p><code>TargetScoreLabel</code>物体需要修改的组件属性：</p></blockquote></blockquote><ul><li><code>Rect Transform</code>:<ul><li><code>Anchors</code>: 点击<code>Rect Transform</code>组件左上角的方框，然后选择<code>top-center</code></li><li><code>PosX</code>: -460</li><li><code>PosY</code>: -35</li><li><code>Width</code>: 320</li><li><code>Height</code>: 80</li></ul></li><li><code>Text</code>: <ul><li><code>Text</code>: <code>Target Score:</code></li><li><code>Font</code>: <code>Assets\Fonts</code>下的<code>BradBunR</code>字体文件</li><li><code>Font Size</code>: 60</li><li><code>Alignment</code>: 水平居中，垂直居中</li><li><code>Color</code>: (119, 119, 119, 180)</li></ul></li></ul></li><li>在<code>TargetScoreLabel</code>物体下新建一个<code>Text</code>，然后将其重命名为<code>TargetScoreText</code><blockquote><blockquote><p><code>TargetScoreText</code>物体需要修改的组件属性：</p></blockquote></blockquote><ul><li><code>Rect Transform</code>:<ul><li><code>PosX</code>: 0</li><li><code>PosY</code>: -50</li><li><code>Width</code>: 320</li><li><code>Height</code>: 80</li></ul></li><li><code>Text</code>: <ul><li><code>Text</code>: <code>50000</code></li><li><code>Font</code>: <code>Assets\Fonts</code>下的<code>BradBunR</code>字体文件</li><li><code>Font Size</code>: 60</li><li><code>Alignment</code>: 水平居中，垂直居中</li><li><code>Color</code>: (119, 119, 119, 180)</li></ul></li></ul></li><li>在<code>UICanvas</code>物体下新建一个<code>Text</code>，然后将其重名为<code>ScoreLabel</code><blockquote><blockquote><p><code>ScoreLabel</code>物体需要修改的组件属性：</p></blockquote></blockquote><ul><li><code>Rect Transform</code>:<ul><li><code>Anchors</code>: 点击<code>Rect Transform</code>组件左上角的方框，然后选择<code>top-center</code></li><li><code>PosX</code>: -80</li><li><code>PosY</code>: -70</li><li><code>Width</code>: 240</li><li><code>Height</code>: 120</li></ul></li><li><code>Text</code>: <ul><li><code>Text</code>: <code>Score:</code></li><li><code>Font</code>: <code>Assets\Fonts</code>下的<code>BradBunR</code>字体文件</li><li><code>Font Size</code>: 100</li><li><code>Alignment</code>: 水平居中，垂直居中</li><li><code>Color</code>: (0, 0, 0, 255)</li></ul></li></ul></li><li>在<code>ScoreLabel</code>物体下新建一个<code>Text</code>，然后将其重名为<code>ScoreLabelForground</code><blockquote><blockquote><p><code>ScoreLabelForground</code>物体需要修改的组件属性：</p></blockquote></blockquote><ul><li><code>Rect Transform</code>:<ul><li><code>PosX</code>: 0</li><li><code>PosY</code>: -49</li><li><code>Width</code>: 240</li><li><code>Height</code>: 120</li></ul></li><li><code>Text</code>: <ul><li><code>Text</code>: <code>Score:</code></li><li><code>Font</code>: <code>Assets\Fonts</code>下的<code>BradBunR</code>字体文件</li><li><code>Font Size</code>: 100</li><li><code>Alignment</code>: 水平居中，垂直居中</li></ul></li></ul></li><li>在<code>UICanvas</code>物体下新建一个<code>Text</code>，然后将其重名为<code>ScoreText</code><blockquote><blockquote><p><code>ScoreText</code>物体需要修改的组件属性：</p></blockquote></blockquote><ul><li><code>Rect Transform</code>:<ul><li><code>Anchors</code>: 点击<code>Rect Transform</code>组件左上角的方框，然后选择<code>top-center</code></li><li><code>PosX</code>: 225</li><li><code>PosY</code>: -70</li><li><code>Width</code>: 320</li><li><code>Height</code>: 120</li></ul></li><li><code>Text</code>: <ul><li><code>Text</code>: <code>50000</code></li><li><code>Font</code>: <code>Assets\Fonts</code>下的<code>BradBunR</code>字体文件</li><li><code>Font Size</code>: 80</li><li><code>Alignment</code>: 向左对齐，垂直居中</li></ul></li></ul></li><li>在<code>UICanvas</code>物体下新建一个<code>Button</code>，然后将其重名为<code>BackButton</code>，并删除<code>BackButton</code>的<code>Text</code>子物体<blockquote><blockquote><p><code>BackButton</code>物体需要修改的组件属性：</p></blockquote></blockquote><ul><li><code>Rect Transform</code>:<ul><li><code>Anchors</code>: 点击<code>Rect Transform</code>组件左上角的方框，然后选择<code>top-right</code></li><li><code>PosX</code>: -140</li><li><code>PosY</code>: -75</li><li><code>Width</code>: 115</li><li><code>Height</code>: 100</li></ul></li><li><code>Image</code>: <ul><li><code>Source Image</code>: <code>Assets\Sprites\UI</code>文件夹下的<code>BackButton</code>图片</li><li><code>Color</code>: (119, 119, 119, 255)</li></ul></li></ul></li><li>在<code>UICanvas</code>物体下新建一个<code>Button</code>，然后将其重名为<code>BackButton</code>，并删除<code>BackButton</code>的<code>Text</code>子物体<blockquote><blockquote><p><code>BackButton</code>物体需要修改的组件属性：</p></blockquote></blockquote><ul><li><code>Rect Transform</code>:<ul><li><code>Anchors</code>: 点击<code>Rect Transform</code>组件左上角的方框，然后选择<code>top-right</code></li><li><code>PosX</code>: -140</li><li><code>PosY</code>: -75</li><li><code>Width</code>: 115</li><li><code>Height</code>: 100</li></ul></li><li><code>Image</code>: <ul><li><code>Source Image</code>: <code>Assets\Sprites\UI</code>文件夹下的<code>BackButton</code>图片</li><li><code>Color</code>: (119, 119, 119, 255)</li></ul></li></ul></li></ol><p>&amp;emsp;&amp;emsp;添加完<code>提示UI</code>之后，我们<code>Game</code>窗口中选择其它尺寸的<code>视口</code>，可以看到，游戏场景中的UI会随着<code>视口尺寸的改变而缩放</code>。</p><p><img src="https://github.com/AsanCai/BlogImage/raw/master/PotatoGloryTutorial/Essay20/Image1.png" alt="添加提示UI之后的游戏场景"></p><hr><h2 id="更新提示UI的内容"><a href="#更新提示UI的内容" class="headerlink" title="更新提示UI的内容"></a>更新提示UI的内容</h2><p>&amp;emsp;&amp;emsp;添加完<code>提示UI</code>之后，我们还需要选择使用代码在游戏运行时更新<code>提示UI</code>的内容。首先，我们为<code>BombManager.cs</code>加入更新<code>提示UI</code>的代码：</p><figure class="highlight csharp"><figcaption><span>BombManager.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><span class="hljs-keyword">using</span> UnityEngine.UI;<br><br>[<span class="hljs-meta">Serializable</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">BombManager</span> &#123;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;炸弹的初始数量&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> InitBombNumber = <span class="hljs-number">4</span>;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;炸弹UI&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> Image BombUI;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;显示炸弹的数量&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> Text BombNumberText;<br><br>    <span class="hljs-comment">// 当前的炸弹数量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> m_CurrentBombNumber;<br>    <span class="hljs-comment">// 当前管理器是否停止工作</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">bool</span> m_Stop;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Init</span>()</span> &#123;<br>        m_CurrentBombNumber = InitBombNumber;<br>        m_Stop = <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-comment">// 更新UI</span><br>        UpdateUI();<br>    &#125;<br><br>    <span class="hljs-comment">// 管理器停止工作</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Stop</span>()</span> &#123;<br>        m_Stop = <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 释放炸弹</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">ReleaseBomb</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> bombNum</span>)</span> &#123;<br>        <span class="hljs-comment">// 管理器停止工作，不执行任何操作</span><br>        <span class="hljs-keyword">if</span>(m_Stop) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-built_in">int</span> temp = m_CurrentBombNumber - bombNum;<br><br>        <span class="hljs-keyword">if</span>(temp &gt;= <span class="hljs-number">0</span>) &#123;<br>            m_CurrentBombNumber = temp;<br>            <span class="hljs-comment">// 更新UI</span><br>            UpdateUI();<br><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 拾取炸弹</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PickupBomb</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> bombNum</span>)</span> &#123;<br>        <span class="hljs-comment">// 管理器停止工作，不执行任何操作</span><br>        <span class="hljs-keyword">if</span>(m_Stop) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        m_CurrentBombNumber += bombNum;<br>        <span class="hljs-comment">// 更新UI</span><br>        UpdateUI();<br>    &#125;<br><br>    <span class="hljs-comment">// 更新UI</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">UpdateUI</span>()</span> &#123;<br>        BombNumberText.text = <span class="hljs-string">&quot;&quot;</span> + m_CurrentBombNumber;<br><br>        <span class="hljs-keyword">if</span>(m_CurrentBombNumber &lt;= <span class="hljs-number">0</span>) &#123;<br>            BombUI.color = <span class="hljs-keyword">new</span> Color(<span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, BombUI.color.a / <span class="hljs-number">2</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            BombUI.color = <span class="hljs-keyword">new</span> Color(<span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>, BombUI.color.a);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>代码说明：<br>&amp;emsp;&amp;emsp;因为我们使用了<code>Text</code>类和<code>Image</code>类来操作UI，所以我们需要加上<code>using UnityEngine.UI;</code></p></blockquote><p>&amp;emsp;&amp;emsp;修改完<code>BombManager.cs</code>之后，我们继续为<code>ScoreManager.cs</code>加入更新<code>提示UI</code>的代码：</p><figure class="highlight csharp"><figcaption><span>ScoreManager.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><span class="hljs-keyword">using</span> UnityEngine.UI;<br><br>[<span class="hljs-meta">Serializable</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ScoreManager</span> &#123;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;游戏胜利的目标分数&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> TargetScore = <span class="hljs-number">5000</span>;<br><br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;保存嘲讽音效&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> AudioClip[] TauntClips;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;得分之后播放嘲讽音效的概率&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> TauntProbaility = <span class="hljs-number">50f</span>;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;嘲讽的间隔&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> TauntDelay = <span class="hljs-number">1f</span>;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;显示目标分数&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> Text TargetScoreText;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;显示当前的分数&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> Text ScoreText;<br><br>    <span class="hljs-comment">// 当前的分数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> m_CurrentScore;<br>    <span class="hljs-comment">// 上一次播放的嘲讽音效的下标</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> m_TauntIndex;<br>    <span class="hljs-comment">// 上一次播放嘲讽音效的时间</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">float</span> m_LastTauntTime;<br>    <span class="hljs-comment">// 当前管理器是否停止工作</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">bool</span> m_Stop;<br><br>    <span class="hljs-keyword">private</span> Transform m_Player;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Init</span>()</span> &#123;<br>        m_CurrentScore = <span class="hljs-number">0</span>;<br>        m_TauntIndex = <span class="hljs-number">0</span>;<br>        m_LastTauntTime = Time.time;<br>        m_Stop = <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-comment">// 初始化目标分数</span><br>        TargetScoreText.text = <span class="hljs-string">&quot;&quot;</span> + TargetScore;<br>        <span class="hljs-comment">// 初始化当前分数</span><br>        ScoreText.text = <span class="hljs-string">&quot;&quot;</span> + m_CurrentScore;<br><br>        m_Player = GameObject.FindGameObjectWithTag(<span class="hljs-string">&quot;Player&quot;</span>).transform;;<br>    &#125;<br><br>    <span class="hljs-comment">// 管理器停止工作</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Stop</span>()</span> &#123;<br>        m_Stop = <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">AddScore</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> score</span>)</span> &#123;<br>        <span class="hljs-comment">// 管理器停止工作，不执行任何操作</span><br>        <span class="hljs-keyword">if</span>(m_Stop) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 增加分数</span><br>        m_CurrentScore += score;<br>        <span class="hljs-comment">// 更新当前分数</span><br>        ScoreText.text = <span class="hljs-string">&quot;&quot;</span> + m_CurrentScore;<br><br>        <span class="hljs-comment">// 达到目标分数，游戏胜利</span><br>        <span class="hljs-keyword">if</span>(m_CurrentScore &gt;= TargetScore) &#123;<br>            GameStateManager.Instance.SetGameResult(<span class="hljs-literal">true</span>);<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span>(m_LastTauntTime &lt;= Time.time + TauntDelay) &#123;<br>            <span class="hljs-built_in">float</span> tauntChance = UnityEngine.Random.Range(<span class="hljs-number">0f</span>, <span class="hljs-number">100f</span>);<br><br>            <span class="hljs-keyword">if</span>(tauntChance &gt; TauntProbaility) &#123;<br>                <span class="hljs-comment">// 播放嘲讽音效</span><br>                m_TauntIndex = TauntRandom();<br>                AudioSource.PlayClipAtPoint(TauntClips[m_TauntIndex], m_Player.position);<br>            &#125;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-comment">//确保相邻两次嘲讽音效不相同</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> <span class="hljs-title">TauntRandom</span>()</span> &#123;<br>        <span class="hljs-built_in">int</span> i = UnityEngine.Random.Range(<span class="hljs-number">0</span>, TauntClips.Length);<br><br>        <span class="hljs-keyword">if</span> (i == m_TauntIndex)<br>            <span class="hljs-keyword">return</span> TauntRandom();<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> i;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>代码说明：<br>&amp;emsp;&amp;emsp;因为我们使用了<code>Text</code>类来操作UI，所以我们需要加上<code>using UnityEngine.UI;</code></p></blockquote><p>&amp;emsp;&amp;emsp;脚本编辑完成之后，我们选择<code>Hierarchy</code>窗口中的<code>GameStateManager</code>，然后将<code>UICanvas</code>物体下的<code>TargetScoreText</code>和<code>ScoreText</code>子物体分别拖拽到<code>Score Manager Instance</code>折叠框下的<code>Target Score Text</code>和<code>Score Text</code>属性赋值框，接着将<code>UICanvas</code>物体下的<code>BombUI</code>和<code>BombNumberText</code>子物体分别拖拽到<code>Bomb Manager Instance</code>折叠框下的<code>Bomb UI</code>和<code>Bomb Number Text</code>属性赋值框。最后，运行游戏，可以看到此时<code>提示UI</code>能正确显示<code>目标分数</code>、<code>当前的分数</code>以及<code>当前可释放的炸弹数</code>。</p><p><img src="https://github.com/AsanCai/BlogImage/raw/master/PotatoGloryTutorial/Essay20/Image2.png" alt="提示UI的设置"></p><hr><h2 id="添加游戏暂停UI和游戏结束UI"><a href="#添加游戏暂停UI和游戏结束UI" class="headerlink" title="添加游戏暂停UI和游戏结束UI"></a>添加游戏暂停UI和游戏结束UI</h2><p>&amp;emsp;&amp;emsp;添加完<code>提示UI</code>之后，我们继续在场景里面添加<code>游戏暂停UI</code>和<code>游戏结束UI</code>。首先，我们先为场景添加<code>游戏暂停UI</code>：</p><blockquote><p>添加<code>游戏暂停UI</code>的步骤：</p></blockquote><ol><li>在<code>UICanvas</code>物体下新建一个<code>Panel</code>，然后将其重名为<code>PausedPanel</code><blockquote><blockquote><p><code>PausedPanel</code>物体需要修改的组件属性：</p></blockquote></blockquote><ul><li><code>Image</code>: <ul><li><code>Color</code>: (119, 119, 119, 100)</li></ul></li></ul></li><li>在<code>PausedPanel</code>物体下新建一个<code>Image</code>，然后将其重命名为<code>Background</code><blockquote><blockquote><p><code>Background</code>物体需要修改的组件属性：</p></blockquote></blockquote><ul><li><code>Rect Transform</code>:<ul><li><code>Width</code>: 1200</li><li><code>Height</code>: 900</li></ul></li><li><code>Image</code>: <ul><li><code>Source Image</code>: <code>Assets\Sprites\UI</code>文件夹下的<code>SF Window</code>图片</li><li><code>Color</code>: (119, 119, 119, 100)</li></ul></li></ul></li><li>在<code>Background</code>物体下新建一个<code>Text</code>，然后将其重名为<code>PausedText</code><blockquote><blockquote><p><code>PausedText</code>物体需要修改的组件属性：</p></blockquote></blockquote><ul><li><code>Rect Transform</code>:<ul><li><code>PosX</code>: 0</li><li><code>PosY</code>: 100</li><li><code>Width</code>: 560</li><li><code>Height</code>: 480</li></ul></li><li><code>Text</code>: <ul><li><code>Text</code>: <code>Whether to quit the game？</code></li><li><code>Font</code>: <code>Assets\Fonts</code>下的<code>BradBunR</code>字体文件</li><li><code>Font Size</code>: 80</li><li><code>Alignment</code>: 水平居中，垂直居中</li></ul></li></ul></li><li>在<code>PausedPanel</code>物体下新建一个<code>Button</code>，然后将其重名为<code>ConfirmButton</code><blockquote><blockquote><p><code>ConfirmButton</code>物体需要修改的组件属性：</p></blockquote></blockquote><ul><li><code>Rect Transform</code>:<ul><li><code>PosX</code>: -220</li><li><code>PosY</code>: -175</li><li><code>Width</code>: 300</li><li><code>Height</code>: 120</li></ul></li><li><code>Image</code>: <ul><li><code>Source Image</code>: <code>Assets\Sprites\UI</code>文件夹下的<code>SF Button</code>图片</li></ul></li></ul></li><li>修改<code>ConfirmButton</code>物体下的子物体<code>Text</code><blockquote><blockquote><p><code>Text</code>物体需要修改的组件属性：</p></blockquote></blockquote><ul><li><code>Text</code>: <ul><li><code>Text</code>: <code>Yes</code></li><li><code>Font</code>: <code>Assets\Fonts</code>下的<code>BradBunR</code>字体文件</li><li><code>Font Size</code>: 80</li><li><code>Alignment</code>: 水平居中，垂直居中</li></ul></li></ul></li><li>在<code>PausedPanel</code>物体下新建一个<code>Button</code>，然后将其重名为<code>CancelButton</code><blockquote><blockquote><p><code>CancelButton</code>物体需要修改的组件属性：</p></blockquote></blockquote><ul><li><code>Rect Transform</code>:<ul><li><code>PosX</code>: 220</li><li><code>PosY</code>: -175</li><li><code>Width</code>: 300</li><li><code>Height</code>: 120</li></ul></li><li><code>Image</code>: <ul><li><code>Source Image</code>: <code>Assets\Sprites\UI</code>文件夹下的<code>SF Button</code>图片</li></ul></li></ul></li><li>修改<code>CancelButton</code>物体下的子物体<code>Text</code><blockquote><blockquote><p><code>Text</code>物体需要修改的组件属性：</p></blockquote></blockquote><ul><li><code>Text</code>: <ul><li><code>Text</code>: <code>No</code></li><li><code>Font</code>: <code>Assets\Fonts</code>下的<code>BradBunR</code>字体文件</li><li><code>Font Size</code>: 80</li><li><code>Alignment</code>: 水平居中，垂直居中</li></ul></li></ul></li></ol><p><img src="https://github.com/AsanCai/BlogImage/raw/master/PotatoGloryTutorial/Essay20/Image3.png" alt="添加游戏暂停UI之后的游戏场景"></p><p>&amp;emsp;&amp;emsp;添加完<code>游戏暂停UI</code>之后，我们继续添加<code>游戏结束UI</code>：</p><blockquote><p>添加<code>游戏结束UI</code>的步骤：</p></blockquote><ol><li>复制<code>PausedPanel</code>得到<code>PausedPanel (1)</code>，并将<code>PausedPanel (1)</code>物体重命名为<code>GameResultPanel</code></li><li>将<code>PausedPanel</code>物体设置为在游戏场景中不可见</li><li>将<code>PausedText</code>物体重名为<code>GameResultText</code><blockquote><blockquote><p><code>GameResultText</code>物体需要修改的组件属性：</p></blockquote></blockquote><ul><li><code>Text</code>: <ul><li><code>Width</code>: 600</li><li><code>Height</code>: 480</li><li><code>Text</code>: <code>You Win!!!</code></li><li><code>Font Size</code>: 150</li><li><code>Color</code>: (103, 103, 103, 255)</li></ul></li></ul></li><li>将<code>ConfirmButton</code>物体重命名为<code>RestartButton</code></li><li>修改<code>RestartButton</code>物体下的子物体<code>Text</code><blockquote><blockquote><p><code>Text</code>物体需要修改的组件属性：</p></blockquote></blockquote><ul><li><code>Text</code>: <ul><li><code>Text</code>: <code>Restart</code></li></ul></li></ul></li><li>将<code>CancelButton</code>重命名为<code>QuitButton</code></li><li>修改<code>QuitButton</code>物体下的子物体<code>Text</code><blockquote><blockquote><p><code>Text</code>物体需要修改的组件属性：</p></blockquote></blockquote><ul><li><code>Text</code>: <ul><li><code>Text</code>: <code>Quit</code></li></ul></li></ul></li></ol><p><img src="https://github.com/AsanCai/BlogImage/raw/master/PotatoGloryTutorial/Essay20/Image4.png" alt="添加游戏结束UI之后的游戏场景"></p><p>&amp;emsp;&amp;emsp;添加完<code>游戏结束UI</code>之后，我们将<code>GameResultPanel</code>设置为在游戏场景中不可见。</p><hr><h2 id="管理游戏暂停UI和游戏结束UI"><a href="#管理游戏暂停UI和游戏结束UI" class="headerlink" title="管理游戏暂停UI和游戏结束UI"></a>管理游戏暂停UI和游戏结束UI</h2><p>&amp;emsp;&amp;emsp;添加完<code>游戏暂停UI</code>和<code>游戏结束UI</code>之后，我们还需要在<code>GameStateManager.cs</code>中加入管理游戏暂停UI和游戏结束UI的代码：</p><figure class="highlight csharp"><figcaption><span>GameStateManager.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><span class="hljs-keyword">using</span> UnityEngine.UI;<br><span class="hljs-keyword">using</span> UnityEngine.SceneManagement;<br><br><span class="hljs-comment">// 游戏状态</span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">enum</span> GameState &#123;<br>    Init,<br>    Start,<br>    Running,<br>    End<br>&#125;<br><br>[<span class="hljs-meta">RequireComponent(typeof(AudioSource))</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">GameStateManager</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br>    <span class="hljs-comment">// 静态实例</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> GameStateManager m_Instance = <span class="hljs-literal">null</span>;<br>    <span class="hljs-comment">// 使用Property来访问静态实例</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> GameStateManager Instance &#123;<br>        <span class="hljs-keyword">get</span> &#123;<br>            <span class="hljs-keyword">if</span> (m_Instance == <span class="hljs-literal">null</span>) &#123;<br>                m_Instance = FindObjectOfType(<span class="hljs-keyword">typeof</span>(GameStateManager)) <span class="hljs-keyword">as</span> GameStateManager;<br>                <br>                <span class="hljs-comment">// 场景中没有添加了GameStateManager.cs脚本的GameObject，就自动创建一个</span><br>                <span class="hljs-keyword">if</span> (m_Instance == <span class="hljs-literal">null</span>) &#123;<br>                    GameObject obj = <span class="hljs-keyword">new</span> GameObject(<span class="hljs-string">&quot;GameStateManager&quot;</span>);<br>                    m_Instance = obj.AddComponent&lt;GameStateManager&gt;();<br>                &#125;<br>            &#125;<br>            <br>            <span class="hljs-comment">// 返回静态实例的引用</span><br>            <span class="hljs-keyword">return</span> m_Instance;<br>        &#125;<br>    &#125;<br><br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;游戏运行时的背景音乐&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> AudioClip BackgroundMusic;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;游戏胜利时的音效&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> AudioClip GameWinClip;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;游戏失败时的音效&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> AudioClip GameLoseClip;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;场景中所有Generator的父物体&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> GameObject Generator;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;ScoreManager的实例&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> ScoreManager ScoreManagerInstance = <span class="hljs-keyword">new</span> ScoreManager();<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;BombManager的实例&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> BombManager BombManagerInstance = <span class="hljs-keyword">new</span> BombManager();<br><br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;游戏暂停界面&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> GameObject PausedPanel;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;游戏结束界面&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> GameObject GameResultPanel;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;游戏结果&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> Text GameResultText;<br><br>    <span class="hljs-comment">// 游戏处于哪个状态</span><br>    <span class="hljs-keyword">private</span> GameState m_CurrentState;<br>    <span class="hljs-comment">// 游戏是否处于暂停状态</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">bool</span> m_IsPaused;<br>    <span class="hljs-comment">// 游戏结果，true为胜利，false为失败</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">bool</span> m_GameResult;<br><br>    <span class="hljs-keyword">private</span> AudioSource m_AudioSource;<br><br><span class="hljs-meta">#<span class="hljs-keyword">region</span> MonoBehaviour的事件函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Awake</span>()</span> &#123;<br>        <span class="hljs-comment">// 初始化组件</span><br>        m_AudioSource = GetComponent&lt;AudioSource&gt;();<br>        m_AudioSource.playOnAwake = <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span> &#123;<br>        <span class="hljs-comment">// 初始化成员变量</span><br>        m_IsPaused = <span class="hljs-literal">false</span>;<br>        m_CurrentState = GameState.Init;<br>        <br>        <span class="hljs-comment">// 开始游戏主循环</span><br>        StartCoroutine(GameMainLoop());<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">region</span> 自定义游戏状态函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> IEnumerator <span class="hljs-title">GameMainLoop</span>()</span> &#123;<br>        GameInit();<br><br>        <span class="hljs-keyword">while</span>(m_CurrentState == GameState.Init) &#123;<br>            <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        GameStart();<br><br>        <span class="hljs-keyword">while</span>(m_CurrentState == GameState.Running) &#123;<br>            GameRunning();<br><br>            <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        GameEnd();<br>    &#125;<br><br>    <span class="hljs-comment">// 游戏初始化</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">GameInit</span>()</span> &#123;<br>        <span class="hljs-comment">// 执行一些游戏预操作，例如初始化其他Manager、播放过场动画和进行倒计时等</span><br>        ScoreManagerInstance.Init();<br>        BombManagerInstance.Init();<br>        <br>        <span class="hljs-comment">// 确保不显示</span><br>        PausedPanel.SetActive(<span class="hljs-literal">false</span>);<br>        GameResultPanel.SetActive(<span class="hljs-literal">false</span>);<br><br>        <span class="hljs-comment">// 进入游戏开始状态</span><br>        m_CurrentState = GameState.Start;<br>    &#125;<br><br>    <span class="hljs-comment">// 游戏开始</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">GameStart</span>()</span> &#123;<br>        <span class="hljs-comment">// 开始播放背景音乐</span><br>        <span class="hljs-keyword">if</span>(BackgroundMusic != <span class="hljs-literal">null</span>) &#123;<br>            m_AudioSource.clip = BackgroundMusic;<br>            m_AudioSource.loop = <span class="hljs-literal">true</span>;<br>            m_AudioSource.Play();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            Debug.LogError(<span class="hljs-string">&quot;请设置BackgroundMusic&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 进入游戏运行状态</span><br>        m_CurrentState = GameState.Running;<br>    &#125;<br><br>    <span class="hljs-comment">// 游戏运行</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">GameRunning</span>()</span> &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> UNITY_STANDALONE || UNITY_EDITOR</span><br>        <span class="hljs-comment">// 暂停或者恢复游戏</span><br>        <span class="hljs-keyword">if</span>(Input.GetKeyDown(KeyCode.P)) &#123;<br>            <span class="hljs-keyword">if</span>(m_IsPaused) &#123;<br>                GameContinue();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                GamePause();<br>            &#125;<br>        &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    &#125;<br><br>    <span class="hljs-comment">// 游戏结束</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">GameEnd</span>()</span> &#123;<br>        <span class="hljs-comment">// 停止播放背景音乐</span><br>        m_AudioSource.Stop();<br>        m_AudioSource.loop = <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-comment">// 让管理器停止工作</span><br>        ScoreManagerInstance.Stop();<br>        BombManagerInstance.Stop();<br><br>        <span class="hljs-built_in">float</span> delay = <span class="hljs-number">0f</span>;<br>        <span class="hljs-comment">// 播放胜利或者失败的音效</span><br>        <span class="hljs-keyword">if</span>(m_GameResult) &#123;<br>            <span class="hljs-keyword">if</span>(GameWinClip != <span class="hljs-literal">null</span>) &#123;<br>                AudioSource.PlayClipAtPoint(GameWinClip, <span class="hljs-keyword">this</span>.transform.position);<br>                delay = GameWinClip.length;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                Debug.LogError(<span class="hljs-string">&quot;请设置GameWinClip&quot;</span>);<br>            &#125;<br><br>            <span class="hljs-comment">// 设置游戏结果</span><br>            GameResultText.text = <span class="hljs-string">&quot;You Win!!!&quot;</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span>(GameLoseClip != <span class="hljs-literal">null</span>) &#123;<br>                AudioSource.PlayClipAtPoint(GameLoseClip, <span class="hljs-keyword">this</span>.transform.position);<br>                delay = GameLoseClip.length;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                Debug.LogError(<span class="hljs-string">&quot;请设置GameLoseClip&quot;</span>);<br>            &#125;<br><br>            <span class="hljs-comment">// 设置游戏结果</span><br>            GameResultText.text = <span class="hljs-string">&quot;You Lose!!!&quot;</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 显示游戏结束界面</span><br>        GameResultPanel.SetActive(<span class="hljs-literal">true</span>);<br>        <span class="hljs-comment">// 播放完音效之后，删除场景中的所有Generator</span><br>        Destroy(Generator, delay);<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>    <span class="hljs-meta">#<span class="hljs-keyword">region</span>  外部调用函数</span><br>    <span class="hljs-comment">// 设置游戏结果</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SetGameResult</span>(<span class="hljs-params"><span class="hljs-built_in">bool</span> result</span>)</span> &#123;<br>        m_GameResult = result;<br>        m_CurrentState = GameState.End;<br>    &#125;<br><br>        <span class="hljs-comment">// 暂停游戏</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">GamePause</span>()</span> &#123;<br>        <span class="hljs-comment">// 暂停背景音乐的播放</span><br>        m_AudioSource.Pause();<br>        <span class="hljs-comment">// 暂停游戏</span><br>        Time.timeScale = <span class="hljs-number">0f</span>;<br><br>        m_IsPaused = <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">// 显示游戏暂停界面</span><br>        PausedPanel.SetActive(<span class="hljs-literal">true</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 继续游戏</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">GameContinue</span>()</span> &#123;<br>        <span class="hljs-comment">// 恢复背景音乐的播放</span><br>        Time.timeScale = <span class="hljs-number">1f</span>;<br>        <span class="hljs-comment">// 恢复游戏</span><br>        m_AudioSource.UnPause();<br><br>        m_IsPaused = <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">// 隐藏游戏暂停界面</span><br>        PausedPanel.SetActive(<span class="hljs-literal">false</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 重新开始游戏</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Restart</span>()</span> &#123;<br>        <span class="hljs-comment">// 重新加载当前的游戏场景</span><br>        SceneManager.LoadScene(SceneManager.GetActiveScene().buildIndex);<br>    &#125;<br><br>    <span class="hljs-comment">// 返回主菜单</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Back</span>()</span> &#123;<br><br>    &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>代码说明：</p></blockquote><ol><li>因为我们使用了<code>Text</code>来操作UI，所以我们需要加上<code>using UnityEngine.UI;</code></li><li>因为我们使用了<code>SceneManager</code>来加载场景，所以我们需要加上<code>using UnityEngine.SceneManagement;</code></li><li>为了方便测试，我们在<code>GameRunning</code>方法中使用了<a href="https://docs.unity3d.com/Manual/PlatformDependentCompilation.html">Unity提供的平台宏定义</a>来进行平台隔离</li><li>为了将<code>GamePause函数</code>和<code>GameContinue函数</code>设置为<code>按钮点击事件的回调函数</code>，我们将<code>GamePause函数</code>和<code>GameContinue函数</code>的可见性设置为<code>public</code></li></ol><p>&amp;emsp;&amp;emsp;编辑完<code>GameStateManager.cs</code>之后，我们在<code>Hierarchy</code>窗口选中<code>GameStateManager</code>物体，然后将<code>GameStateManager</code>物体上<code>GameStateManager.cs</code>组件的<code>Paused Panel</code>和<code>Game Result Panel</code>字段分别设置<code>UICanvas</code>下的子物体<code>PausedPanel</code>和子物体<code>GameResultPanel</code>，将<code>Game Result Text</code>字段设置为<code>GameResultPanel</code>物体下的子物体<code>Game Result Text</code>。</p><p><img src="https://github.com/AsanCai/BlogImage/raw/master/PotatoGloryTutorial/Essay20/Image5.png" alt="游戏暂停UI和游戏结束UI的设置"></p><p>&amp;emsp;&amp;emsp;设置完<code>游戏暂停UI</code>和<code>游戏结束UI</code>之后，我们还需要设置<code>按钮的点击事件</code>,我们先来设置<code>BackButton</code>的点击事件。</p><blockquote><p><code>BackButton</code>点击事件的设置步骤：</p></blockquote><ol><li>选中<code>BackButton</code>物体，然后点击其<code>Button</code>组件上<code>On Click()</code>下的<code>+</code>号增加一个<code>空点击事件</code></li><li>将场景中的<code>GameStateManager</code>拖拽至<code>On Click()</code>下的<code>GameObject</code>赋值框处</li><li>点击<code>No Function</code>下拉菜单，选择<code>GameStateManager</code>下的<code>GamePause函数</code></li></ol><p><img src="https://github.com/AsanCai/BlogImage/raw/master/PotatoGloryTutorial/Essay20/Image6.png" alt="设置BackButton的点击事件"></p><p>&amp;emsp;&amp;emsp;最后，我们按照相同的步骤，将<code>PausedPanel</code>物体的子物体<code>ConfirmButton</code>的点击事件设置为<code>GameStateManager</code>下的<code>Back函数</code>，将<code>PausedPanel</code>物体的子物体<code>CancelButton</code>的点击事件设置为<code>GameStateManager</code>下的<code>GameContinue函数</code>，将<code>GameResultPanel</code>物体的子物体<code>RestartButton</code>的点击事件设置为<code>GameStateManager</code>下的<code>Restart函数</code>，将<code>GameResultPanel</code>物体的子物体<code>QuitButton</code>的点击事件设置为<code>GameStateManager</code>下的<code>Back函数</code>。</p><p>&amp;emsp;&amp;emsp;运行游戏，可以看到当游戏胜利或者失败时，会弹出游戏结束界面，此时若点击<code>Restart</code>按钮，游戏将重新开始。此外，当我们点击<code>BackButton</code>时，游戏会暂停并弹出游戏暂停界面，若我们点击游戏暂停界面的<code>No</code>按钮时，游戏恢复且游戏暂停界面消失。</p><hr><h2 id="后言"><a href="#后言" class="headerlink" title="后言"></a>后言</h2><p>&amp;emsp;&amp;emsp;需要注意的是，目前我们还没有实现菜单场景，因此我们的<code>Back函数</code>是一个空函数。最后，本篇文章所做的修改，可以在<a href="https://github.com/AsanCai/PotatoGloryTutorial">PotatoGloryTutorial</a>这个仓库的<code>essay18</code>分支下看到，读者可以clone这个仓库到本地进行查看。</p><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://docs.unity3d.com/Manual/UICanvas.html">Unity-Canvas</a></li><li><a href="https://docs.unity3d.com/Manual/script-CanvasScaler.html">Unity-Canvas Scaler</a></li><li><a href="https://docs.unity3d.com/Manual/HOWTO-UIMultiResolution.html">Unity-Designing UI for Multiple Resolutions</a></li><li><a href="https://docs.unity3d.com/Manual/PlatformDependentCompilation.html">Unity-Platform dependent compilation</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
      <category>《土豆荣耀》</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《土豆荣耀》重构笔记（十九）使用单例模式实现游戏主逻辑管理器</title>
    <link href="/posts/733f40fd/"/>
    <url>/posts/733f40fd/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&amp;emsp;&amp;emsp;到目前为止，我们已经能在场景中控制角色进行<code>移动</code>、<code>攻击怪物</code>并<code>拾取道具</code>，但我们还没有做出一个完整的游戏，我们还需要加入<code>游戏的胜负条件</code>。</p><blockquote><p><code>游戏的胜负条件</code></p></blockquote><ol><li>胜利条件：每击杀一个怪物获得<code>100分</code>，当已获得的分数达到<code>预设的分数</code>时，游戏胜利</li><li>失败条件：当角色死亡时，游戏失败</li></ol><p>&amp;emsp;&amp;emsp;知道了<code>游戏胜负条件</code>之后，我们还需要加入<code>游戏主逻辑管理器</code>来管理整个游戏的<code>状态</code>。通常来说，一个游戏场景里面，只有唯一一个<code>游戏主逻辑管理器</code>。因此，我们可以使用<code>单例模式</code>来实现<code>游戏主逻辑管理器</code>。</p><hr><h2 id="什么是单例模式"><a href="#什么是单例模式" class="headerlink" title="什么是单例模式"></a>什么是单例模式</h2><p>&amp;emsp;&amp;emsp;<a href="https://en.wikipedia.org/wiki/Singleton_pattern">单例模式</a>是一种常用的<code>软件设计模式</code>。在应用这个模式时，单例对象的类必须保证<code>只有一个实例存在</code>，并提供一个访问这个<code>唯一实例</code>的<code>全局访问点</code>。</p><p>&amp;emsp;&amp;emsp;<code>单例模式</code>的实现思路是：一个类定义<code>一个静态的实例引用</code>和<code>一个获得该实例的方法（必须是静态方法）</code>，当我们调用<code>获取静态实例的方法</code>时，如果类持有的<code>静态实例引用不为空就返回这个引用</code>，如果类保持的<code>静态实例引用为空就创建该类的实例，并将新创建的实例引用赋予该类持有的静态实例引用</code>。同时我们还应该将该类的<code>构造函数定义为私有方法</code>，这样其他处的代码就无法通过调用该类的构造函数来实例化该类的对象，<code>只有通过该类提供的静态方法来得到该类的唯一实例</code>。</p><blockquote><p><code>单例模式</code>的两种构建方式：</p></blockquote><ol><li><code>懒汉方式(Lazy initialization)</code>：指单例类的单例实例在<code>第一次被使用时</code>构建。</li><li><code>饿汉方式(Eager initialization)</code>：指单例类的单例实例在<code>类装载时</code>先主动构建。</li></ol><p>&amp;emsp;&amp;emsp;由于Unity采用了<code>组件化编程</code>的方式，所以在Unity中，除了对象以外一切都是<code>组件(Component)</code>，所有定义了继承自<code>MonoBehaviour</code>的类的C#脚本都需要先绑定到<code>游戏对象(GameObject)</code>上，Unity才会<code>自动实例化该类</code>，并在游戏运行时调用<code>MonoBehaviour</code>的各个<code>事件函数</code>。此外，我们不可以使用<code>new</code>关键字对继承自<code>MonoBehaviour</code>的类进行实例化，只能使用<code>GetComponet&lt;&gt;</code>函数来获取该类的实例对象，这就决定了如果我们使用<code>饿汉方式(Eager initialization)</code>来实现<code>单例模式</code>，那么我们只能在<code>Awake</code>函数中<code>初始化单例对象</code>。</p><p>&amp;emsp;&amp;emsp;需要注意的是，根据Unity关于<a href="https://docs.unity3d.com/Manual/EventFunctions.html">Event Functions的说明文档</a>，Unity会按照<code>随机的顺序</code>执行所有继承自<code>MonoBehaviour</code>的类的<code>Awake</code>函数，因此如果我们使用<code>饿汉方式(Eager initialization)</code>来实现<code>单例模式</code>，那么我们需要保证<code>单例类</code>的<code>Awake</code>函数在其他继承自<code>MonoBehaviour</code>的类的<code>Awake</code>函数之前执行，否则将有可能<code>出现空引用的问题</code>。考虑到保证脚本之间的执行顺序工作量较大，<code>为了避免出现空引用的问题</code>，我们采用<code>懒汉方式(Lazy initialization)</code>来实现<code>单例模式</code>。</p><hr><h2 id="实现游戏主逻辑管理器框架"><a href="#实现游戏主逻辑管理器框架" class="headerlink" title="实现游戏主逻辑管理器框架"></a>实现游戏主逻辑管理器框架</h2><p>&amp;emsp;&amp;emsp;在了解了<code>单例模式</code>是什么，以及采用哪种方式实现<code>单例模式</code>之后，我们开始实现<code>游戏主逻辑管理器</code>。首先，我们在<code>Assets\Scripts</code>文件夹下创建一个名为<code>Manager</code>的文件夹，然后在<code>Assets\Scripts\Manager</code>文件夹下创建一个名为<code>GameStateManager</code>的C#脚本。接着，我们编辑<code>GameStateManager.cs</code>如下：</p><figure class="highlight csharp"><figcaption><span>GameStateManager.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-comment">// 游戏状态</span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">enum</span> GameState &#123;<br>    Init,<br>    Start,<br>    Running,<br>    End<br>&#125;<br><br>[<span class="hljs-meta">RequireComponent(typeof(AudioSource))</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">GameStateManager</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br>    <span class="hljs-comment">// 静态实例</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> GameStateManager m_Instance = <span class="hljs-literal">null</span>;<br>    <span class="hljs-comment">// 使用Property来访问静态实例</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> GameStateManager Instance &#123;<br>        <span class="hljs-keyword">get</span> &#123;<br>            <span class="hljs-keyword">if</span> (m_Instance == <span class="hljs-literal">null</span>) &#123;<br>                m_Instance = FindObjectOfType(<span class="hljs-keyword">typeof</span>(GameStateManager)) <span class="hljs-keyword">as</span> GameStateManager;<br>                <br>                <span class="hljs-comment">// 场景中没有添加了GameStateManager.cs脚本的GameObject，就自动创建一个</span><br>                <span class="hljs-keyword">if</span> (m_Instance == <span class="hljs-literal">null</span>) &#123;<br>                    GameObject obj = <span class="hljs-keyword">new</span> GameObject(<span class="hljs-string">&quot;GameStateManager&quot;</span>);<br>                    m_Instance = obj.AddComponent&lt;GameStateManager&gt;();<br>                &#125;<br>            &#125;<br>            <br>            <span class="hljs-comment">// 返回静态实例的引用</span><br>            <span class="hljs-keyword">return</span> m_Instance;<br>        &#125;<br>    &#125;<br><br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;游戏运行时的背景音乐&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> AudioClip BackgroundMusic;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;游戏胜利时的音效&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> AudioClip GameWinClip;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;游戏失败时的音效&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> AudioClip GameLoseClip;<br><br>    <span class="hljs-comment">// 游戏处于哪个状态</span><br>    <span class="hljs-keyword">private</span> GameState m_CurrentState;<br>    <span class="hljs-comment">// 游戏是否处于暂停状态</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">bool</span> m_IsPaused;<br>    <span class="hljs-comment">// 游戏结果，true为胜利，false为失败</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">bool</span> m_GameResult;<br><br>    <span class="hljs-keyword">private</span> AudioSource m_AudioSource;<br><br>    <span class="hljs-meta">#<span class="hljs-keyword">region</span> MonoBehaviour的事件函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Awake</span>()</span> &#123;<br>        <span class="hljs-comment">// 初始化组件</span><br>        m_AudioSource = GetComponent&lt;AudioSource&gt;();<br>        m_AudioSource.playOnAwake = <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span> &#123;<br>        <span class="hljs-comment">// 初始化成员变量</span><br>        m_IsPaused = <span class="hljs-literal">false</span>;<br>        m_CurrentState = GameState.Init;<br>        <br>        <span class="hljs-comment">// 开始游戏主循环</span><br>        StartCoroutine(GameMainLoop());<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">region</span> 自定义游戏状态函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> IEnumerator <span class="hljs-title">GameMainLoop</span>()</span> &#123;<br>        GameInit();<br><br>        <span class="hljs-keyword">while</span>(m_CurrentState == GameState.Init) &#123;<br>            <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        GameStart();<br><br>        <span class="hljs-keyword">while</span>(m_CurrentState == GameState.Running) &#123;<br>            GameRunning();<br><br>            <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        GameEnd();<br>    &#125;<br><br>    <span class="hljs-comment">// 游戏初始化</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">GameInit</span>()</span> &#123;<br>        <span class="hljs-comment">// 执行一些游戏预操作，例如初始化其他Manager、播放过场动画和进行倒计时等</span><br>        Debug.Log(<span class="hljs-string">&quot;Game Init&quot;</span>);<br><br>        <span class="hljs-comment">// 进入游戏开始状态</span><br>        m_CurrentState = GameState.Start;<br>    &#125;<br><br>    <span class="hljs-comment">// 游戏开始</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">GameStart</span>()</span> &#123;<br>        Debug.Log(<span class="hljs-string">&quot;Game Start&quot;</span>);<br><br>        <span class="hljs-comment">// 开始播放背景音乐</span><br>        <span class="hljs-keyword">if</span>(BackgroundMusic != <span class="hljs-literal">null</span>) &#123;<br>            m_AudioSource.clip = BackgroundMusic;<br>            m_AudioSource.loop = <span class="hljs-literal">true</span>;<br>            m_AudioSource.Play();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            Debug.LogError(<span class="hljs-string">&quot;请设置BackgroundMusic&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 进入游戏运行状态</span><br>        m_CurrentState = GameState.Running;<br>    &#125;<br><br>    <span class="hljs-comment">// 暂停游戏</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">GamePause</span>()</span> &#123;<br>        Debug.Log(<span class="hljs-string">&quot;Game Pause&quot;</span>);<br><br>        <span class="hljs-comment">// 暂停背景音乐的播放</span><br>        m_AudioSource.Pause();<br>        <span class="hljs-comment">// 暂停游戏</span><br>        Time.timeScale = <span class="hljs-number">0f</span>;<br><br>        m_IsPaused = <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 继续游戏</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">GameContinue</span>()</span> &#123;<br>        Debug.Log(<span class="hljs-string">&quot;Game Continue&quot;</span>);<br><br>        <span class="hljs-comment">// 恢复背景音乐的播放</span><br>        Time.timeScale = <span class="hljs-number">1f</span>;<br>        <span class="hljs-comment">// 恢复游戏</span><br>        m_AudioSource.UnPause();<br><br>        m_IsPaused = <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 游戏运行</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">GameRunning</span>()</span> &#123;<br>        Debug.Log(<span class="hljs-string">&quot;Game Running&quot;</span>);<br><br>        <span class="hljs-comment">// 暂停或者恢复游戏</span><br>        <span class="hljs-keyword">if</span>(Input.GetKeyDown(KeyCode.P)) &#123;<br>            <span class="hljs-keyword">if</span>(m_IsPaused) &#123;<br>                GameContinue();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                GamePause();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(Input.GetKeyDown(KeyCode.E)) &#123;<br>            SetGameResult(<span class="hljs-literal">false</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(Input.GetKeyDown(KeyCode.Q)) &#123;<br>            SetGameResult(<span class="hljs-literal">true</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 游戏结束</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">GameEnd</span>()</span> &#123;<br>        Debug.Log(<span class="hljs-string">&quot;Game End&quot;</span>);<br><br>        <span class="hljs-comment">// 停止播放背景音乐</span><br>        m_AudioSource.Stop();<br>        m_AudioSource.loop = <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-built_in">float</span> delay = <span class="hljs-number">0f</span>;<br><br>        <span class="hljs-keyword">if</span>(m_GameResult) &#123;<br>            <span class="hljs-keyword">if</span>(GameWinClip != <span class="hljs-literal">null</span>) &#123;<br>                AudioSource.PlayClipAtPoint(GameWinClip, <span class="hljs-keyword">this</span>.transform.position);<br>                delay = GameWinClip.length;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                Debug.LogError(<span class="hljs-string">&quot;请设置GameWinClip&quot;</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span>(GameLoseClip != <span class="hljs-literal">null</span>) &#123;<br>                AudioSource.PlayClipAtPoint(GameLoseClip, <span class="hljs-keyword">this</span>.transform.position);<br>                delay = GameLoseClip.length;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                Debug.LogError(<span class="hljs-string">&quot;请设置GameLoseClip&quot;</span>);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 播放完音效之后，删除场景中的所有Generator</span><br>        Destroy(Generator, delay);<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">region</span>  外部调用函数</span><br>    <span class="hljs-comment">// 设置游戏结果</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SetGameResult</span>(<span class="hljs-params"><span class="hljs-built_in">bool</span> result</span>)</span> &#123;<br>        m_GameResult = result;<br>        m_CurrentState = GameState.End;<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>代码说明：</p></blockquote><ol><li>这里，我们自定义了<code>GameInit</code>、<code>GameStart</code>、<code>GamePause</code>、<code>GameContinue</code>、<code>GameRunning</code>和<code>GameEnd</code>这几个游戏状态函数，用于执行对应状态的代码。</li><li>其次，我们还使用了协程来实现<code>GameMainLoop</code>这个函数，用于切换和管理游戏状态</li><li>最后，我们使用键盘上的<code>P</code>来<code>暂停和恢复游戏</code>，使用<code>Q</code>来切换至<code>游戏胜利</code>，使用<code>E</code>来切换至<code>游戏失败</code></li></ol><p>&amp;emsp;&amp;emsp;编辑完毕之后，我们在场景中新建一个名为<code>GameStateManager</code>的<code>Empty GameObject</code>，然后为其添加<code>GameStateManager.cs</code>，可以看到Unity自动帮我们添加了<code>AudioSource</code>组件。</p><blockquote><p><code>GameStateManager</code>物体上各个组件的属性设置：</p></blockquote><ol><li><code>Transform</code>：<ul><li><code>Position</code>：(0, 0, 0)</li></ul></li><li><code>GameStateManager.cs</code><ul><li><code>Background Music</code>: <code>Assets\Audio\Music</code>文件夹下的<code>MainTheme</code></li><li><code>GameWinClip</code>: <code>Assets\Audio\Music</code>文件夹下的<code>GameWin</code></li><li><code>GameLoseClip</code>: <code>Assets\Audio\Music</code>文件夹下的<code>GameLose</code></li></ul></li><li><code>AudioSource</code>:<ul><li><code>Play On Awake</code>: false</li><li><code>Vloume</code>: 0.05</li></ul></li></ol><p><img src="https://github.com/AsanCai/BlogImage/raw/master/PotatoGloryTutorial/Essay19/Image1.png" alt="GameStateManager的组件"></p><p>&amp;emsp;&amp;emsp;为<code>GameStateManager</code>添加完组件之后，我们可以听到游戏场景中出现了背景音乐，且<code>Console</code>窗口输出了对应的游戏状态。此外，当我们按键盘上的<code>P</code>键时，游戏可以<code>正常暂停和恢复</code>；当我们按<code>Q</code>或者<code>E</code>时，会<code>停止播放背景音乐</code>，开始播放<code>游戏胜利</code>或者<code>游戏失败</code>的音效，并在播放完之后删除场景中的<code>Generator</code>物体，不再产生新的东西。</p><p>&amp;emsp;&amp;emsp;但同时我们发现导弹击中物体时的爆炸音效音量过大，因此我们还需要将<code>Assets\Prefabs\Weapons</code>文件夹下的<code>MissileExplosion</code>上<code>AudioSource</code>组件的<code>Volume</code>设置为<code>0.2</code>。</p><p><img src="https://github.com/AsanCai/BlogImage/raw/master/PotatoGloryTutorial/Essay19/Image2.png" alt="MissileExplosion的组件"></p><hr><h2 id="加入游戏胜负条件"><a href="#加入游戏胜负条件" class="headerlink" title="加入游戏胜负条件"></a>加入游戏胜负条件</h2><p>&amp;emsp;&amp;emsp;有了<code>游戏主逻辑管理器框架</code>之后，我们开始加入游戏胜负条件。如果我们直接在<code>GameStateManager</code>加入<code>分数管理的代码</code>，那么势必会出现<code>GameStateManager</code>里的<code>代码多且杂</code>的问题。我们应该让其他<code>Manager</code>来执行<code>分数管理</code>的工作，然后让管理整个游戏状态的<code>GameStateManager</code>来管理其他的<code>Manager</code>。</p><p>&amp;emsp;&amp;emsp;清楚了这一设计思路之后，我们先在<code>Assets\Scripts\Manager</code>文件夹下创建一个名为<code>ScoreManager</code>的C#脚本，然后编辑<code>ScoreManager.cs</code>如下：</p><figure class="highlight csharp"><figcaption><span>ScoreManager.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br>[<span class="hljs-meta">Serializable</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ScoreManager</span> &#123;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;游戏胜利的目标分数&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> TargetScore = <span class="hljs-number">5000</span>;<br><br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;保存嘲讽音效&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> AudioClip[] TauntClips;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;得分之后播放嘲讽音效的概率&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> TauntProbaility = <span class="hljs-number">50f</span>;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;嘲讽的间隔&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> TauntDelay = <span class="hljs-number">1f</span>;<br><br>    <span class="hljs-comment">// 当前的分数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> m_CurrentScore;<br>    <span class="hljs-comment">// 上一次播放的嘲讽音效的下标</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> m_TauntIndex;<br>    <span class="hljs-comment">// 上一次播放嘲讽音效的时间</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">float</span> m_LastTauntTime;<br>    <span class="hljs-comment">// 当前管理器是否停止工作</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">bool</span> m_Stop;<br><br>    <span class="hljs-keyword">private</span> Transform m_Player;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Init</span>(<span class="hljs-params">Transform player</span>)</span> &#123;<br>        m_CurrentScore = <span class="hljs-number">0</span>;<br>        m_TauntIndex = <span class="hljs-number">0</span>;<br>        m_LastTauntTime = Time.time;<br>        m_Stop = <span class="hljs-literal">false</span>;<br><br>        m_Player = player;<br>    &#125;<br><br>    <span class="hljs-comment">// 管理器停止工作</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Stop</span>()</span> &#123;<br>        m_Stop = <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">AddScore</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> score</span>)</span> &#123;<br>        <span class="hljs-comment">// 管理器停止工作，不执行任何操作</span><br>        <span class="hljs-keyword">if</span>(m_Stop) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 增加分数</span><br>        m_CurrentScore += score;<br><br>        <span class="hljs-comment">// 达到目标分数，游戏胜利</span><br>        <span class="hljs-keyword">if</span>(m_CurrentScore &gt;= TargetScore) &#123;<br>            GameStateManager.Instance.SetGameResult(<span class="hljs-literal">true</span>);<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span>(m_LastTauntTime &lt;= Time.time + TauntDelay) &#123;<br>            <span class="hljs-built_in">float</span> tauntChance = UnityEngine.Random.Range(<span class="hljs-number">0f</span>, <span class="hljs-number">100f</span>);<br><br>            <span class="hljs-keyword">if</span>(tauntChance &gt; TauntProbaility) &#123;<br>                <span class="hljs-comment">// 播放嘲讽音效</span><br>                m_TauntIndex = TauntRandom();<br>                AudioSource.PlayClipAtPoint(TauntClips[m_TauntIndex], m_Player.position);<br>            &#125;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-comment">//确保相邻两次嘲讽音效不相同</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> <span class="hljs-title">TauntRandom</span>()</span> &#123;<br>        <span class="hljs-built_in">int</span> i = UnityEngine.Random.Range(<span class="hljs-number">0</span>, TauntClips.Length);<br><br>        <span class="hljs-keyword">if</span> (i == m_TauntIndex)<br>            <span class="hljs-keyword">return</span> TauntRandom();<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> i;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>代码说明：</p></blockquote><ol><li>因为我们使用<code>GameStateManager</code>来管理<code>ScoreManager</code>，所以<code>ScoreManager</code>不需要继承<code>MonoBehaviour</code></li><li>因为<code>ScoreManager</code>没有继承<code>MonoBehaviour</code>，所以我们需要为<code>ScoreManager</code>添加Unity提供的<code>Serializable</code>这一<code>Attribute</code>，通过<a href="https://docs.unity3d.com/Manual/script-Serialization-Custom.html">自定义序列化的方式</a>使<code>ScoreManager</code>能被Unity序列化</li><li>因为<code>ScoreManager</code>没有继承<code>MonoBehaviour</code>，所以我们不能使用<code>协程</code>，我们需要使用<code>Time.time</code>来实现<code>延时执行某段代码</code>的功能</li></ol><p>&amp;emsp;&amp;emsp;编辑完<code>ScoreManager.cs</code>之后，我们修改<code>GameStateManager.cs</code>，删除用于测试的代码，并加入管理<code>ScoreManager</code>的代码：</p><figure class="highlight csharp"><figcaption><span>GameStateManager.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-comment">// 游戏状态</span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">enum</span> GameState &#123;<br>    Init,<br>    Start,<br>    Running,<br>    End<br>&#125;<br><br>[<span class="hljs-meta">RequireComponent(typeof(AudioSource))</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">GameStateManager</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br>    <span class="hljs-comment">// 静态实例</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> GameStateManager m_Instance = <span class="hljs-literal">null</span>;<br>    <span class="hljs-comment">// 使用Property来访问静态实例</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> GameStateManager Instance &#123;<br>        <span class="hljs-keyword">get</span> &#123;<br>            <span class="hljs-keyword">if</span> (m_Instance == <span class="hljs-literal">null</span>) &#123;<br>                m_Instance = FindObjectOfType(<span class="hljs-keyword">typeof</span>(GameStateManager)) <span class="hljs-keyword">as</span> GameStateManager;<br>                <br>                <span class="hljs-comment">// 场景中没有添加了GameStateManager.cs脚本的GameObject，就自动创建一个</span><br>                <span class="hljs-keyword">if</span> (m_Instance == <span class="hljs-literal">null</span>) &#123;<br>                    GameObject obj = <span class="hljs-keyword">new</span> GameObject(<span class="hljs-string">&quot;GameStateManager&quot;</span>);<br>                    m_Instance = obj.AddComponent&lt;GameStateManager&gt;();<br>                &#125;<br>            &#125;<br>            <br>            <span class="hljs-comment">// 返回静态实例的引用</span><br>            <span class="hljs-keyword">return</span> m_Instance;<br>        &#125;<br>    &#125;<br><br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;游戏运行时的背景音乐&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> AudioClip BackgroundMusic;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;游戏胜利时的音效&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> AudioClip GameWinClip;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;游戏失败时的音效&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> AudioClip GameLoseClip;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;ScoreManager的实例&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> ScoreManager ScoreManagerInstance = <span class="hljs-keyword">new</span> ScoreManager();<br><br>    <span class="hljs-comment">// 游戏处于哪个状态</span><br>    <span class="hljs-keyword">private</span> GameState m_CurrentState;<br>    <span class="hljs-comment">// 游戏是否处于暂停状态</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">bool</span> m_IsPaused;<br>    <span class="hljs-comment">// 游戏结果，true为胜利，false为失败</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">bool</span> m_GameResult;<br><br>    <span class="hljs-keyword">private</span> AudioSource m_AudioSource;<br><br><span class="hljs-meta">#<span class="hljs-keyword">region</span> MonoBehaviour的事件函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Awake</span>()</span> &#123;<br>        <span class="hljs-comment">// 初始化组件</span><br>        m_AudioSource = GetComponent&lt;AudioSource&gt;();<br>        m_AudioSource.playOnAwake = <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span> &#123;<br>        <span class="hljs-comment">// 初始化成员变量</span><br>        m_IsPaused = <span class="hljs-literal">false</span>;<br>        m_CurrentState = GameState.Init;<br>        <br>        <span class="hljs-comment">// 开始游戏主循环</span><br>        StartCoroutine(GameMainLoop());<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">region</span> 自定义游戏状态函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> IEnumerator <span class="hljs-title">GameMainLoop</span>()</span> &#123;<br>        GameInit();<br><br>        <span class="hljs-keyword">while</span>(m_CurrentState == GameState.Init) &#123;<br>            <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        GameStart();<br><br>        <span class="hljs-keyword">while</span>(m_CurrentState == GameState.Running) &#123;<br>            GameRunning();<br><br>            <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        GameEnd();<br>    &#125;<br><br>    <span class="hljs-comment">// 游戏初始化</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">GameInit</span>()</span> &#123;<br>        <span class="hljs-comment">// 执行一些游戏预操作，例如初始化其他Manager、播放过场动画和进行倒计时等</span><br>        ScoreManagerInstance.Init();<br><br>        <span class="hljs-comment">// 进入游戏开始状态</span><br>        m_CurrentState = GameState.Start;<br>    &#125;<br><br>    <span class="hljs-comment">// 游戏开始</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">GameStart</span>()</span> &#123;<br>        <span class="hljs-comment">// 开始播放背景音乐</span><br>        <span class="hljs-keyword">if</span>(BackgroundMusic != <span class="hljs-literal">null</span>) &#123;<br>            m_AudioSource.clip = BackgroundMusic;<br>            m_AudioSource.loop = <span class="hljs-literal">true</span>;<br>            m_AudioSource.Play();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            Debug.LogError(<span class="hljs-string">&quot;请设置BackgroundMusic&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 进入游戏运行状态</span><br>        m_CurrentState = GameState.Running;<br>    &#125;<br><br>    <span class="hljs-comment">// 暂停游戏</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">GamePause</span>()</span> &#123;<br>        <span class="hljs-comment">// 暂停背景音乐的播放</span><br>        m_AudioSource.Pause();<br>        <span class="hljs-comment">// 暂停游戏</span><br>        Time.timeScale = <span class="hljs-number">0f</span>;<br><br>        m_IsPaused = <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 继续游戏</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">GameContinue</span>()</span> &#123;<br>        <span class="hljs-comment">// 恢复背景音乐的播放</span><br>        Time.timeScale = <span class="hljs-number">1f</span>;<br>        <span class="hljs-comment">// 恢复游戏</span><br>        m_AudioSource.UnPause();<br><br>        m_IsPaused = <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 游戏运行</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">GameRunning</span>()</span> &#123;<br>        <span class="hljs-comment">// 暂停或者恢复游戏</span><br>        <span class="hljs-keyword">if</span>(Input.GetKeyDown(KeyCode.P)) &#123;<br>            <span class="hljs-keyword">if</span>(m_IsPaused) &#123;<br>                GameContinue();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                GamePause();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 游戏结束</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">GameEnd</span>()</span> &#123;<br>        <span class="hljs-comment">// 停止播放背景音乐</span><br>        m_AudioSource.Stop();<br>        m_AudioSource.loop = <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-built_in">float</span> delay = <span class="hljs-number">0f</span>;<br><br>        <span class="hljs-keyword">if</span>(m_GameResult) &#123;<br>            <span class="hljs-keyword">if</span>(GameWinClip != <span class="hljs-literal">null</span>) &#123;<br>                AudioSource.PlayClipAtPoint(GameWinClip, <span class="hljs-keyword">this</span>.transform.position);<br>                delay = GameWinClip.length;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                Debug.LogError(<span class="hljs-string">&quot;请设置GameWinClip&quot;</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span>(GameLoseClip != <span class="hljs-literal">null</span>) &#123;<br>                AudioSource.PlayClipAtPoint(GameLoseClip, <span class="hljs-keyword">this</span>.transform.position);<br>                delay = GameLoseClip.length;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                Debug.LogError(<span class="hljs-string">&quot;请设置GameLoseClip&quot;</span>);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 播放完音效之后，删除场景中的所有Generator</span><br>        Destroy(Generator, delay);<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">region</span>  外部调用函数</span><br>    <span class="hljs-comment">// 设置游戏结果</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SetGameResult</span>(<span class="hljs-params"><span class="hljs-built_in">bool</span> result</span>)</span> &#123;<br>        m_GameResult = result;<br>        m_CurrentState = GameState.End;<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;接着，我们在<code>Hierarchy</code>窗口中选中<code>GameStateManager</code>物体，可以看到<code>Inspector</code>窗口多出了一个名为<code>Score Manager Instance</code>折叠框，且在<code>Score Manager Instance</code>折叠框下出现了<code>ScoreManager</code>类里定义的公共字段。</p><blockquote><p><code>ScoreManager</code>类定义的公共字段设置：</p></blockquote><ul><li><code>Target Score</code>: 5000</li><li><code>Taunt Clips</code>: <code>Assets\Audio\Player\Taunts</code>文件夹下的9个音频</li><li><code>Taunt Probaility</code>: 50</li><li><code>Taunt Delay</code>: 1</li></ul><p><img src="https://github.com/AsanCai/BlogImage/raw/master/PotatoGloryTutorial/Essay19/Image3.png" alt="GameStateManager脚本的属性设置"></p><p>&amp;emsp;&amp;emsp;设置好<code>ScoreManager</code>类定义的公共字段之后，我们还需要在<code>Remover.cs</code>的<code>OnTriggerEnter2D</code>加入<code>设置游戏结果</code>的代码：</p><figure class="highlight csharp"><figcaption><span>Remover.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br>[<span class="hljs-meta">RequireComponent(typeof(BoxCollider2D))</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Remover</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br>    ...<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnTriggerEnter2D</span>(<span class="hljs-params">Collider2D collision</span>)</span> &#123;<br>        <span class="hljs-comment">// 角色掉进河里，游戏失败</span><br>        <span class="hljs-keyword">if</span>(collision.CompareTag(<span class="hljs-string">&quot;Player&quot;</span>)) &#123;<br>            GameStateManager.Instance.SetGameResult(<span class="hljs-literal">false</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 实例化水花对象，水花对象会自动播放声音和动画</span><br>        Instantiate(SplashPrefab, collision.transform.position, transform.rotation);<br>        <span class="hljs-comment">// 销毁掉下去的物体</span><br>        Destroy(collision.gameObject);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;最后，我们还需要修改一下<code>CameraFollow.cs</code>的<code>LateUpdate</code>函数：</p><figure class="highlight csharp"><figcaption><span>CameraFollow.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">CameraFollow</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br>    ...<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">LateUpdate</span>()</span> &#123;<br>        <span class="hljs-comment">// 如果角色被销毁，不再进行跟随</span><br>        <span class="hljs-keyword">if</span>(m_Player != <span class="hljs-literal">null</span>) &#123;<br>            TrackPlayer();<br>        &#125;<br>    &#125;<br><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;修改完成之后，运行游戏，可以看到当我们打死怪物时，<code>Console</code>窗口会输出我们当前<code>不断增加的分数</code>，且<code>一定概率会播放嘲讽音效</code>。此外，当角色死亡或者直接掉进河里时，<code>背景音乐停止播放并播放游戏失败的音效</code>。</p><hr><h2 id="添加击杀怪物得分特效"><a href="#添加击杀怪物得分特效" class="headerlink" title="添加击杀怪物得分特效"></a>添加击杀怪物得分特效</h2><p>&amp;emsp;&amp;emsp;因为击杀怪物可以得分，所以我们需要添加<code>击杀怪物得分的特效</code>。</p><blockquote><p><code>得分特效</code>的制作步骤：</p></blockquote><ol><li>在场景中新建一个名为<code>Score</code>的<code>Empty GameObject</code>，然后将<code>Assets\Sprites\UI</code>下的<code>numeric-1</code>和<code>numeric-0</code>图片拖拽至<code>Score</code>物体下成为<code>Score</code>物体的子物体</li><li>复制<code>Score</code>物体下的<code>numeric-0</code>得到<code>numeric-0 (1)</code>物体</li><li>设置<code>numeric-1</code>的<code>Position</code>为<code>(-0.4, 0, 0)</code>，<code>Sprite Renderer</code>组件的<code>Sorting Layer</code>属性为<code>Character</code>、<code>Order In Layer</code>属性为<code>10</code></li><li>设置<code>numeric-0</code>的<code>Position</code>为<code>(0, 0, 0)</code>，<code>Sprite Renderer</code>组件的<code>Sorting Layer</code>属性为<code>Character</code>、<code>Order In Layer</code>属性为<code>10</code></li><li>设置<code>numeric-0 (1)</code>的<code>Position</code>为<code>(0.5, 0, 0)</code>，<code>Sprite Renderer</code>组件的<code>Sorting Layer</code>属性为<code>Character</code>、<code>Order In Layer</code>属性为<code>10</code></li><li>打开<code>Animation</code>窗口，选中Hierarchy窗口中的<code>Score</code>物体，然后点击<code>Animation</code>窗口中的<code>Create</code>按钮创建一个名为<code>Score.anim</code>的动画文件，并将其保存在<code>Assets\Animation\Enemy</code>文件夹下，最后将<code>Score.controller</code>文件移至<code>Assets\Animator\Enemy</code>文件夹下</li><li>为<code>Score</code>物体添加<code>Destrpyer.cs</code>脚本</li><li>点击<code>Animation</code>窗口的<code>红点按钮</code>，开始为<code>Score.anim</code>添加关键帧，添加的关键帧信息如下：<blockquote><blockquote><p><code>Score.anim</code>的关键帧：</p></blockquote></blockquote><ol><li><code>第一帧</code>：<ul><li><code>frame</code>: 0</li><li><code>numeric-1：Position</code>: (-0.4, 0, 0)</li><li><code>numeric-0：Position</code>: (0, 0, 0)</li><li><code>numeric-0 (1)：Position</code>: (0.5, 0, 0)</li></ul></li><li><code>第二帧</code>：<ul><li><code>frame</code>: 5</li><li><code>numeric-1：Position</code>: (-0.4, 0.25, 0)</li></ul></li><li><code>第三帧</code>：<ul><li><code>frame</code>: 10</li><li><code>numeric-0：Position</code>: (0, 0.31, 0)</li></ul></li><li><code>第四帧</code>：<ul><li><code>frame</code>: 30</li><li><code>numeric-1：Position</code>: (-0.4, 0.78, 0)</li><li><code>numeric-0：Position</code>: (0, 0.78, 0)</li><li><code>numeric-0 (1)：Position</code>: (0.5, 0.78, 0)</li></ul></li><li><code>第五帧</code>：<ul><li><code>frame</code>: 40</li><li><code>numeric-1：Position</code>: (-0.4, 1.1, 0)</li><li><code>numeric-0：Position</code>: (0, 1.1, 0)</li><li><code>numeric-0 (1)：Position</code>: (0.5, 1.1, 0)</li></ul></li><li><code>第六帧</code>：<ul><li><code>frame</code>: 60</li><li><code>numeric-1：Position</code>: (-0.4, 1.25, 0)</li><li><code>numeric-0：Position</code>: (0, 1.25, 0)</li><li><code>numeric-0 (1)：Position</code>: (0.5, 1.25, 0)</li></ul></li></ol></li><li>在<code>Score.anim</code>的最后一帧处添加一个<code>Animation Event</code>，选择调用的函数为<code>DestroyGameObject</code></li><li>将场景中的<code>Score</code>物体拖拽至<code>Assets\Prefabs\Character</code>文件夹将其制作为Prefab，然后删除场景中的<code>Score</code>物体</li></ol><p>&amp;emsp;&amp;emsp;至此，我们的<code>得分特效</code>就制作好了。接下来，我们改写<code>Enemy.cs</code>，在怪物死亡时生成得分特效：</p><figure class="highlight csharp"><figcaption><span>Enemy.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br>[<span class="hljs-meta">RequireComponent(typeof(Wander))</span>]<br>[<span class="hljs-meta">RequireComponent(typeof(Rigidbody2D))</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Enemy</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;角色受伤时减少的血量&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> DamageAmount = <span class="hljs-number">10f</span>;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;角色被怪物伤害时受到的击退力大小&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> HurtForce = <span class="hljs-number">500f</span>;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;障碍物检测点&quot;</span>)</span>]<br>    [<span class="hljs-meta">SerializeField</span>]<br>    <span class="hljs-keyword">private</span> Transform FrontCheck;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;怪物的血量&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> MaxHP = <span class="hljs-number">10f</span>;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;怪物受伤时用来展示的图片&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> Sprite DamagedSprite;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;怪物死亡时用来展示的图片&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> Sprite DeadSprite;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;怪物死亡时用来展示DeadSprite&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> SpriteRenderer BodySpriteRenderer;<br><br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;怪物死亡时的音效&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> AudioClip[] DeathClips;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;得分特效&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> GameObject ScorePrefab;<br><br>    <span class="hljs-keyword">private</span> Wander m_Wander;<br>    <span class="hljs-keyword">private</span> Rigidbody2D m_Rigidbody2D;<br><br>    <span class="hljs-keyword">private</span> LayerMask m_LayerMask;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">float</span> m_CurrentHP;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">bool</span> m_Hurt;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">bool</span> m_Dead;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Awake</span>()</span> &#123;<br>        <span class="hljs-comment">// 获取引用</span><br>        m_Wander = GetComponent&lt;Wander&gt;();<br>        m_Rigidbody2D = GetComponent&lt;Rigidbody2D&gt;();<br>    &#125;<br>        <br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span> &#123;<br>        <span class="hljs-comment">// 初始化变量</span><br>        m_LayerMask = LayerMask.GetMask(<span class="hljs-string">&quot;Obstacle&quot;</span>);<br>        m_CurrentHP = MaxHP;<br>        m_Hurt = <span class="hljs-literal">false</span>;<br>        m_Dead = <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Update</span> ()</span> &#123;<br>        <span class="hljs-comment">// 死亡之后不执行任何操作</span><br>        <span class="hljs-keyword">if</span>(m_Dead) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        Collider2D[] frontHits = Physics2D.OverlapPointAll(FrontCheck.position, m_LayerMask);<br><br>        <span class="hljs-keyword">if</span>(frontHits.Length &gt; <span class="hljs-number">0</span>) &#123;<br>            m_Wander.Flip();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCollisionEnter2D</span>(<span class="hljs-params">Collision2D collision</span>)</span> &#123;<br>        <span class="hljs-comment">// 对角色造成伤害</span><br>        <span class="hljs-keyword">if</span>(collision.gameObject.CompareTag(<span class="hljs-string">&quot;Player&quot;</span>)) &#123;<br>            collision.gameObject.GetComponent&lt;PlayerHealth&gt;().TakeDamage(<span class="hljs-keyword">this</span>.transform, HurtForce, DamageAmount);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 受伤函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">TakeDamage</span>(<span class="hljs-params">Transform weapon, <span class="hljs-built_in">float</span> hurtForce, <span class="hljs-built_in">float</span> damage</span>)</span> &#123;<br>        <span class="hljs-comment">// 减少当前的HP</span><br>        m_CurrentHP -= damage;<br><br>        <span class="hljs-comment">// 制造击退效果</span><br>        Vector3 hurtVector = transform.position - weapon.position;<br>        m_Rigidbody2D.AddForce(hurtVector.normalized * hurtForce);<br><br>        <span class="hljs-comment">// 判断当前是否第一次受伤</span><br>        <span class="hljs-keyword">if</span>(!m_Hurt) &#123;<br>            m_Hurt = <span class="hljs-literal">true</span>;<br><br>            <span class="hljs-keyword">if</span>(DamagedSprite != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// 禁用原有的Sprite</span><br>                SpriteRenderer[] children = GetComponentsInChildren&lt;SpriteRenderer&gt;();<br>                <span class="hljs-keyword">foreach</span>(SpriteRenderer child <span class="hljs-keyword">in</span> children) &#123;<br>                    child.enabled = <span class="hljs-literal">false</span>;<br>                &#125;<br><br>                <span class="hljs-comment">// 显示怪物受伤图片</span><br>                <span class="hljs-keyword">if</span>(BodySpriteRenderer != <span class="hljs-literal">null</span>) &#123;<br>                    BodySpriteRenderer.enabled = <span class="hljs-literal">true</span>;<br>                    BodySpriteRenderer.sprite = DamagedSprite;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    Debug.LogError(<span class="hljs-string">&quot;请设置BodySpriteRenderer&quot;</span>);<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                Debug.LogWarning(<span class="hljs-string">&quot;请设置DamagedSprite&quot;</span>);<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 判断当前的是否死亡</span><br>        <span class="hljs-keyword">if</span>(m_CurrentHP &lt;= <span class="hljs-number">0</span> &amp;&amp; !m_Dead) &#123;<br>            m_Dead = <span class="hljs-literal">true</span>;<br>            Death();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Death</span>()</span> &#123;<br>        <span class="hljs-comment">// 禁用Wander.cs</span><br>        m_Wander.enabled = <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">if</span>(DeadSprite != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 禁用原有的Sprite</span><br>            SpriteRenderer[] children = GetComponentsInChildren&lt;SpriteRenderer&gt;();<br>            <span class="hljs-keyword">foreach</span>(SpriteRenderer child <span class="hljs-keyword">in</span> children) &#123;<br>                child.enabled = <span class="hljs-literal">false</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// 显示怪物死亡图片</span><br>            <span class="hljs-keyword">if</span>(BodySpriteRenderer != <span class="hljs-literal">null</span>) &#123;<br>                BodySpriteRenderer.enabled = <span class="hljs-literal">true</span>;<br>                BodySpriteRenderer.sprite = DeadSprite;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                Debug.LogError(<span class="hljs-string">&quot;请设置BodySpriteRenderer&quot;</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            Debug.LogWarning(<span class="hljs-string">&quot;请设置DeadSprite&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 将所有的Collider2D都设置为Trigger，避免和其他物体产生物理碰撞</span><br>        Collider2D[] cols = GetComponents&lt;Collider2D&gt;();<br>        <span class="hljs-keyword">foreach</span>(Collider2D c <span class="hljs-keyword">in</span> cols) &#123;<br>            c.isTrigger = <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 随机播放死亡的音效</span><br>        <span class="hljs-keyword">if</span>(DeathClips != <span class="hljs-literal">null</span> &amp;&amp; DeathClips.Length &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">int</span> i = Random.Range(<span class="hljs-number">0</span>, DeathClips.Length);<br>            AudioSource.PlayClipAtPoint(DeathClips[i], transform.position);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            Debug.LogWarning(<span class="hljs-string">&quot;请设置DeathClips&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 生成得分特效</span><br>        <span class="hljs-keyword">if</span>(ScorePrefab != <span class="hljs-literal">null</span>) &#123;<br>            Vector3 scorePos = <span class="hljs-keyword">this</span>.transform.position + Vector3.up * <span class="hljs-number">1.5f</span>;<br>            Instantiate(ScorePrefab, scorePos, Quaternion.identity);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            Debug.LogError(<span class="hljs-string">&quot;请设置ScorePrefab&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 增加分数</span><br>        GameStateManager.Instance.ScoreManagerInstance.AddScore(<span class="hljs-number">100</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;最后，我们分别选中<code>Assets\Prefabs\Character</code>文件夹下的<code>AlienShip</code>和<code>AlienSlug</code>这两个Prefab，将其<code>Enemy.cs</code>上的<code>Score Prefab</code>字段都设置为<code>Assets\Prefabs\Character</code>文件夹下的<code>Score</code>物体对应的Prefab。运行游戏，我们可以看到击杀怪物时，怪物上方会出现得分特效。</p><hr><h2 id="后言"><a href="#后言" class="headerlink" title="后言"></a>后言</h2><p>&amp;emsp;&amp;emsp;至此，我们就已经完成了<code>使用单例模式实现游戏游戏主逻辑管理器</code>的所有功能。最后，本篇文章所做的修改，可以在<a href="https://github.com/AsanCai/PotatoGloryTutorial">PotatoGloryTutorial</a>这个仓库的<code>essay17</code>分支下看到，读者可以clone这个仓库到本地进行查看。</p><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://en.wikipedia.org/wiki/Singleton_pattern">单例模式</a></li><li><a href="https://docs.unity3d.com/Manual/EventFunctions.html">Unity-Initialization Events</a></li><li><a href="https://docs.unity3d.com/Manual/script-Serialization-Custom.html">Unity-Custom serialization</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
      <category>《土豆荣耀》</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《土豆荣耀》重构笔记（十八）使用自定义Inspector窗口拓展Generator</title>
    <link href="/posts/5a4a3ccc/"/>
    <url>/posts/5a4a3ccc/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&amp;emsp;&amp;emsp;到目前为止，我们已经实现了使用<code>Generator</code>来生成<a href="https://asancai.github.io/tutorial/potato-glory/PotatoGloryTutorial-14/">怪物</a>、<a href="https://asancai.github.io/tutorial/potato-glory/PotatoGloryTutorial-16/">不可交互物体</a>和<a href="https://asancai.github.io/tutorial/potato-glory/PotatoGloryTutorial-17/">可拾取道具</a>的功能。但我们发现，现有的<code>Generator</code>只能做到在<code>固定的时刻</code>、在<code>固定的位置</code>随机生成某个Prefab，我们希望能拓展<code>Generator</code>的功能。<code>Generator</code>拓展后的功能需求如下：</p><blockquote><p><code>Generator</code>拓展后的功能需求</p></blockquote><ol><li>能动态地决定是使用<code>固定的时间间隔</code>还是使用<code>随机的时间间隔</code>来实例化预设对象，如果使用<code>固定的时间间隔</code>，那么要设置<code>时间间隔的长度</code>，如果使用<code>随机的时间间隔</code>，那么要设置<code>最短的时间间隔</code>和<code>最长的时间间隔</code></li><li>能动态地决定是在<code>固定位置</code>上还是在<code>随机位置</code>上实例化预设对象，如果选择在<code>随机位置</code>上实例化预设对象，那么需要能分别设置<code>X、Y坐标的随机范围</code></li></ol><hr><h2 id="拓展Generator-cs"><a href="#拓展Generator-cs" class="headerlink" title="拓展Generator.cs"></a>拓展Generator.cs</h2><p>&amp;emsp;&amp;emsp;在知道了<code>Generator</code>拓展后的功能需求之后，我们先根据需求来改写<code>Generator.cs</code></p><figure class="highlight csharp"><figcaption><span>Generator.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-comment">// 朝向</span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">enum</span> Orientation &#123;<br>    Left,<span class="hljs-comment">// 固定朝左</span><br>    Right,<span class="hljs-comment">// 固定朝右</span><br>    Random,<span class="hljs-comment">// 随机朝向</span><br>    None<span class="hljs-comment">// 不需要考虑朝向</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Generator</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;多久之后开始实例化预设对象&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> GenerateDelay = <span class="hljs-number">2f</span>;<br><br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;是否使用随机时间间隔来实例化预设对象&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> RandomGenerateInterval = <span class="hljs-literal">false</span>;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;实例化预设对象的最短时间间隔&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> MinGenerateInterval;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;实例化预设对象的最长时间间隔&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> MaxGenerateInterval;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;实例化预设对象的固定时间间隔&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> GenerateInterval = <span class="hljs-number">3f</span>;<br><br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;是否在随机的X坐标上实例化预设对象&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> RandomGeneratePositionX = <span class="hljs-literal">false</span>;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;实例化预设对象时的最小X坐标&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> MinGeneratePositionX;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;实例化预设对象时的最大X坐标&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> MaxGeneratePositionX;<br><br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;是否在随机的Y坐标上实例化预设对象&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> RandomGeneratePositionY = <span class="hljs-literal">false</span>;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;实例化预设对象时的最小Y坐标&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> MinGeneratePositionY;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;实例化预设对象时的最大Y坐标&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> MaxGeneratePositionY;<br><br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;预设对象的朝向&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> Orientation PrefabOrientation = Orientation.Right;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;预设对象&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> GameObject[] Prefabs;<br><br>    <span class="hljs-keyword">private</span> ParticleSystem m_Particle;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Awake</span>()</span> &#123;<br>        <span class="hljs-comment">// 获取引用</span><br>        m_Particle = GetComponent&lt;ParticleSystem&gt;();<br><br>        <span class="hljs-keyword">if</span>(Prefabs == <span class="hljs-literal">null</span> || Prefabs.Length == <span class="hljs-number">0</span>) &#123;<br>            Debug.LogError(<span class="hljs-string">&quot;请至少为Prefabs添加一个预设对象&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Start</span> ()</span> &#123;<br>        <span class="hljs-comment">// 开始随机生成的协程</span><br>        StartCoroutine(RandomGenerate());<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> IEnumerator <span class="hljs-title">RandomGenerate</span>()</span> &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title">WaitForSeconds</span>(<span class="hljs-params">GenerateDelay</span>)</span>;<br><br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-comment">// 确定下一次实例化预设对象的时间间隔</span><br>            <span class="hljs-built_in">float</span> interval = GenerateInterval;<br>            <span class="hljs-keyword">if</span>(RandomGenerateInterval) &#123;<br>                interval = Random.Range(MinGenerateInterval, MaxGenerateInterval);<br>            &#125;<br><br>            <span class="hljs-function"><span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title">WaitForSeconds</span>(<span class="hljs-params">interval</span>)</span>;<br>            <br>            <span class="hljs-comment">// 实例化预设对象</span><br>            Generate();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 实例化预设对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Generate</span>()</span> &#123;<br>        <span class="hljs-comment">// 随机选择要实例化的预设的下标</span><br>        <span class="hljs-built_in">int</span> index = Random.Range(<span class="hljs-number">0</span>, Prefabs.Length);<br><br>        <span class="hljs-comment">// 确定生成位置的X坐标</span><br>        <span class="hljs-built_in">float</span> x = transform.position.x;<br>        <span class="hljs-keyword">if</span>(RandomGeneratePositionX) &#123;<br>            x = Random.Range(MinGeneratePositionX, MaxGeneratePositionX);<br>        &#125;<br>        <br>        <span class="hljs-comment">// 确定生成位置的Y坐标</span><br>        <span class="hljs-built_in">float</span> y = transform.position.y;<br>        <span class="hljs-keyword">if</span>(RandomGeneratePositionY) &#123;<br>            y = Random.Range(MinGeneratePositionY, MaxGeneratePositionY);<br>        &#125;<br><br>        <span class="hljs-comment">// 更新位置</span><br>        transform.position = <span class="hljs-keyword">new</span> Vector3(x, y, transform.position.z);<br><br>        <span class="hljs-comment">// 实例化预设对象</span><br>        GameObject prefab = Instantiate(Prefabs[index], transform.position, Quaternion.identity);<br><br>        <span class="hljs-comment">// 播放粒子特效</span><br>        <span class="hljs-keyword">if</span>(m_Particle != <span class="hljs-literal">null</span>) &#123;<br>            m_Particle.Play();<br>        &#125;<br><br>        <span class="hljs-comment">// 不需要考虑朝向</span><br>        <span class="hljs-keyword">if</span>(PrefabOrientation == Orientation.None) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(PrefabOrientation == Orientation.Left) &#123;<br>            Wander wander = prefab.GetComponent&lt;Wander&gt;();<br>            <span class="hljs-keyword">if</span>(wander.FacingRight) &#123;<br>                wander.Flip();<br>            &#125;<br>            <span class="hljs-keyword">return</span>;<br>        &#125; <br>        <br>        <span class="hljs-keyword">if</span>(PrefabOrientation == Orientation.Right) &#123;<br>            Wander wander = prefab.GetComponent&lt;Wander&gt;();<br>            <span class="hljs-keyword">if</span>(!wander.FacingRight) &#123;<br>                wander.Flip();<br>            &#125;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(PrefabOrientation == Orientation.Random) &#123;<br>            Wander wander = prefab.GetComponent&lt;Wander&gt;();<br>            <span class="hljs-comment">// 有一半的概率进行翻转</span><br>            <span class="hljs-keyword">if</span>(Random.<span class="hljs-keyword">value</span> &lt;= <span class="hljs-number">0.5</span>) &#123;<br>                wander.Flip();<br>            &#125;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>代码说明：<br>&amp;emsp;&amp;emsp;这里，我们使用了<code>RandomGenerateInterval</code>、<code>RandomGeneratePositionX</code>和<code>RandomGeneratePositionY</code>这三个bool变量来分别设置是否使用<code>随机的时间间隔</code>来实例化预设对象、是否在<code>随机的X坐标</code>上实例化预设对象和是否在<code>随机的Y坐标</code>上实例化随机对象。</p></blockquote><p>&amp;emsp;&amp;emsp;改写完<code>Generator.cs</code>，我们打开<code>Generator</code>物体下任意一个带有<code>Generator.cs</code>的子物体，可以看到在<code>Inspector</code>窗口多出了很多变量。</p><p><img src="https://github.com/AsanCai/BlogImage/raw/master/PotatoGloryTutorial/Essay18/Image1.png" alt="默认的Inspector窗口"></p><hr><h2 id="使用自定义Inspector窗口隐藏无关变量"><a href="#使用自定义Inspector窗口隐藏无关变量" class="headerlink" title="使用自定义Inspector窗口隐藏无关变量"></a>使用自定义Inspector窗口隐藏无关变量</h2><p>&amp;emsp;&amp;emsp;我们希望在<code>设置参数</code>的时候，一些<code>无关的变量能被隐藏</code>不显示出来。因此，我们需要来自定义<code>Generator.cs</code>在<code>Inspector</code>窗口的显示规则。首先，我们在<code>Assets\Scripts</code>下新建一个名为<code>Editor</code>的文件夹，然后在<code>Assets\Scripts\Editor</code>下新建一个名为<code>GeneratorEditor</code>的C#脚本：</p><figure class="highlight csharp"><figcaption><span>GeneratorEditor.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><span class="hljs-keyword">using</span> UnityEditor;<br><br>[<span class="hljs-meta">CustomEditor(typeof(Generator))</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">GeneratorEditor</span> : <span class="hljs-title">Editor</span> &#123;<br>    <span class="hljs-comment">// 判断是否显示折叠框</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">bool</span> m_ShowPrefabs;<br><br>    <span class="hljs-comment">// Generator的ScriptAble实例对象</span><br>    <span class="hljs-keyword">private</span> Generator m_Generator;<br>    <span class="hljs-comment">// 用于存放Prefab</span><br>    <span class="hljs-keyword">private</span> List&lt;GameObject&gt; m_PrefabList = <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnInspectorGUI</span>()</span> &#123;<br>        <span class="hljs-comment">// 获取Generator脚本的ScriptAble实例对象</span><br>        m_Generator = (Generator)target;<br><br>        <span class="hljs-comment">// 显示GenerateDelay参数</span><br>        m_Generator.GenerateDelay = EditorGUILayout.FloatField(<span class="hljs-keyword">new</span> GUIContent(<span class="hljs-string">&quot;Generate Delay&quot;</span>, <span class="hljs-string">&quot;多久之后开始实例化预设对象&quot;</span>), m_Generator.GenerateDelay);<br>        <br>        <span class="hljs-comment">// 显示RandomGenerateInterval参数</span><br>        m_Generator.RandomGenerateInterval = EditorGUILayout.Toggle(<span class="hljs-keyword">new</span> GUIContent(<span class="hljs-string">&quot;Random Generate Interval&quot;</span>, <span class="hljs-string">&quot;多久之后开始实例化预设对象&quot;</span>), m_Generator.RandomGenerateInterval);<br>        <span class="hljs-keyword">if</span>(m_Generator.RandomGenerateInterval) &#123;<br>            <span class="hljs-comment">// 显示MinGenerateInterval和MaxGenerateInterval参数</span><br>            m_Generator.MinGenerateInterval = EditorGUILayout.FloatField(<span class="hljs-keyword">new</span> GUIContent(<span class="hljs-string">&quot;Min Generate Interval&quot;</span>, <span class="hljs-string">&quot;实例化预设对象的最短时间间隔&quot;</span>), m_Generator.MinGenerateInterval);<br>            m_Generator.MaxGenerateInterval = EditorGUILayout.FloatField(<span class="hljs-keyword">new</span> GUIContent(<span class="hljs-string">&quot;Max Generate Interval&quot;</span>, <span class="hljs-string">&quot;实例化预设对象的最长时间间隔&quot;</span>), m_Generator.MaxGenerateInterval);<br>            <br>            <span class="hljs-comment">// 确保MaxGenerateInterval的数值比MinGenerateInterval大</span><br>            <span class="hljs-keyword">if</span>(m_Generator.MaxGenerateInterval &lt; m_Generator.MinGenerateInterval) &#123;<br>                m_Generator.MaxGenerateInterval = m_Generator.MinGenerateInterval;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 显示GenerateInterval参数</span><br>            m_Generator.GenerateInterval = EditorGUILayout.FloatField(<span class="hljs-keyword">new</span> GUIContent(<span class="hljs-string">&quot;Generate Interval&quot;</span>, <span class="hljs-string">&quot;实例化预设对象的固定时间间隔&quot;</span>), m_Generator.GenerateInterval);<br>        &#125;<br>        <br>        <span class="hljs-comment">// 显示RandomGeneratePositionX参数</span><br>        m_Generator.RandomGeneratePositionX = EditorGUILayout.Toggle(<span class="hljs-keyword">new</span> GUIContent(<span class="hljs-string">&quot;RandomG enerate PositionX&quot;</span>, <span class="hljs-string">&quot;是否在随机的X坐标上实例化预设对象&quot;</span>), m_Generator.RandomGeneratePositionX);<br>        <span class="hljs-keyword">if</span>(m_Generator.RandomGeneratePositionX) &#123;<br>            <span class="hljs-comment">// 显示MinGeneratePositionX和MaxGeneratePositionX参数</span><br>            m_Generator.MinGeneratePositionX = EditorGUILayout.FloatField(<span class="hljs-keyword">new</span> GUIContent(<span class="hljs-string">&quot;Min Generate PositionX&quot;</span>, <span class="hljs-string">&quot;实例化预设对象的最小X坐标&quot;</span>), m_Generator.MinGeneratePositionX);<br>            m_Generator.MaxGeneratePositionX = EditorGUILayout.FloatField(<span class="hljs-keyword">new</span> GUIContent(<span class="hljs-string">&quot;Max Generate PositionX&quot;</span>, <span class="hljs-string">&quot;实例化预设对象的最大X坐标&quot;</span>), m_Generator.MaxGeneratePositionX);<br><br>            <span class="hljs-comment">// 确保MaxGeneratePositionX的数值比MinGeneratePositionX大</span><br>            <span class="hljs-keyword">if</span>(m_Generator.MaxGeneratePositionX &lt; m_Generator.MinGeneratePositionX) &#123;<br>                m_Generator.MaxGeneratePositionX = m_Generator.MinGeneratePositionX;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 显示RandomGeneratePositionY参数</span><br>        m_Generator.RandomGeneratePositionY = EditorGUILayout.Toggle(<span class="hljs-keyword">new</span> GUIContent(<span class="hljs-string">&quot;RandomG enerate PositionY&quot;</span>, <span class="hljs-string">&quot;是否在随机的Y坐标上实例化预设对象&quot;</span>), m_Generator.RandomGeneratePositionY);<br>        <span class="hljs-keyword">if</span>(m_Generator.RandomGeneratePositionY) &#123;<br>            <span class="hljs-comment">// 显示MinGeneratePositionY和MaxGeneratePositionY参数</span><br>            m_Generator.MinGeneratePositionY = EditorGUILayout.FloatField(<span class="hljs-keyword">new</span> GUIContent(<span class="hljs-string">&quot;Min Generate PositionY&quot;</span>, <span class="hljs-string">&quot;实例化预设对象的最小Y坐标&quot;</span>), m_Generator.MinGeneratePositionY);<br>            m_Generator.MaxGeneratePositionY = EditorGUILayout.FloatField(<span class="hljs-keyword">new</span> GUIContent(<span class="hljs-string">&quot;Max Generate PositionY&quot;</span>, <span class="hljs-string">&quot;实例化预设对象的最大Y坐标&quot;</span>), m_Generator.MaxGeneratePositionY);<br><br>            <span class="hljs-comment">// 确保MaxGeneratePositionY的数值比MaxGeneratePositionY大</span><br>            <span class="hljs-keyword">if</span>(m_Generator.MaxGeneratePositionY &lt; m_Generator.MinGeneratePositionY) &#123;<br>                m_Generator.MaxGeneratePositionY = m_Generator.MinGeneratePositionY;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 显示PrefabOrientation参数</span><br>        m_Generator.PrefabOrientation = (Orientation)EditorGUILayout.EnumPopup(<span class="hljs-keyword">new</span> GUIContent(<span class="hljs-string">&quot;Prefab Orientation&quot;</span>, <span class="hljs-string">&quot;预设对象的朝向&quot;</span>), m_Generator.PrefabOrientation);<br>        <br>        <span class="hljs-comment">// 获取当前有哪些已赋值的Prefab</span><br>        <span class="hljs-keyword">if</span>(m_PrefabList == <span class="hljs-literal">null</span>) &#123;<br>            m_PrefabList = <span class="hljs-keyword">new</span> List&lt;GameObject&gt;(m_Generator.Prefabs);<br>        &#125;<br>        <span class="hljs-comment">// 绘制折叠框，设置Prefabs参数</span><br>        m_ShowPrefabs = EditorGUILayout.Foldout(m_ShowPrefabs, <span class="hljs-keyword">new</span> GUIContent(<span class="hljs-string">&quot;Prefabs&quot;</span>, <span class="hljs-string">&quot;预设对象&quot;</span>));<br>        <span class="hljs-keyword">if</span>(m_ShowPrefabs) &#123;<br>            <span class="hljs-comment">// 缩进</span><br>            EditorGUI.indentLevel++;<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; m_Generator.Prefabs.Length; i++) &#123;<br>                EditorGUILayout.BeginHorizontal();<br>                <span class="hljs-comment">// 绘制元素赋值框</span><br>                m_Generator.Prefabs[i] = (GameObject)EditorGUILayout.ObjectField(<span class="hljs-keyword">new</span> GUIContent(<span class="hljs-string">&quot;Prefab&quot;</span>, <span class="hljs-string">&quot;预设对象&quot;</span>), m_Generator.Prefabs[i], <span class="hljs-keyword">typeof</span>(GameObject), <span class="hljs-literal">false</span>);<br><br>                <span class="hljs-comment">// 删除指定元素</span><br>                <span class="hljs-keyword">if</span> (GUILayout.Button(<span class="hljs-string">&quot;Remove&quot;</span>)) &#123;<br>                    m_PrefabList.RemoveAt(i);<br>                    m_Generator.Prefabs = m_PrefabList.ToArray();<br>                &#125;<br>                EditorGUILayout.EndHorizontal();<br>            &#125;<br>            <span class="hljs-comment">// 增加一个元素</span><br>            <span class="hljs-keyword">if</span> (GUILayout.Button(<span class="hljs-string">&quot;Add&quot;</span>)) &#123;<br>                m_PrefabList.Add(<span class="hljs-literal">null</span>);<br>                m_Generator.Prefabs = m_PrefabList.ToArray();<br>            &#125;<br><br>            <span class="hljs-comment">// 取消缩进</span><br>            EditorGUI.indentLevel--;<br>        &#125;<br><br>        <span class="hljs-comment">// 当值改变时，将target标记为已修改</span><br>        <span class="hljs-keyword">if</span> (GUI.changed) &#123;<br>            EditorUtility.SetDirty(target);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>代码说明：</p></blockquote><ol><li>因为<code>GeneratorEditor.cs</code>是用于自定义<code>Inspector</code>窗口脚本，所以必须将<code>GeneratorEditor.cs</code>放在一个名为<code>Editor</code>的文件夹下<code>（Editor文件夹可以位于任意位置）</code></li><li><code>CustomEditor</code>是Unity提供的<code>Attribute</code>，我们需要使用它来<code>标识我们要自定义哪个脚本</code>的<code>Inspector</code>窗口</li><li>由于绘制<code>Inspector窗口</code>的代码是在<code>OnInspectorGUI</code>这一函数里执行的，我们需要让<code>GeneratorEditor</code>这个类继承<code>UnityEditor</code>命名空间下的<code>Editor</code>类，并使用关键字<code>override</code>覆写<code>OnInspectorGUI</code>函数</li><li><code>target</code>是<code>Editor</code>类提供的成员变量，我们可以通过它来获取<code>当前脚本实例对象</code></li><li>由于我们覆写了<code>OnInspectorGUI</code>函数，所以<code>Unity默认的脚本序列化代码</code>不会被执行，我们需要自己使用<code>EditorGUILayout</code>提供的静态函数来<code>序列化各个变量</code>（同理，脚本里面的<code>ToolTip</code>也失效了，如果需要在<code>Inspector</code>窗口提示变量的含义，我们也需要自己编写）</li><li>由于<code>EditorGUILayout</code>没有提供数组的序列化方法，所以我们需要<code>逐一对数组的每个元素</code>进行序列化</li><li>最后，我们使用<code>EditorUtility</code>提供的静态方法<code>SetDirty</code>在我们修改参数之后将<code>target</code>标记为已修改，否则Prefab的实例对象上的<code>参数会被Prefab上的值覆盖</code></li></ol><p>&amp;emsp;&amp;emsp;编写完<code>GeneratorEditor.cs</code>之后，再次打开<code>Generator</code>物体下任意一个带有<code>Generator.cs</code>的子物体，可以看到此时<code>Inspector</code>窗口少了很多变量。而且根据我们的选择，<code>Inspector</code>窗口显示的变量也会动态改变。</p><p><img src="https://github.com/AsanCai/BlogImage/raw/master/PotatoGloryTutorial/Essay18/Image2.png" alt="自定义的Inspector窗口"></p><hr><h2 id="调整各个Generator的参数"><a href="#调整各个Generator的参数" class="headerlink" title="调整各个Generator的参数"></a>调整各个Generator的参数</h2><p>&amp;emsp;&amp;emsp;有了拓展后的<code>Generator.cs</code>，接下来，我们就要来调整各个<code>Generator</code>的参数了。需要注意的是，因为<code>Generator</code>的<code>Position</code>，<code>需要实例化的Prefab</code>以及<code>实例化Prefab时的朝向</code>都没有改变，所以不再列出。</p><blockquote><p>场景中各个Generator的设置</p></blockquote><ul><li><code>EnemyGenerator</code>:<ul><li><code>Generator Delay</code>: 2</li><li><code>Random Generate Interval</code>: true</li><li><code>Min Generate Interval</code>: 2</li><li><code>Max Generate Interval</code>: 8</li><li><code>RandomG enerate PositionX</code>: true</li><li><code>Min Generate PositionX</code>: -17.5</li><li><code>Max Generate PositionX</code>: -6.5</li><li><code>RandomG enerate PositionY</code>: false</li></ul></li><li><code>EnemyGenerator (1)</code>:<ul><li><code>Generator Delay</code>: 2</li><li><code>Random Generate Interval</code>: true</li><li><code>Min Generate Interval</code>: 2</li><li><code>Max Generate Interval</code>: 8</li><li><code>RandomG enerate PositionX</code>: true</li><li><code>Min Generate PositionX</code>: -6</li><li><code>Max Generate PositionX</code>: 6</li><li><code>RandomG enerate PositionY</code>: false</li></ul></li><li><code>EnemyGenerator (2)</code>:<ul><li><code>Generator Delay</code>: 2</li><li><code>Random Generate Interval</code>: true</li><li><code>Min Generate Interval</code>: 2</li><li><code>Max Generate Interval</code>: 8</li><li><code>RandomG enerate PositionX</code>: true</li><li><code>Min Generate PositionX</code>: 6.5</li><li><code>Max Generate PositionX</code>: 17.5</li><li><code>RandomG enerate PositionY</code>: false</li></ul></li><li><code>CabGenerator</code>:<ul><li><code>Generator Delay</code>: 1</li><li><code>Random Generate Interval</code>: true</li><li><code>Min Generate Interval</code>: 5</li><li><code>Max Generate Interval</code>: 15</li><li><code>RandomG enerate PositionX</code>: false</li><li><code>RandomG enerate PositionY</code>: false</li></ul></li><li><code>CabGenerator (1)</code>:<ul><li><code>Generator Delay</code>: 5</li><li><code>Random Generate Interval</code>: true</li><li><code>Min Generate Interval</code>: 5</li><li><code>Max Generate Interval</code>: 15</li><li><code>RandomG enerate PositionX</code>: false</li><li><code>RandomG enerate PositionY</code>: false</li></ul></li><li><code>BusGenerator</code>:<ul><li><code>Generator Delay</code>: 4</li><li><code>Random Generate Interval</code>: true</li><li><code>Min Generate Interval</code>: 5</li><li><code>Max Generate Interval</code>: 15</li><li><code>RandomG enerate PositionX</code>: false</li><li><code>RandomG enerate PositionY</code>: false</li></ul></li><li><code>BusGenerator (1)</code>:<ul><li><code>Generator Delay</code>: 8</li><li><code>Random Generate Interval</code>: true</li><li><code>Min Generate Interval</code>: 5</li><li><code>Max Generate Interval</code>: 15</li><li><code>RandomG enerate PositionX</code>: false</li><li><code>RandomG enerate PositionY</code>: falsealse</li><li><code>Prefab Orientation</code>: Random</li></ul></li><li><code>SwanGenerator</code>:<ul><li><code>Generator Delay</code>: 2</li><li><code>Random Generate Interval</code>: true</li><li><code>Min Generate Interval</code>: 5</li><li><code>Max Generate Interval</code>: 15</li><li><code>RandomG enerate PositionX</code>: false</li><li><code>RandomG enerate PositionY</code>: true</li><li><code>Min Generate PositionY</code>: -7</li><li><code>Max Generate PositionY</code>: 2</li></ul></li><li><code>SwanGenerator (1)</code>:<ul><li><code>Generator Delay</code>: 2</li><li><code>Random Generate Interval</code>: true</li><li><code>Min Generate Interval</code>: 5</li><li><code>Max Generate Interval</code>: 15</li><li><code>RandomG enerate PositionX</code>: false</li><li><code>RandomG enerate PositionY</code>: true</li><li><code>Min Generate PositionY</code>: -7</li><li><code>Max Generate PositionY</code>: 2</li></ul></li><li><code>PickupGenerator</code>:<ul><li><code>Generator Delay</code>: 5</li><li><code>Random Generate Interval</code>: true</li><li><code>Min Generate Interval</code>: 15</li><li><code>Max Generate Interval</code>: 20</li><li><code>RandomG enerate PositionX</code>: true</li><li><code>Min Generate PositionX</code>: -15</li><li><code>Max Generate PositionX</code>: -5</li><li><code>RandomG enerate PositionY</code>: false</li></ul></li><li><code>PickupGenerator (1)</code>:<ul><li><code>Generator Delay</code>: 5</li><li><code>Random Generate Interval</code>: true</li><li><code>Min Generate Interval</code>: 15</li><li><code>Max Generate Interval</code>: 20</li><li><code>RandomG enerate PositionX</code>: true</li><li><code>Min Generate PositionX</code>: 5</li><li><code>Max Generate PositionX</code>: 15</li><li><code>RandomG enerate PositionY</code>: false</li></ul></li></ul><p>&amp;emsp;&amp;emsp;运行游戏，可以发现此时各个<code>Generator</code>能按照我们的设置，在<code>随机的时刻</code>和<code>随机的位置</code>随机生成某个Prefab。</p><hr><h2 id="后言"><a href="#后言" class="headerlink" title="后言"></a>后言</h2><p>&amp;emsp;&amp;emsp;至此，我们的拓展<code>Generator</code>的工作就全部完成了。需要说明的是，现有的<code>Generator</code>还不是最优的，因为我们没有利用<code>资源池</code>来回收在场景中生成的对象，而是<code>不断地实例化和销毁对象</code>。因为采用<code>资源池</code>的方法来改写<code>Generator</code>，我们需要改造Prefab，使得我们可以重置并回收已生成的资源，工作量较大，所以在这里我们并不提及，感兴趣的读者可以自己进一步拓展。</p><p>&amp;emsp;&amp;emsp;最后，本篇文章所做的修改，可以在<a href="https://github.com/AsanCai/PotatoGloryTutorial">PotatoGloryTutorial</a>这个仓库的<code>essay16</code>分支下看到，读者可以clone这个仓库到本地进行查看。</p><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://unity3d.com/cn/learn/tutorials/topics/interface-essentials/building-custom-inspector">Building a Custom Inspector</a></li><li><a href="https://docs.unity3d.com/ScriptReference/Editor.html">Editor类的说明文档</a></li><li><a href="https://docs.unity3d.com/ScriptReference/EditorGUILayout.html">EditorGUILayout的说明文档</a></li><li><a href="https://docs.unity3d.com/ScriptReference/EditorUtility.html">EditorUtility的说明文档</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
      <category>《土豆荣耀》</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《土豆荣耀》重构笔记（十七）随机生成可拾取道具</title>
    <link href="/posts/7abcd8c8/"/>
    <url>/posts/7abcd8c8/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&amp;emsp;&amp;emsp;我们在<a href="https://asancai.github.io/tutorial/potato-glory/PotatoGloryTutorial-14/">前面的文章</a>中，已经实现了<code>随机生成足够多的怪物</code>的功能。为了能延长游戏时间，增加游戏的趣味性，我们需要<code>随机生成一些可拾取的道具</code>，来<code>恢复角色的血量</code>或者<code>增加角色可释放的炸弹数</code>。<code>可拾取道具</code>的需求如下：</p><blockquote><p><code>可拾取道具</code>的需求：</p></blockquote><ol><li><code>可拾取道具</code>在设定上是<code>空投补给</code>的，所以在落地之前，<code>可拾取道具</code>将会<code>在降落伞的作用下缓慢下降</code>，在落地之后，<code>可拾取道具</code>上的<code>降落伞缓慢消失</code></li><li><code>可拾取道具</code>一共有两种，分别是<code>能恢复角色血量</code>的<code>医疗箱</code>和<code>增加角色可释放炸弹数</code>的<code>装备箱</code></li><li><code>可拾取道具</code>在<code>降落的过程</code>中也能被角色拾取</li><li><code>装备箱</code>被<code>导弹击中</code>会被直接引爆</li></ol><hr><h2 id="制作降落伞动画"><a href="#制作降落伞动画" class="headerlink" title="制作降落伞动画"></a>制作降落伞动画</h2><p>&amp;emsp;&amp;emsp;根据<code>可拾取道具的需求</code>，我们知道降落伞应该有两个动画，一个是<code>降落时在空中飘动的动画</code>，另一个则是<code>落地时缓慢消失的动画</code>。首先，我们在<code>Assets\Animation</code>和<code>Assets\Animator</code>文件夹下新建一个名为<code>Prop</code>的文件夹，分别用来保存降落伞的<code>动画文件</code>和<code>动画状态机文件</code>。创建完毕之后，我们先来制作<code>降落伞降落时在空中飘动的动画</code>。</p><blockquote><p>制作<code>降落伞降落时在空中飘动的动画</code>的步骤：</p></blockquote><ol><li>在场景中创建一个名为<code>Parachute</code>的<code>Empty GameObject</code>，然后将<code>Assets\Sprites\Props</code>文件夹下的<code>prop_parachute</code>图片拖拽至<code>Parachute</code>物体，使其成为<code>Parachute</code>物体的子物体</li><li>将<code>prop_parachute</code>物体上<code>SpriteRenderer</code>组件的<code>Sorting Layer</code>设置为<code>Foreground</code>，<code>Order In Layer</code>设置为<code>1</code></li><li>打开<code>Animation</code>窗口，在<code>Hierarchy</code>窗口中选中<code>Parachute</code>物体，然后点击<code>Create</code>创建一个名为<code>FloatDown.anim</code>的动画，并将其保存在<code>Assets\Animation\Prop</code>文件夹下</li><li>将<code>Assets\Animation\Prop</code>文件夹下的<code>Parachute.controller</code>文件移动至<code>Assets\Animator\Prop</code>文件夹下</li><li>点击<code>Animation</code>窗口的<code>红点按钮</code>，开始为<code>FloatDown.anim</code>添加关键帧，添加的关键帧信息如下：<blockquote><blockquote><p><code>FloatDown.anim</code>的关键帧：</p></blockquote></blockquote><ol><li><code>第一帧</code>：<ul><li><code>frame</code>: 0</li><li><code>Parachute：Rotaition</code>: (0, 0, -12)</li></ul></li><li><code>第二帧</code>：<ul><li><code>frame</code>: 30</li><li><code>Parachute：Rotaition</code>: (0, 0, 12)</li></ul></li><li><code>第三帧</code>：<ul><li><code>frame</code>: 60</li><li><code>Parachute：Rotaition</code>: (0, 0, 12)</li></ul></li></ol></li></ol><p>&amp;emsp;&amp;emsp;制作完成之后，我们接着制作<code>降落伞落地时缓慢消失的动画</code>。</p><blockquote><p>制作<code>降落伞落地时缓慢消失的动画</code>的步骤：</p></blockquote><ol><li>为<code>Parachute</code>物体添加<code>Destroyer.cs</code>脚本</li><li>在<code>Animation</code>窗口选中<code>FloatDown</code>下拉框，然后点击<code>Create New Clip</code>创建一个名为<code>Landing.anim</code>的动画，并将其保存在<code>Assets\Animation\Prop</code>文件夹下</li><li>点击<code>Animation</code>窗口的<code>红点按钮</code>，开始为<code>Landing.anim</code>添加关键帧，添加的关键帧信息如下：<blockquote><blockquote><p><code>Landing.anim</code>的关键帧：</p></blockquote></blockquote><ol><li><code>第一帧</code>：<ul><li><code>frame</code>: 0</li><li><code>prop_parachute：Scale</code>: (1, 1, 1)</li><li><code>prop_parachute：GameObject.IsActive</code>: true</li><li><code>prop_parachute：Sprite Renderer.Color</code>: (1, 1, 1, 1)</li></ul></li><li><code>第二帧</code>：<ul><li><code>frame</code>: 45</li><li><code>prop_parachute：Sprite Renderer.Color</code>: (1, 1, 1, 0)</li></ul></li><li><code>第三帧</code>：<ul><li><code>frame</code>: 60</li><li><code>prop_parachute：Scale</code>: (0, 0, 1)</li><li><code>prop_parachute：GameObject.IsActive</code>: false</li></ul></li></ol></li><li>在<code>Landing.anim</code>的最后一帧处添加一个<code>Animation Event</code>，选择<code>DestroyGameObject</code>方法作为这个<code>Animation Event</code>的调用方法</li></ol><hr><h2 id="制作降落伞的其他工作"><a href="#制作降落伞的其他工作" class="headerlink" title="制作降落伞的其他工作"></a>制作降落伞的其他工作</h2><p>&amp;emsp;&amp;emsp;制作完成降落伞的所有动画之后，我们接下来继续编辑<code>控制降落伞动画</code>的<code>动画状态机</code>，也就是Unity自动为我们创建的<code>Parachute.controller</code>文件。</p><blockquote><p>编辑<code>Parachute.controller</code>的步骤：</p></blockquote><ol><li>打开<code>Animator</code>窗口，然后选择<code>Hierarchy</code>窗口中的<code>Parachute</code>物体</li><li>新建一个名为<code>Landing</code>的<code>Trigger</code>变量</li><li>新建一个从<code>FloatDown</code>到<code>Landing</code>的<code>Transition</code>，然后设置<code>转移条件</code>为<code>Landing</code>这一<code>Trigger</code>变量，并取消<code>Has Exit Time</code>的勾选<blockquote><p><img src="https://github.com/AsanCai/BlogImage/raw/master/PotatoGloryTutorial/Essay17/Image1.png" alt="Parachute.controller"></p></blockquote></li></ol><p>&amp;emsp;&amp;emsp;降落伞的<code>动画状态机</code>编辑完成之后，我们还需要让降落伞能在重力的作用下缓慢下降。因此，我们需要为<code>Parachute</code>物体添加<code>Rigidbody2D</code>组件，并将<code>Parachute</code>物体上<code>Rigidbody2D</code>组件的<code>Linear Grag</code>属性设置为<code>6</code>，用来模拟降落伞下落时受到的<code>空气阻力</code>。</p><hr><h2 id="编写控制可拾取道具的脚本"><a href="#编写控制可拾取道具的脚本" class="headerlink" title="编写控制可拾取道具的脚本"></a>编写控制可拾取道具的脚本</h2><p>&amp;emsp;&amp;emsp;降落伞制作完毕之后，我们先根据<code>可拾取道具的需求</code>来编写<code>控制可拾取道具的脚本</code>。首先，我们在<code>Assets\Scripts</code>文件夹下创建一个名为<code>Prop</code>的文件夹，并在<code>Assets\Scripts\Prop</code>文件夹下分别创建一个名为<code>MedicalBoxPickup</code>和一个名为<code>AmmunitionBoxPickup</code>的C#脚本。创建完毕之后，我们先来编写<code>MedicalBoxPickup.cs</code>，用于控制<code>医疗箱</code>：</p><figure class="highlight csharp"><figcaption><span>MedicalBoxPickup.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br>[<span class="hljs-meta">RequireComponent(typeof(CircleCollider2D))</span>]<br>[<span class="hljs-meta">RequireComponent(typeof(BoxCollider2D))</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MedicalBoxPickup</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;医疗箱的治疗量&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> HealAmount;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;被拾取时播放的音效&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> AudioClip PickupEffect;<br><br>    <span class="hljs-keyword">private</span> Animator m_Animator;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">bool</span> m_Landed;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Awake</span>()</span> &#123;<br>        m_Animator = transform.root.GetComponent&lt;Animator&gt;();<br><br>        GetComponent&lt;CircleCollider2D&gt;().isTrigger = <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span> &#123;<br>        m_Landed = <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnTriggerEnter2D</span>(<span class="hljs-params">Collider2D collision</span>)</span> &#123;<br>        <span class="hljs-comment">// 接触到地面</span><br>        <span class="hljs-keyword">if</span> (collision.tag == <span class="hljs-string">&quot;Ground&quot;</span> &amp;&amp; !m_Landed) &#123;<br>            m_Landed = <span class="hljs-literal">true</span>;<br><br>            <span class="hljs-comment">// 脱离降落伞</span><br>            transform.parent = <span class="hljs-literal">null</span>;<br>            gameObject.AddComponent&lt;Rigidbody2D&gt;();<br><br>            <span class="hljs-comment">// 播放降落伞的落地动画</span><br>            m_Animator.SetTrigger(<span class="hljs-string">&quot;Landing&quot;</span>);<br><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 被角色拾取</span><br>        <span class="hljs-keyword">if</span>(collision.CompareTag(<span class="hljs-string">&quot;Player&quot;</span>)) &#123;<br>            <span class="hljs-comment">// 恢复角色血量</span><br>            collision.GetComponent&lt;PlayerHealth&gt;().Heal(HealAmount);<br><br>            <span class="hljs-comment">// 播放拾取音效</span><br>            AudioSource.PlayClipAtPoint(PickupEffect, transform.position);<br><br>            <span class="hljs-comment">// 销毁整个物体</span><br>            Destroy(transform.root.gameObject);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>代码说明：<br>&amp;emsp;&amp;emsp;这里，我们使用<code>Trigger</code>来识别当前降落伞触碰到哪些物体，因此我们需要新建一个名为<code>Ground</code>的<code>Tag</code>，并将<code>Foreground</code>物体下的子物体<code>env_PlatformBridge</code>、<code>env_PlatformBridge (1)</code>、<code>env_PlatformTop</code>、<code>env_PlatformTop (1)</code>以及<code>env_PlatformUfo</code>的<code>Tag</code>设置为<code>Ground</code>。</p></blockquote><p>&amp;emsp;&amp;emsp;接着，我们需要改写<code>PlayerHealth.cs</code>，编辑<code>PlayerHealth.cs</code>如下：</p><figure class="highlight csharp"><figcaption><span>PlayerHealth.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br>[<span class="hljs-meta">RequireComponent(typeof(Rigidbody2D))</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PlayerHealth</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;角色的最大生命值&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> MaxHP = <span class="hljs-number">100f</span>;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;角色的受伤音效&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> AudioClip[] OuchClips;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;角色受伤后的免伤时间&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> FreeDamagePeriod = <span class="hljs-number">0.35f</span>;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;血量条&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> SpriteRenderer HealthSprite;<br><br>    <span class="hljs-comment">// 角色当前的血量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">float</span> m_CurrentHP;<br>    <span class="hljs-comment">// 上一次受到伤害的时间</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">float</span> m_LastFreeDamageTime;<br>    <span class="hljs-comment">// 血量条的初始长度</span><br>    <span class="hljs-keyword">private</span> Vector3 m_InitHealthScale;<br>    <span class="hljs-comment">// 角色当前是否死亡</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">bool</span> m_IsDead;<br><br>    <span class="hljs-keyword">private</span> Rigidbody2D m_Rigidbody2D;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Awake</span>()</span> &#123;<br>        m_Rigidbody2D = GetComponent&lt;Rigidbody2D&gt;();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span> &#123;<br>        <span class="hljs-comment">// 初始化变量</span><br>        m_CurrentHP = MaxHP;<br>        m_LastFreeDamageTime = <span class="hljs-number">0f</span>;<br>        m_InitHealthScale = HealthSprite.transform.localScale;<br>        m_IsDead = <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 受伤函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">TakeDamage</span>(<span class="hljs-params">Transform enemy, <span class="hljs-built_in">float</span> hurtForce, <span class="hljs-built_in">float</span> damage</span>)</span> &#123;<br>        <span class="hljs-keyword">if</span>(m_IsDead) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 处于免伤状态，不执行任何操作</span><br>        <span class="hljs-keyword">if</span>(Time.time &lt;= m_LastFreeDamageTime + FreeDamagePeriod) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 更新上次受伤害的时间</span><br>        m_LastFreeDamageTime = Time.time;<br><br>        <span class="hljs-comment">// 给角色加上后退的力，制造击退效果</span><br>        Vector3 hurtVector = transform.position - enemy.position + Vector3.up * <span class="hljs-number">5f</span>;<br>        m_Rigidbody2D.AddForce(hurtVector.normalized * hurtForce);<br><br>        <span class="hljs-comment">// 更新角色的生命值</span><br>        m_CurrentHP -= damage;<br><br>        <span class="hljs-comment">// 更新生命条</span><br>        UpdateHealthBar();<br><br>        <span class="hljs-comment">// 随机播放受伤音频</span><br>        <span class="hljs-keyword">if</span>(OuchClips != <span class="hljs-literal">null</span> &amp;&amp; OuchClips.Length &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">int</span> i = Random.Range(<span class="hljs-number">0</span>, OuchClips.Length);<br>            AudioSource.PlayClipAtPoint(OuchClips[i], transform.position);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            Debug.LogWarning(<span class="hljs-string">&quot;请设置OuchClips&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 角色死亡</span><br>        <span class="hljs-keyword">if</span>(m_CurrentHP &lt;= <span class="hljs-number">0f</span>) &#123;<br>            Death();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 恢复血量</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Heal</span>(<span class="hljs-params"><span class="hljs-built_in">float</span> healAmount</span>)</span> &#123;<br>        <span class="hljs-keyword">if</span>(m_IsDead) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        m_CurrentHP += healAmount;<br><br>        UpdateHealthBar();<br>    &#125;<br><br>    <span class="hljs-comment">// 更新血量条的函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">UpdateHealthBar</span>()</span> &#123;<br>        <span class="hljs-comment">// 限制当前血量的值</span><br>        m_CurrentHP = Mathf.Clamp(m_CurrentHP, <span class="hljs-number">0</span>, MaxHP);<br><br>        <span class="hljs-keyword">if</span>(HealthSprite != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 更新血量条颜色</span><br>            HealthSprite.color = Color.Lerp(Color.green, Color.red, <span class="hljs-number">1</span> - m_CurrentHP * <span class="hljs-number">0.01f</span>);<br>            <span class="hljs-comment">// 更新血量条长度</span><br>            HealthSprite.transform.localScale = Vector3.Scale(m_InitHealthScale, <span class="hljs-keyword">new</span> Vector3(m_CurrentHP * <span class="hljs-number">0.01f</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>));<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            Debug.LogError(<span class="hljs-string">&quot;请设置HealthSprite&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 死亡函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Death</span>()</span> &#123;<br>        m_IsDead = <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-comment">// 将碰撞体设置为Trigger，避免和其他物体产生碰撞效果</span><br>        Collider2D[] cols = GetComponents&lt;Collider2D&gt;();<br>        <span class="hljs-keyword">foreach</span>(Collider2D c <span class="hljs-keyword">in</span> cols) &#123;<br>            c.isTrigger = <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 禁用脚本</span><br>        GetComponent&lt;PlayerController&gt;().enabled = <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-comment">// 播放死亡动画</span><br>        GetComponent&lt;Animator&gt;().SetTrigger(<span class="hljs-string">&quot;Death&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>代码说明：<br>&amp;emsp;&amp;emsp;这里，我们新增了一个变量<code>m_IsDead</code>来检测角色是否死亡，然后增加一个用于恢复角色血量的<code>Heal</code>函数。最后，我们在<code>UpdateHealthBar</code>内限制了角色的血量。</p></blockquote><p>&amp;emsp;&amp;emsp;编写<code>MedicalBoxPickup.cs</code>之后，我们继续编写<code>AmmunitionBoxPickup.cs</code>来控制<code>弹药箱</code>：</p><figure class="highlight csharp"><figcaption><span>AmmunitionBoxPickup.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br>[<span class="hljs-meta">RequireComponent(typeof(CircleCollider2D))</span>]<br>[<span class="hljs-meta">RequireComponent(typeof(BoxCollider2D))</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AmmunitionBoxPickup</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;增加的炸弹数&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> BombAmount = <span class="hljs-number">1</span>;<br><br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;被拾取时播放的音效&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> AudioClip PickupEffect;<br><br>    <span class="hljs-keyword">private</span> Animator m_Animator;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">bool</span> m_Landed;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Awake</span>()</span> &#123;<br>        m_Animator = transform.root.GetComponent&lt;Animator&gt;();<br><br>        GetComponent&lt;CircleCollider2D&gt;().isTrigger = <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span> &#123;<br>        m_Landed = <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnTriggerEnter2D</span>(<span class="hljs-params">Collider2D collision</span>)</span> &#123;<br>        <span class="hljs-comment">// 接触到地面</span><br>        <span class="hljs-keyword">if</span> (collision.tag == <span class="hljs-string">&quot;Ground&quot;</span> &amp;&amp; !m_Landed) &#123;<br>            m_Landed = <span class="hljs-literal">true</span>;<br><br>            <span class="hljs-comment">// 脱离降落伞</span><br>            transform.parent = <span class="hljs-literal">null</span>;<br>            gameObject.AddComponent&lt;Rigidbody2D&gt;();<br><br>            <span class="hljs-comment">// 播放降落伞的落地动画</span><br>            m_Animator.SetTrigger(<span class="hljs-string">&quot;Landing&quot;</span>);<br><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 被角色拾取</span><br>        <span class="hljs-keyword">if</span>(collision.tag == <span class="hljs-string">&quot;Player&quot;</span>) &#123;<br>            <span class="hljs-comment">// 增加炸弹数</span><br>            collision.GetComponent&lt;PlayerAttack&gt;().AddBomb(BombAmount);<br><br>            <span class="hljs-comment">// 播放拾取音效</span><br>            AudioSource.PlayClipAtPoint(PickupEffect, transform.position);<br><br>            <span class="hljs-comment">// 销毁整个物体</span><br>            Destroy(transform.root.gameObject);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;最后，我们在<code>PlayerAttack.cs</code>中增加<code>AddBomb</code>函数：</p><figure class="highlight csharp"><figcaption><span>PlayerAttack.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-comment">// [RequireComponent(typeof(Animator))]</span><br>[<span class="hljs-meta">RequireComponent(typeof(PlayerController))</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PlayerAttack</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br>    ...<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">AddBomb</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> bombNum</span>)</span> &#123;<br>        m_CurrentBombNumber += <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="制作可拾取道具"><a href="#制作可拾取道具" class="headerlink" title="制作可拾取道具"></a>制作可拾取道具</h2><p>&amp;emsp;&amp;emsp;编写完控制可拾取道具的脚本之后，我们开始制作可拾取道具。首先，我们需要将<code>Assets\Sprites\Props</code>文件夹下的<code>prop_crate_ammo</code>和<code>prop_crate_health</code>图片的<code>Pixel Per Unit</code>都调整为<code>200</code>创建完之后，我们复制场景中的<code>Parachute</code>物体，并将<code>Parachute</code>物体重命名为<code>MedicalBoxPickup</code>，将复制得到的<code>Parachute(1)</code>物体重名为<code>AmmunitionBoxPickup</code>。接着，我们在<code>Assets\Prefabs</code>文件夹下新建一个名为<code>Props</code>的文件夹，用于保存<code>可拾取道具</code>的Prefab。最后，<code>可拾取道具</code>不应该跟怪物产生交互，因此我们还需要新建一个名为<code>Pickup</code>的<code>Layer</code>，并在<code>Layer Collision Matrix</code>中取消<code>Enemy-Pickup</code>和<code>Setting-Pickup</code>这两项的勾选：</p><blockquote><p><img src="https://github.com/AsanCai/BlogImage/raw/master/PotatoGloryTutorial/Essay17/Image2.png" alt="Layer Collision Matrix"></p></blockquote><p>&amp;emsp;&amp;emsp;做完这些准备工作之后，我们先来制作<code>医疗箱</code>这一可拾取道具：</p><blockquote><p><code>医疗箱</code>制作步骤如下：</p></blockquote><ol><li>将<code>Assets\Sprites\Props</code>文件夹下的<code>prop_crate_health</code>拖拽至<code>MedicalBoxPickup</code>物体成为其子物体</li><li>修改<code>prop_crate_health</code>物体的<code>Position</code>为<code>(0.2, -0.7, 0)</code></li><li>将<code>prop_crate_health</code>物体上<code>SpriteRenderer</code>组件的<code>Sorting Layer</code>设置为<code>Foreground</code>，<code>Order In Layer</code>设置为<code>0</code></li><li>为<code>prop_crate_health</code>物体添加<code>MedicalBoxPickup.cs</code>，设置<code>Heal Amount</code>为<code>50</code>，<code>Pickup Effect</code>为<code>Assets\Audio\FX</code>下的<code>healthPickup</code></li><li>将<code>prop_crate_health</code>物体上<code>BoxCollider2D</code>组件的<code>Offset</code>设置为<code>(-0.2, 0)</code>，<code>Size</code>设置为<code>(1.8, 1.4)</code></li><li>将<code>prop_crate_health</code>物体上<code>CircleCollider2D</code>组件的<code>Offset</code>设置为<code>(-0.2, 0)</code>，<code>Radius</code>设置为<code>1.4</code>，并勾选<code>Is Trigger</code></li><li>将<code>MedicalBoxPickup</code>物体的<code>Layer</code>设置为<code>Pickup</code>，并选择<code>Yes, change children</code>将子物体的<code>Layer</code>也设置为<code>Pickup</code></li><li>将<code>MedicalBoxPickup</code>物体拖拽至<code>Assets\Prefabs\Props</code>文件夹下，将其制作为Prefab，并删除场景中的<code>MedicalBoxPickup</code>物体</li></ol><p>&amp;emsp;&amp;emsp;<code>医疗箱</code>制作完毕之后，我们继续制作<code>弹药箱</code>：</p><blockquote><p><code>弹药箱</code>制作步骤如下：</p></blockquote><ol><li>将<code>Assets\Sprites\Props</code>文件夹下的<code>prop_crate_ammo</code>拖拽至<code>AmmunitionBoxPickup</code>物体成为其子物体</li><li>修改<code>prop_crate_ammo</code>物体的<code>Position</code>为<code>(-0.1, -0.65, 0)</code></li><li>将<code>prop_crate_ammo</code>物体上<code>SpriteRenderer</code>组件的<code>Sorting Layer</code>设置为<code>Foreground</code>，<code>Order In Layer</code>设置为<code>0</code></li><li>为<code>prop_crate_ammo</code>物体添加<code>AmmunitionBoxPickup.cs</code>，设置<code>Bomb Amount</code>为<code>2</code>，<code>Pickup Effect</code>为<code>Assets\Audio\FX</code>下的<code>bombCollect</code></li><li>将<code>prop_crate_ammo</code>物体上<code>BoxCollider2D</code>组件的<code>Offset</code>设置为<code>(0, -0.05)</code>，<code>Size</code>设置为<code>(1.84, 1.25)</code></li><li>将<code>prop_crate_ammo</code>物体上<code>CircleCollider2D</code>组件的<code>Offset</code>设置为<code>(0, 0)</code>，<code>Radius</code>设置为<code>1.4</code>，并勾选<code>Is Trigger</code></li><li>将<code>AmmunitionBoxPickup</code>物体的<code>Layer</code>设置为<code>Pickup</code>，并选择<code>Yes, change children</code>将子物体的<code>Layer</code>也设置为<code>Pickup</code></li><li>新建一个名为<code>AmmunitionBox</code>的<code>Tag</code>，将<code>prop_crate_ammo</code>物体的<code>Tag</code>设置为<code>AmmunitionBox</code></li><li>为<code>prop_crate_ammo</code>物体添加<code>Bomb.cs</code>，并修改其属性如下：<blockquote><blockquote><p><code>Bomb.cs</code>的属性</p></blockquote></blockquote><ul><li><code>DamageAmount</code>: 50</li><li><code>BombRadius</code>: 10</li><li><code>BombForce</code>: 800</li><li><code>BoomClip</code>: <code>Assets\Audio\FX</code>下的<code>bigboom</code></li><li><code>FuseTime</code>: 1.5f</li><li><code>FuseClip</code>: <code>Assets\Audio\FX</code>下的<code>bombfuse</code></li></ul></li><li>将<code>AmmunitionBoxPickup</code>物体拖拽至<code>Assets\Prefabs\Props</code>文件夹下，将其制作为Prefab，并删除场景中的<code>AmmunitionBoxPickup</code>物体</li></ol><p>&amp;emsp;&amp;emsp;<code>弹药箱</code>制作完毕之后，为了能让<code>弹药箱</code>被<code>导弹</code>击中之后直接引爆，我们需要修改<code>Missile.cs</code>的<code>OnTriggerEnter2D</code>函数：</p><figure class="highlight csharp"><figcaption><span>Missile.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br>[<span class="hljs-meta">RequireComponent(typeof(Rigidbody2D))</span>]<br>[<span class="hljs-meta">RequireComponent(typeof(CapsuleCollider2D))</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Missile</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br>    ...<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnTriggerEnter2D</span>(<span class="hljs-params">Collider2D collider</span>)</span> &#123;<br>        <span class="hljs-comment">// 不对角色产生任何操作</span><br>        <span class="hljs-keyword">if</span>(collider.CompareTag(<span class="hljs-string">&quot;Player&quot;</span>)) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 引爆弹药箱</span><br>        <span class="hljs-keyword">if</span>(collider.tag == <span class="hljs-string">&quot;AmmunitionBox&quot;</span>) &#123;<br>            collider.GetComponent&lt;Bomb&gt;().Explode();<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 对怪物造成伤害</span><br>        <span class="hljs-keyword">if</span>(collider.CompareTag(<span class="hljs-string">&quot;Enemy&quot;</span>)) &#123;<br>            collider.GetComponent&lt;Enemy&gt;().TakeDamage(<span class="hljs-keyword">this</span>.transform, HurtForce, DamageAmount);<br>        &#125;<br><br>        OnExplode();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;最后，如果<code>弹药箱</code>在降落过程中被引爆，那么我们需要直接销毁整个降落伞，所以我们还需要修改<code>Bomb.cs</code>的<code>Explode</code>函数</p><figure class="highlight csharp"><figcaption><span>Bomb.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br>[<span class="hljs-meta">RequireComponent(typeof(AudioSource))</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Bomb</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br>    ...<br><br>    <span class="hljs-comment">// 爆炸函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Explode</span>()</span> &#123;<br>        <span class="hljs-comment">// 获取一定范围内的所有Layer为Enemy或者Player物体</span><br>        Collider2D[] objects = Physics2D.OverlapCircleAll(transform.position, BombRadius, m_LayerMask);<br><br>        <span class="hljs-keyword">foreach</span>(Collider2D obj <span class="hljs-keyword">in</span> objects) &#123;<br>            <span class="hljs-comment">// 对怪物造成伤害</span><br>            <span class="hljs-keyword">if</span>(obj.tag == <span class="hljs-string">&quot;Enemy&quot;</span>) &#123;<br>                obj.GetComponent&lt;Enemy&gt;().TakeDamage(<span class="hljs-keyword">this</span>.transform, BombForce, DamageAmount);<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// 对角色造成伤害</span><br>            <span class="hljs-keyword">if</span>(obj.CompareTag(<span class="hljs-string">&quot;Player&quot;</span>)) &#123;<br>                obj.GetComponent&lt;PlayerHealth&gt;().TakeDamage(<span class="hljs-keyword">this</span>.transform, BombForce, DamageAmount);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 实例化爆炸特效</span><br>        <span class="hljs-keyword">if</span>(BombExplosion != <span class="hljs-literal">null</span>) &#123;<br>            Instantiate(BombExplosion, <span class="hljs-keyword">this</span>.transform.position, Quaternion.identity);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            Debug.LogWarning(<span class="hljs-string">&quot;请设置BombExplosion&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 播放爆炸音效</span><br>        <span class="hljs-keyword">if</span>(BoomClip != <span class="hljs-literal">null</span>) &#123;<br>            AudioSource.PlayClipAtPoint(BoomClip, transform.position);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            Debug.LogWarning(<span class="hljs-string">&quot;请设置BoomClip&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 直接删除父物体</span><br>        Destroy(transform.root.gameObject);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="生成可拾取道具"><a href="#生成可拾取道具" class="headerlink" title="生成可拾取道具"></a>生成可拾取道具</h2><p>&amp;emsp;&amp;emsp;最后，我们还需要使用<code>Generator</code>来生成我们制作好的可交互道具。首先，我们在<code>Hierarchy</code>窗口的<code>Generator</code>物体下创建一个名为<code>PickupGenerators</code>的<code>Empty GameObject</code>。接着，我们在<code>PickupGenerators</code>物体下创建一个名为<code>PickupGenerator</code>的<code>Empty GameObject</code>，并为<code>PickupGenerator</code>物体添加<code>Generator.cs</code>组件。</p><blockquote><p><code>PickupGenerator</code>的设置如下：</p></blockquote><ul><li><code>Position</code>: (-10, 20, 0)</li><li><code>Generate Delay</code>: 5</li><li><code>Generate Interval</code>: 10</li><li><code>Prefab Orientation</code>: None</li><li><code>Prefabs</code>:<ul><li><code>Element0</code>: <code>Assets\Prefabs\Props</code>文件夹下的<code>AmmunitionBoxPickup</code>物体的Prefab</li><li><code>Element1</code>: <code>Assets\Prefabs\Props</code>文件夹下的<code>MedicalBoxPickup</code>物体的Prefab</li></ul></li></ul><p>&amp;emsp;&amp;emsp;编辑完之后，我们将<code>PickupGenerator</code>物体拖拽至<code>Assets\Prefabs\Generators</code>文件夹下将其制作为Prefab。然后复制场景中已经成为实例对象的<code>PickupGenerator</code>物体得到<code>PickupGenerator (1)</code>物体，并将<code>PickupGenerator (1)</code>物体的<code>Position</code>修改为<code>(10, 20, 0)</code>。运行游戏，我们可以看到此时游戏中已经能不断随机生成<code>弹药箱</code>和<code>医疗箱</code>。</p><hr><h2 id="后言"><a href="#后言" class="headerlink" title="后言"></a>后言</h2><p>&amp;emsp;&amp;emsp;至此，我们已经完成了<code>随机生成可交互道具</code>的功能。最后，本篇文章所做的修改，可以在<a href="https://github.com/AsanCai/PotatoGloryTutorial">PotatoGloryTutorial</a>这个仓库的<code>essay15</code>分支下看到，读者可以clone这个仓库到本地进行查看。</p>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
      <category>《土豆荣耀》</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《土豆荣耀》重构笔记（十六）随机生成不可交互物体</title>
    <link href="/posts/c462f027/"/>
    <url>/posts/c462f027/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&amp;emsp;&amp;emsp;在<a href="https://asancai.github.io/tutorial/potato-glory/PotatoGloryTutorial-4/">前面的文章</a>中，我们提到，<code>为了不让游戏背景那么一成不变，显得更有动感一点，我们通常需要加入一些不能与游戏内的元素发生交互的背景动画</code>。但有一些作为背景动画的物体<code>并不是在进行重复运动的</code>，我们不能简单地为制作循环播放的动画，而是要<code>使用Generator随机生成它们</code>。</p><hr><h2 id="制作不可交互物体的动画"><a href="#制作不可交互物体的动画" class="headerlink" title="制作不可交互物体的动画"></a>制作不可交互物体的动画</h2><p>&amp;emsp;&amp;emsp;在游戏里，一共有<code>移动的出租车</code>、<code>移动的巴士</code>和<code>飞翔的天鹅</code>这三种不可交互的物体，我们先来制作<code>出租车</code>的动画。</p><blockquote><p><code>出租车</code>动画的制作步骤如下：</p></blockquote><ol><li>将<code>Assets\Sprites\Props</code>下<code>Cab</code>图片切割得到的<code>Cab</code>拖拽到游戏场景中，接着设置<code>SpriteRenderer</code>组件的<code>Sorting Layer</code>为<code>Background</code>，并设置<code>Order In Layer</code>为<code>3</code></li><li>将<code>Cab</code>图片切割得到的<code>Wheels</code>拖拽到游戏场景中的<code>Cab</code>物体下成为其子物体，接着设置<code>Wheels</code>的Position为<code>(0, -0.8, 0)</code>，然后设置<code>SpriteRenderer</code>组件的<code>Sorting Layer</code>为<code>Background</code>，并设置<code>Order In Layer</code>为<code>4</code></li><li>打开<code>Animation</code>窗口，选中<code>Cab</code>物体，然后点击<code>Create</code>创建一个名为<code>Cab.anim</code>的动画文件，并将其保存在<code>Assets\Animation\Environment</code>文件夹下</li><li>将<code>Assets\Animation\Environment</code>文件夹下的<code>Cab.controller</code>移动到<code>Assets\Animator\Environment</code>文件夹下</li><li>点击<code>Animation</code>窗口的<code>红点按钮</code>，开始为<code>Cab.anim</code>添加关键帧，添加的关键帧信息如下：<blockquote><blockquote><p><code>Cab.anim</code>的关键帧：</p></blockquote></blockquote><ol><li><code>第一帧</code>：<ul><li><code>frame</code>: 0</li><li><code>Cab：Rotaition</code>: (0, 0, 0)</li><li><code>Wheels：Position</code>: (0, -0.8, 0)</li></ul></li><li><code>第二帧</code>：<ul><li><code>frame</code>: 20</li><li><code>Cab：Rotaition</code>: (0, 0, -2.75)</li><li><code>Wheels：Position</code>: (0, -0.85, 0)</li></ul></li><li><code>第三帧</code>：<ul><li><code>frame</code>: 30</li><li><code>Cab：Rotaition</code>: (0, 0, -3.5)</li><li><code>Wheels：Position</code>: (0, -0.88, 0)</li></ul></li><li><code>第四帧</code>：<ul><li><code>frame</code>: 40</li><li><code>Cab：Rotaition</code>: (0, 0, -2.1)</li><li><code>Wheels：Position</code>: (0, -0.82, 0)</li></ul></li><li><code>第五帧</code>：<ul><li><code>frame</code>: 60</li><li><code>Cab：Rotaition</code>: (0, 0, 0)</li><li><code>Wheels：Position</code>: (0, -0.8, 0)</li></ul></li></ol></li><li>为<code>Cab</code>物体添加<code>Wander.cs</code>，然后取消<code>Facing Right</code>的勾选，并设置<code>Moving Speed</code>为<code>5</code></li><li>将<code>Rigidbody2D</code>组件的<code>Body Type</code>设置为<code>Kinematic</code></li><li>为<code>Cab</code>物体添加<code>Destroyer.cs</code>，勾选<code>Destroy On Awake</code>，并设置<code>Awake Destroy Delay</code>为<code>10</code><blockquote><p><img src="https://github.com/AsanCai/BlogImage/raw/master/PotatoGloryTutorial/Essay16/Image1.png" alt="Cab物体的组件"></p></blockquote></li><li>将<code>Cab</code>物体拖拽至<code>Assets\Prefabs\Environment</code>文件夹下将其制作为Prefab，并删除场景中的<code>Cab</code>物体</li></ol><p>&amp;emsp;&amp;emsp;制作好<code>出租车</code>的动画，接下来我们开始制作<code>巴士</code>的动画。</p><blockquote><p><code>巴士</code>动画的制作步骤如下：</p></blockquote><ol><li>将<code>Assets\Sprites\Props</code>下<code>Bus</code>图片切割得到的<code>Bus</code>拖拽到游戏场景中，接着设置<code>SpriteRenderer</code>组件的<code>Sorting Layer</code>为<code>Background</code>，并设置<code>Order In Layer</code>为<code>5</code></li><li>将<code>Cab</code>图片切割得到的<code>Wheels</code>拖拽到游戏场景中的<code>Bus</code>物体下成为其子物体，接着设置<code>Wheels</code>的Position为<code>(-0.1, -1.67, 0)</code>，然后设置<code>SpriteRenderer</code>组件的<code>Sorting Layer</code>为<code>Background</code>，并设置<code>Order In Layer</code>为<code>6</code></li><li>打开<code>Animation</code>窗口，选中<code>Bus</code>物体，然后点击<code>Create</code>创建一个名为<code>Bus.anim</code>的动画文件，并将其保存在<code>Assets\Animation\Environment</code>文件夹下</li><li>将<code>Assets\Animation\Environment</code>文件夹下的<code>Bus.controller</code>移动到<code>Assets\Animator\Environment</code>文件夹下</li><li>点击<code>Animation</code>窗口的<code>红点按钮</code>，开始为<code>Bus.anim</code>添加关键帧，添加的关键帧信息如下：<blockquote><blockquote><p><code>Bus.anim</code>的关键帧：</p></blockquote></blockquote><ol><li><code>第一帧</code>：<ul><li><code>frame</code>: 0</li><li><code>Cab：Rotaition</code>: (0, 0, 0)</li><li><code>Wheels：Position</code>: (-0.1, -1.67, 0)</li></ul></li><li><code>第二帧</code>：<ul><li><code>frame</code>: 20</li><li><code>Cab：Rotaition</code>: (0, 0, 1.58)</li><li><code>Wheels：Position</code>: (-0.1, -1.71, 0)</li></ul></li><li><code>第三帧</code>：<ul><li><code>frame</code>: 30</li><li><code>Cab：Rotaition</code>: (0, 0, 2.5)</li><li><code>Wheels：Position</code>: (0, -1.75, 0)</li></ul></li><li><code>第四帧</code>：<ul><li><code>frame</code>: 40</li><li><code>Cab：Rotaition</code>: (0, 0, 1.73)</li><li><code>Wheels：Position</code>: (0, -1.69, 0)</li></ul></li><li><code>第五帧</code>：<ul><li><code>frame</code>: 60</li><li><code>Cab：Rotaition</code>: (0, 0, 0)</li><li><code>Wheels：Position</code>: (-0.1, -1.67, 0)</li></ul></li></ol></li><li>为<code>Bus</code>物体添加<code>Wander.cs</code>，然后取消<code>Facing Right</code>的勾选，并设置<code>Moving Speed</code>为<code>3.5</code></li><li>将<code>Rigidbody2D</code>组件的<code>Body Type</code>设置为<code>Kinematic</code></li><li>为<code>Bus</code>物体添加<code>Destroyer.cs</code>，勾选<code>Destroy On Awake</code>，并设置<code>Awake Destroy Delay</code>为<code>14</code><br> <img src="https://github.com/AsanCai/BlogImage/raw/master/PotatoGloryTutorial/Essay16/Image2.png" alt="Bus物体的组件"></li><li>将<code>Bus</code>物体拖拽至<code>Assets\Prefabs\Environment</code>文件夹下将其制作为Prefab，并删除场景中的<code>Bus</code>物体</li></ol><p>&amp;emsp;&amp;emsp;制作好<code>巴士</code>的动画之后，接下来我们开始制作<code>天鹅</code>的动画。</p><blockquote><p><code>天鹅</code>动画的制作步骤如下：</p></blockquote><ol><li>在<code>Hierarchy</code>窗口中创建一个名为<code>Swan</code>的<code>Empty GameObject</code></li><li>选中<code>Assets\Sprites\Props</code>下<code>swan_Sheet</code>图片切割得到的所有图片，然后将它们都拖拽到<code>Swan</code>物体上，接着将Unity自动创建的动画文件命名为<code>Swan.anim</code>，并将其保存在<code>Assets\Animation\Environment</code>文件夹下</li><li>将<code>Assets\Animation\Environment</code>文件夹下的<code>Swan.controller</code>移动到<code>Assets\Animator\Environment</code>文件夹下</li><li>设置<code>Swan</code>物体的<code>SpriteRenderer</code>组件的<code>Sprite</code>为<code>swan_Sheet</code>图片切割得到的<code>Swan_Sheet1_0</code>，然后设置其<code>Sorting Layer</code>为<code>Background</code>，并设置<code>Order In Layer</code>为<code>7</code></li><li>为<code>Swan</code>物体添加<code>Wander.cs</code>，然后取消<code>Facing Right</code>的勾选，并设置<code>Moving Speed</code>为<code>5.5</code></li><li>因为天鹅能往上飞，所以我们需要将<code>Swan</code>物体的<code>Rigidbody2D</code>组件的<code>Gravity Scale</code>设置为<code>-0.04</code></li><li>为<code>Swan</code>物体添加<code>Destroyer.cs</code>，勾选<code>Destroy On Awake</code>，并设置<code>Awake Destroy Delay</code>为<code>10</code><br> <img src="https://github.com/AsanCai/BlogImage/raw/master/PotatoGloryTutorial/Essay16/Image3.png" alt="Swan物体的组件"></li><li>将<code>Swan</code>物体拖拽至<code>Assets\Prefabs\Environment</code>文件夹下将其制作为Prefab，并删除场景中的<code>Swan</code>物体</li></ol><hr><h2 id="生成不可交互物体"><a href="#生成不可交互物体" class="headerlink" title="生成不可交互物体"></a>生成不可交互物体</h2><p>&amp;emsp;&amp;emsp;制作好<code>Cab</code>、<code>Bus</code>和<code>Swan</code>的Prefab之后，接下来，我们开始制作能实例化这些Prefab的<code>Generator</code>。首先，我们在<code>Hierarchy</code>窗口的<code>Generator</code>物体下创建一个名为<code>Non-interactiveObjectGenerators</code>的<code>Empty GameObject</code>。接着，我们在<code>Non-interactiveObjectGenerators</code>物体下创建<code>CabGenerator</code>、<code>BusGenerator</code>和<code>SwanGenerator</code>三个<code>Empty GameObject</code>，并为它们添加<code>Generator.cs</code>组件。</p><blockquote><p>各个Generator的设置如下：</p></blockquote><ul><li><code>CabGenerator</code>：<ul><li><code>Position</code>: (-22, -8.5, 0)</li><li><code>Generate Delay</code>: 3</li><li><code>Generate Interval</code>: 12</li><li><code>Prefab Orientation</code>: Right</li><li><code>Prefabs</code>:<ul><li><code>Element0</code>: <code>Assets\Prefabs\Environment</code>文件夹下的<code>Cab</code>物体的Prefab</li></ul></li></ul></li><li><code>BusGenerator</code>：<ul><li><code>Position</code>: (-22, -7.65, 0)</li><li><code>Generate Delay</code>: 8</li><li><code>Generate Interval</code>: 14</li><li><code>Prefab Orientation</code>: Right</li><li><code>Prefabs</code>:<ul><li><code>Element0</code>: <code>Assets\Prefabs\Environment</code>文件夹下的<code>Bus</code>物体的Prefab</li></ul></li></ul></li><li><code>SwanGenerator</code>：<ul><li><code>Position</code>: (-24, -3.2, 0)</li><li><code>Generate Delay</code>: 2</li><li><code>Generate Interval</code>: 10</li><li><code>Prefab Orientation</code>: Right</li><li><code>Prefabs</code>:<ul><li><code>Element0</code>: <code>Assets\Prefabs\Environment</code>文件夹下的<code>Swan</code>物体的Prefab</li></ul></li></ul></li></ul><p>&amp;emsp;&amp;emsp;运行游戏，可以看到此时我们已经能产生<code>从左到右运动</code>的物体，接下来我们还需要产生能<code>从右到左运动</code>的物体。首先，我们将<code>CabGenerator</code>、<code>BusGenerator</code>和<code>SwanGenerator</code>分别拖拽至<code>Assets\Prefabs\Generators</code>下将它们制作为Prefab。接着，我们分别复制<code>Non-interactiveObjectGenerators</code>物体下已经成为Prefab的<code>实例对象</code>的<code>CabGenerator</code>、<code>BusGenerator</code>和<code>SwanGenerator</code>子物体。</p><blockquote><p>各个复制得到的Generator的设置如下：</p></blockquote><ul><li><code>CabGenerator(1)</code>：<ul><li><code>Position</code>: (22, -8.5, 0)</li><li><code>Generate Delay</code>: 15</li><li><code>Generate Interval</code>: 12</li><li><code>Prefab Orientation</code>: Left</li><li><code>Prefabs</code>:<ul><li><code>Element0</code>: <code>Assets\Prefabs\Environment</code>文件夹下的<code>Cab</code>物体的Prefab</li></ul></li></ul></li><li><code>BusGenerator(1)</code>：<ul><li><code>Position</code>: (22, -7.65, 0)</li><li><code>Generate Delay</code>: 18</li><li><code>Generate Interval</code>: 14</li><li><code>Prefab Orientation</code>: Left</li><li><code>Prefabs</code>:<ul><li><code>Element0</code>: <code>Assets\Prefabs\Environment</code>文件夹下的<code>Bus</code>物体的Prefab</li></ul></li></ul></li><li><code>SwanGenerator(1)</code>：<ul><li><code>Position</code>: (24, -0.1, 0)</li><li><code>Generate Delay</code>: 2</li><li><code>Generate Interval</code>: 10</li><li><code>Prefab Orientation</code>: Left</li><li><code>Prefabs</code>:<ul><li><code>Element0</code>: <code>Assets\Prefabs\Environment</code>文件夹下的<code>Swan</code>物体的Prefab</li></ul></li></ul></li></ul><p>&amp;emsp;&amp;emsp;再次运行游戏，可以看到此时我们已经能产生<code>从右到左运动</code>的物体。</p><hr><h2 id="后言"><a href="#后言" class="headerlink" title="后言"></a>后言</h2><p>&amp;emsp;&amp;emsp;至此，我们已经完成了<code>随机生成不可交互物体</code>的功能。最后，本篇文章所做的修改，可以在<a href="https://github.com/AsanCai/PotatoGloryTutorial">PotatoGloryTutorial</a>这个仓库的<code>essay14</code>分支下看到，读者可以clone这个仓库到本地进行查看。</p>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
      <category>《土豆荣耀》</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《土豆荣耀》重构笔记（十五）实现角色和怪物掉入河中被销毁的功能</title>
    <link href="/posts/626aa160/"/>
    <url>/posts/626aa160/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&amp;emsp;&amp;emsp;我们在<a href="https://asancai.github.io/tutorial/potato-glory/PotatoGloryTutorial-14/">上篇文章</a>中已经实现随机生成更多怪物的功能，但怪物和角色死亡时，并不会被销毁。当生成的怪物增多时，这会占用大量游戏内存。为了节约内存，我们需要实现角色和怪物掉入河中就会在游戏场景中被销毁的功能。</p><hr><h2 id="制作浪花溅起的动画"><a href="#制作浪花溅起的动画" class="headerlink" title="制作浪花溅起的动画"></a>制作浪花溅起的动画</h2><p>&amp;emsp;&amp;emsp;角色和怪物掉入河中之后，应该溅起浪花，所以我们需要先制作<code>浪花溅起</code>的动画。</p><blockquote><p>制作<code>浪花溅起</code>的动画的步骤：</p></blockquote><ol><li>同时选中<code>Assets\Sprites\FX</code>下<code>splash</code>切割出来的所有图片，然后将他们拖拽到<code>Hierarchy</code>窗口</li><li>将新创建的动画保存至<code>Assets\Animation\Environment</code>，并将其命名为<code>SplashingSpray.anim</code></li><li>将<code>Assets\Animation\Environment</code>文件夹下的<code>splash_0.controller</code>重命名为<code>Splash.controller</code>，并将其移至<code>Assets\Animator\Environment</code>文件夹</li><li>将场景中的<code>splash_0</code>物体重命名为<code>Splash</code>，并为其添加<code>Assets\Scripts\Utility</code>文件夹下的<code>Destroyer.cs</code></li><li>打开<code>Animation Editor</code>，选中<code>Hierarchy</code>窗口中的<code>Splash</code>物体，然后在最后一帧处添加一个<code>Animation Event</code>，选择调用的函数为<code>DestroyGameObject</code></li><li>将<code>Splash</code>物体上<code>Sprite Renderer</code>组件的<code>Sorting Layer</code>设置为<code>Foreground</code></li><li>为<code>Splash</code>物体添加一个<code>AudioSource</code>组件，然后设置<code>AudioClip</code>为<code>Assets\Audio\FX</code>下的<code>waterSplash</code></li><li>在<code>Assets\Prefabs</code>文件夹下新建一个名为<code>Environment</code>的文件夹，然后将<code>Splash</code>物体拖拽至<code>Assets\Prefabs\Environment</code>下，将其做成Prefab</li><li>删除场景中的<code>Splash</code>物体</li></ol><p>&amp;emsp;&amp;emsp;至此，我们<code>浪花溅起</code>的动画就制作好了。</p><p><img src="https://github.com/AsanCai/BlogImage/raw/master/PotatoGloryTutorial/Essay15/Image1.png" alt="Splash的组件"></p><hr><h2 id="制作RiverTrigger"><a href="#制作RiverTrigger" class="headerlink" title="制作RiverTrigger"></a>制作RiverTrigger</h2><p>&amp;emsp;&amp;emsp;接下来，我们开始实现角色和怪物掉入河中被销毁，并溅起浪花的功能。首先，我们创建一个名为<code>RiverTrigger</code>的<code>Empty GameObject</code>。接着，我们在<code>Assets\Scripts\Utility</code>下创建一个名为<code>Remover</code>的C#脚本，并编辑<code>Remover.cs</code>如下：</p><figure class="highlight csharp"><figcaption><span>Remover.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br>[<span class="hljs-meta">RequireComponent(typeof(BoxCollider2D))</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Remover</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;浪花预设&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> GameObject SplashPrefab;<br><br>    <span class="hljs-keyword">private</span> BoxCollider2D m_Trigger;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Awake</span>()</span> &#123;<br>        <span class="hljs-comment">// 获取引用</span><br>        m_Trigger = GetComponent&lt;BoxCollider2D&gt;();<br>        <span class="hljs-comment">// 确保已经被设置为Trigger</span><br>        m_Trigger.isTrigger = <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnTriggerEnter2D</span>(<span class="hljs-params">Collider2D collision</span>)</span> &#123;<br>        <span class="hljs-comment">// 实例化水花对象，水花对象会自动播放声音和动画</span><br>        Instantiate(SplashPrefab, collision.transform.position, transform.rotation);<br>        <span class="hljs-comment">// 销毁掉下去的物体</span><br>        Destroy(collision.gameObject);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;编辑完<code>Remover.cs</code>之后，我们将<code>Remover.cs</code>添加到<code>RiverTrigger</code>物体上，可以看到Unity自动帮我们添加了一个<code>BoxCollider2D</code>组件。</p><blockquote><p><code>RiverTrigger</code>的组件设置如下：</p></blockquote><ul><li><code>Transform</code>:<ul><li><code>Position</code>: (0, -19.6, 0)</li></ul></li><li><code>Remover.cs</code>:<ul><li><code>Splash Prefab</code>: <code>Assets\Prefabs\Environment</code>下<code>Splash</code>物体的Prefab</li></ul></li><li><code>BoxCollider2D</code>:<ul><li><code>Is Trigger</code>: true</li><li><code>Size</code>: (100, 10)</li></ul></li></ul><p>&amp;emsp;&amp;emsp;设置完成之后，保存场景，运行游戏，可以看到此时怪物掉进河中会从场景中被销毁，且会产生<code>浪花溅起</code>的动画，并播放<code>浪花溅起</code>的音效。</p><p><img src="https://github.com/AsanCai/BlogImage/raw/master/PotatoGloryTutorial/Essay15/Image1.png" alt="RiverTrigger的组件"></p><hr><h2 id="一些小调整"><a href="#一些小调整" class="headerlink" title="一些小调整"></a>一些小调整</h2><p>&amp;emsp;&amp;emsp;此时，我们发现摄像机位置太靠上，只能看到河流的一小部分，基本看不到怪物和角色掉入河中时产生的浪花。我们需要<code>增大摄像机的可移动范围</code>，其调整的步骤如下：</p><blockquote><p><code>增大摄像机的可移动范围</code>的步骤：</p></blockquote><ol><li>选中场景中的<code>SceneBounds</code>物体</li><li>修改其<code>BoxCollider2D</code>组件的<code>Offset</code>为<code>(0, -2.5)</code></li><li>修改其<code>BoxCollider2D</code>组件的<code>Size</code>为<code>(48, 32)</code></li></ol><p>&amp;emsp;&amp;emsp;此外，在游戏运行的过程中，我们发现当<code>AlienSlug</code>和<code>AlieShip</code>重合或者<code>AlienSlug</code>和<code>AlienSlug</code>重合时，会出现<code>AlienSlug</code>的眼球被<code>AlienSlug</code>遮挡的问题，我们需要调整<code>AlieShip</code>的子物体<code>char_enemy_alienShip</code>上<code>Sprite Renderer</code>组件的<code>Order In Layer</code>组件属性设置为<code>2</code>。</p><p>&amp;emsp;&amp;emsp;最后，因为导弹在爆炸时，爆炸的特效被建筑物遮挡了，我们需要将<code>Assets\Prefabs\Weapons</code>下<code>MissileExplosion</code>的Prefab上<code>Sprite Renderer</code>组件的<code>Sorting Layer</code>设置为<code>Weapons</code>。</p><hr><h2 id="后言"><a href="#后言" class="headerlink" title="后言"></a>后言</h2><p>&amp;emsp;&amp;emsp;调整好之后，运行游戏，可以看到此时问题都被修复了。至此，我们已经完成了实现角色和怪物掉入河中被销毁的功能。最后，本篇文章所做的修改，可以在<a href="https://github.com/AsanCai/PotatoGloryTutorial">PotatoGloryTutorial</a>这个仓库的<code>essay13</code>分支下看到，读者可以clone这个仓库到本地进行查看。</p>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
      <category>《土豆荣耀》</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《土豆荣耀》重构笔记（十四）随机生成更多的怪物</title>
    <link href="/posts/c1848c93/"/>
    <url>/posts/c1848c93/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&amp;emsp;&amp;emsp;到目前为止，我们的游戏场景里面只有两个怪物。为了让游戏更有挑战，我们需要在游戏运行时<code>每隔一段时间</code>就随机生成一个新的怪物。接下来，我们开始实现随机生成更多怪物的功能。</p><hr><h2 id="制作Generator"><a href="#制作Generator" class="headerlink" title="制作Generator"></a>制作Generator</h2><p>&amp;emsp;&amp;emsp;为了能在场景中随机生成更多的怪物，我们需要有一个<code>Generator</code>在场景中不断实例化我们已经做好的怪物Prefab。首先，我们在<code>Assets\Scripts\Utility</code>文件夹下创建一个名为<code>Generator</code>的C#脚本，然后编辑<code>Generator.cs</code>如下：</p><figure class="highlight csharp"><figcaption><span>Generator.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-comment">// 朝向</span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">enum</span> Orientation &#123;<br>    Left,<span class="hljs-comment">// 固定朝左</span><br>    Right,<span class="hljs-comment">// 固定朝右</span><br>    Random,<span class="hljs-comment">// 随机朝向</span><br>    None<span class="hljs-comment">// 不需要考虑朝向</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Generator</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;多久之后开始实例化预设对象&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> GenerateDelay = <span class="hljs-number">2f</span>;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;实例化预设对象的时间间隔&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> GenerateInterval = <span class="hljs-number">3f</span>;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;预设对象的朝向&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> Orientation PrefabOrientation = Orientation.Right;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;预设对象&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> GameObject[] Prefabs;<br><br>    <span class="hljs-keyword">private</span> ParticleSystem m_Particle;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Awake</span>()</span> &#123;<br>        <span class="hljs-comment">// 获取引用</span><br>        m_Particle = GetComponent&lt;ParticleSystem&gt;();<br><br>        <span class="hljs-keyword">if</span>(Prefabs == <span class="hljs-literal">null</span> || Prefabs.Length == <span class="hljs-number">0</span>) &#123;<br>            Debug.LogError(<span class="hljs-string">&quot;请至少为Prefabs添加一个预设对象&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Start</span> ()</span> &#123;<br>        <span class="hljs-comment">// GenerateDelay秒之后第一次调用Generate函数，然后每隔GenerateInterval调用Generate函数一次</span><br>        InvokeRepeating(<span class="hljs-string">&quot;Generate&quot;</span>, GenerateDelay, GenerateInterval);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Generate</span>()</span> &#123;<br>        <span class="hljs-comment">// 随机选择一个预设进行生成</span><br>        <span class="hljs-built_in">int</span> index = Random.Range(<span class="hljs-number">0</span>, Prefabs.Length);<br><br>        <span class="hljs-comment">// 实例化预设对象</span><br>        GameObject prefab = Instantiate(Prefabs[index], transform.position, Quaternion.identity);<br><br>        <span class="hljs-comment">// 播放粒子特效</span><br>        <span class="hljs-keyword">if</span>(m_Particle != <span class="hljs-literal">null</span>) &#123;<br>            m_Particle.Play();<br>        &#125;<br><br>        <span class="hljs-comment">// 不需要考虑朝向</span><br>        <span class="hljs-keyword">if</span>(PrefabOrientation == Orientation.None) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(PrefabOrientation == Orientation.Left) &#123;<br>            Wander wander = prefab.GetComponent&lt;Wander&gt;();<br>            <span class="hljs-keyword">if</span>(wander.FacingRight) &#123;<br>                wander.Flip();<br>            &#125;<br>            <span class="hljs-keyword">return</span>;<br>        &#125; <br>        <br>        <span class="hljs-keyword">if</span>(PrefabOrientation == Orientation.Right) &#123;<br>            Wander wander = prefab.GetComponent&lt;Wander&gt;();<br>            <span class="hljs-keyword">if</span>(!wander.FacingRight) &#123;<br>                wander.Flip();<br>            &#125;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(PrefabOrientation == Orientation.Random) &#123;<br>            Wander wander = prefab.GetComponent&lt;Wander&gt;();<br>            <span class="hljs-comment">// 有一半的概率进行翻转</span><br>            <span class="hljs-keyword">if</span>(Random.<span class="hljs-keyword">value</span> &lt;= <span class="hljs-number">0.5</span>) &#123;<br>                wander.Flip();<br>            &#125;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>代码说明：<br>&amp;emsp;&amp;emsp;这里，我们使用<code>MonoBehaviour</code>提供的静态方法<code>InvokeRepeating</code>来实现<code>等待一段时间后每隔一定时间重复调用某个函数</code>的功能。如果我们只想实现<code>等待一段时间后调用一次某个函数</code>的功能，我们可以使用<code>MonoBehaviour</code>提供的静态方法<code>Invoke</code>来实现。</p></blockquote><p>&amp;emsp;&amp;emsp;接着，我们还需要修改<code>Assets\Scripts\Enemy</code>下的<code>Wander.cs</code>如下：</p><figure class="highlight csharp"><figcaption><span>Wander.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br>[<span class="hljs-meta">RequireComponent(typeof(Rigidbody2D))</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Wander</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;是否朝向右边&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> FacingRight = <span class="hljs-literal">true</span>;<br><br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;怪物水平移动的速度&quot;</span>)</span>]<br>    [<span class="hljs-meta">SerializeField</span>]<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">float</span> MoveSpeed = <span class="hljs-number">2f</span>;<br><br><br>    <span class="hljs-comment">//用于设置怪物对象的物理属性</span><br>    <span class="hljs-keyword">private</span> Rigidbody2D m_Rigidbody;<br>    <span class="hljs-comment">// 用于保存当前的水平移动速度</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">float</span> m_CurrentMoveSpeed;<br><br>    <span class="hljs-comment">// 获取组件引用</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Awake</span>()</span> &#123;<br>        m_Rigidbody = GetComponent&lt;Rigidbody2D&gt;();<br>    &#125;<br><br>    <span class="hljs-comment">// 设置字段的初始值</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span> &#123;<br>        <span class="hljs-keyword">if</span>(FacingRight) &#123;<br>            m_CurrentMoveSpeed = MoveSpeed;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            m_CurrentMoveSpeed = -MoveSpeed;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 执行和物理相关的代码</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">FixedUpdate</span>()</span> &#123;<br>        m_Rigidbody.velocity = <span class="hljs-keyword">new</span> Vector2(m_CurrentMoveSpeed, m_Rigidbody.velocity.y);<br>    &#125;<br><br>    <span class="hljs-comment">// 在Wander.cs脚本被禁用时被调用</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDisable</span>()</span> &#123;<br>        <span class="hljs-comment">// 设置水平方向上的速度为0</span><br>        m_Rigidbody.velocity = <span class="hljs-keyword">new</span> Vector2(<span class="hljs-number">0f</span>, m_Rigidbody.velocity.y);<br>    &#125;<br><br>    <span class="hljs-comment">// 转向函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Flip</span>()</span> &#123;<br>        FacingRight = !FacingRight;<br><br>        m_CurrentMoveSpeed *= <span class="hljs-number">-1</span>;<br>        <br>        <span class="hljs-keyword">this</span>.transform.localScale = Vector3.Scale(<span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>), <span class="hljs-keyword">this</span>.transform.localScale);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>代码说明：<br>&amp;emsp;&amp;emsp;这里，我们将<code>FacingRight</code>的可见性变为<code>public</code>，且在<code>Filp</code>方法中，我们动态地更新<code>FacingRight</code>字段的值。这是为了在生成预设时，我们能动态地决定预设被实例化之后要往那边运动。</p></blockquote><p>&amp;emsp;&amp;emsp;编辑完成之后，我们删除场景中的<code>AlienSlug</code>和<code>AlienShip</code>物体，然后新建一个名为<code>Generator</code>的<code>Empty GameObject</code>。接着，我们为<code>Generator</code>物体创建一个名为<code>EnemyGenerator</code>的<code>Empty GameObject</code>，并将<code>Generator.cs</code>添加到<code>EnemyGenerator</code>物体上。最后，我们将<code>Prefab Orientation</code>设置为<code>Random</code>，并将<code>Assets\Prefabs\Character</code>下的<code>AlienShip</code>和<code>AlienSlug</code>拖拽到<code>Prefabs</code>的赋值框，再运行游戏，我们可以看到场景中不断有随机朝向的怪物在<code>EnemyGenerator</code>的位置处产生。</p><p><img src="https://github.com/AsanCai/BlogImage/raw/master/PotatoGloryTutorial/Essay14/Image1.png" alt="设置Generator"></p><hr><h2 id="添加粒子特效"><a href="#添加粒子特效" class="headerlink" title="添加粒子特效"></a>添加粒子特效</h2><p>&amp;emsp;&amp;emsp;此时，怪物是在场景中<code>凭空出现</code>，为了在随机生成怪物时增加提示，我们为<code>EnemyGenerator</code>增加粒子特效。首先，我们为<code>EnemyGenerator</code>物体添加<code>Particle System</code>组件。</p><blockquote><p><code>EnemyGenerator</code>物体的<code>Particle System</code>组件设置：</p></blockquote><ul><li>Main Module:<ul><li><code>Looping</code>: false</li><li><code>Start Lifetime</code>: 0.7</li><li><code>Start Speed</code>: 0</li><li><code>Start Size(Random Between Two Constants)</code>: (0.9, 1)</li><li><code>Start Rotation(Random Between Two Constants)</code>: (0, 360)</li><li><code>Start Color</code>: (173, 173, 173, 255)</li><li><code>Scaling Mode</code>: Shape</li><li><code>Play On Awake</code>: false</li></ul></li><li>Emission:<ul><li><code>Rate Over Time</code>: 0</li><li><code>Brusts</code>:<ul><li><code>Element1</code>： Time(0.000), Count(1), Cycles(1), Interval(0.010)</li></ul></li></ul></li><li>Shape:<ul><li><code>Shape</code>: Sphere</li><li><code>Radius</code>: 0.01</li></ul></li><li>Color over Lifetime:<ul><li><code>Color(Gradient)</code>:<ul><li>左上角：Aplha(255), Location(78.8%)</li><li>右上角：Aplha(0), Location(100%)</li><li>左下角：Color(90, 90, 90), Location(0%)</li><li>右下角：Color(90, 90, 90), Location(100%)<br>  <img src="https://github.com/AsanCai/BlogImage/raw/master/PotatoGloryTutorial/Essay14/Image2.png" alt="Color Gradient"></li></ul></li></ul></li><li>Size over Lifetime:<ul><li><code>Size(Random Between Two Curves)</code>: <ul><li>上面是从<code>(0, 0.32)</code>到<code>(1, 1)</code>的曲线</li><li>下面是从<code>(0, 0.25)</code>到<code>(1, 0.85)</code>的曲线</li><li>纵坐标的最大值为<code>10</code></li><li>曲线的走势可以根据自己喜好调整<br>  <img src="https://github.com/AsanCai/BlogImage/raw/master/PotatoGloryTutorial/Essay14/Image3.png" alt="Size Curves"></li></ul></li></ul></li><li>Render<ul><li><code>Material</code>: <code>Assets\Materials</code>下的<code>part_star</code></li><li><code>Max Particle Size</code>: 10</li><li><code>Sorting Layer</code>: Character</li><li><code>Order In Layer</code>: 5</li></ul></li></ul><p>&amp;emsp;&amp;emsp;设置完毕之后再次运行游戏，可以看到当怪物随机生成时，会出现发光的粒子效果。至此，我们已经完成<code>EnemyGenerator</code>的制作。</p><hr><h2 id="给场景添加多个EnemyGenerator"><a href="#给场景添加多个EnemyGenerator" class="headerlink" title="给场景添加多个EnemyGenerator"></a>给场景添加多个EnemyGenerator</h2><p>&amp;emsp;&amp;emsp;<code>EnemyGenerator</code>制作完毕之后，我们要在场景里面加入多个<code>EnemyGenerator</code>。我们可以直接复制现有的<code>EnemyGenerator</code>，但如果后面我们需要对<code>EnemyGenerator</code>进行修改，那么我们就需要对所有的<code>EnemyGenerator</code>物体修改一遍，效率低下，且容易出错。</p><p>&amp;emsp;&amp;emsp;而前面提到，当我们修改Prefab的时候，Prefab在场景中的所有实例对象都会被修改，因此，我们选择将<code>EnemyGenerator</code>制作为Prefab。首先，我们在<code>Assets\Prefabs</code>下创建一个名为<code>Generators</code>的文件夹，然后将<code>EnemyGenerator</code>物体拖拽至<code>Assets\Prefabs\Generators</code>下将其制作为Prefab。接着，我们将<code>EnemyGenerator</code>的Prefab往场景里面拖拽两次，创建两个<code>EnemyGenerator</code>的Prefab实例对象。最后，我们在<code>Generator</code>物体下创建一个名为<code>EnemyGenerators</code>的<code>Empty GameObject</code>，将<code>EnemyGenerator</code>、<code>EnemyGenerator(1)</code>和<code>EnemyGenerator(2)</code>拖拽至<code>EnemyGenerators</code>下成为其子物体。</p><p><img src="https://github.com/AsanCai/BlogImage/raw/master/PotatoGloryTutorial/Essay14/Image4.png" alt="创建多个EnemyGenerator的实例对象"></p><p>&amp;emsp;&amp;emsp;当然，我们不能让怪物在场景中间生成，所以我们需要调整<code>EnemyGenerator</code>、<code>EnemyGenerator(1)</code>和<code>EnemyGenerator(2)</code>的位置。</p><blockquote><p>它们的位置信息如下：</p></blockquote><ul><li><code>EnemyGenerator</code>: Position(-15.5, 15, 0)</li><li><code>EnemyGenerator(1)</code>: Position(0, 15, 0)</li><li><code>EnemyGenerator(2)</code>: Position(15.5, 15, 0)</li></ul><p>&amp;emsp;&amp;emsp;调整完成之后，运行游戏，可以看到空中不断落下随机生成的怪物。</p><hr><h2 id="后言"><a href="#后言" class="headerlink" title="后言"></a>后言</h2><p>&amp;emsp;&amp;emsp;至此，我们已完成实现随机生成更多怪物的所有工作。本篇文章涉及到的一些数值参数，大家可以根据自己的喜好进行修改。最后，本篇文章所做的修改，可以在<a href="https://github.com/AsanCai/PotatoGloryTutorial">PotatoGloryTutorial</a>这个仓库的<code>essay12</code>分支下看到，读者可以clone这个仓库到本地进行查看。</p><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://docs.unity3d.com/Manual/Prefabs.html">Unity的Prefabs</a></li><li><a href="https://docs.unity3d.com/ScriptReference/MonoBehaviour.InvokeRepeating.html">InvokeRepeating说明</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
      <category>《土豆荣耀》</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《土豆荣耀》重构笔记（十三）实现放置炸弹的功能</title>
    <link href="/posts/7a9e2f41/"/>
    <url>/posts/7a9e2f41/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&amp;emsp;&amp;emsp;在<a href="https://asancai.github.io/tutorial/potato-glory/PotatoGloryTutorial-12/">上篇文章</a>，我们已经实现了对怪物造成伤害的功能，但此时我们只有<code>发射导弹</code>一种攻击方式。为了增加游戏的可玩性，我们将制作<code>炸弹</code>，<code>玩家可以通过放置炸弹来对范围内的怪物造成伤害</code>。在开始制作<code>炸弹</code>之前，我们先梳理一下和<code>炸弹</code>有关的需求。</p><blockquote><p>和<code>炸弹</code>有关的需求：</p></blockquote><ol><li><code>炸弹</code>会对<code>爆炸半径</code>内的<code>怪物</code>和<code>角色</code>造成<code>一定的伤害</code></li><li><code>炸弹</code>会对<code>爆炸半径</code>内的<code>怪物</code>和<code>角色</code>产生一个<code>冲击力</code></li><li><code>炸弹</code>被释放后，<code>会先燃烧一段时间引信</code>，然后再爆炸</li><li>角色可以在原地释放<code>炸弹</code>、也可以通过火箭筒向前发射<code>炸弹</code></li><li><code>炸弹</code>属于大威力道具，因此<code>炸弹</code>的放置有<code>冷却时间</code>限制，且<code>炸弹</code>的数量是有限的</li></ol><hr><h2 id="制作炸弹Prefab"><a href="#制作炸弹Prefab" class="headerlink" title="制作炸弹Prefab"></a>制作炸弹Prefab</h2><p>&amp;emsp;&amp;emsp;清楚了<code>炸弹</code>的需求之后，我们先来制作<code>炸弹</code>并实现<code>炸弹</code>爆炸对<code>怪物</code>和<code>角色</code>造成伤害的功能。首先，我们将<code>Assets\Sprites\Props</code>下的<code>prop_bomb</code>拖拽到<code>Hierarchy</code>窗口中，然后将其重命名为<code>Bomb</code>。此时，可以看到场景里面出现了一个<code>炸弹</code>，但尺寸比较大。这里，我们需要先将<code>Assets\Sprites\Props</code>下的<code>prop_bomb</code>的<code>Pixel Per Unit</code>改为<code>500</code>。</p><p><img src="https://github.com/AsanCai/BlogImage/raw/master/PotatoGloryTutorial/Essay13/Image1.png" alt="设置Pixel Per Unit"></p><p>&amp;emsp;&amp;emsp;接着，因为<code>炸弹</code>能对角色造成伤害，为了在检测时提高效率，我们不能将<code>Player</code>的<code>Layer</code>设置为<code>Default</code>，因为<code>Layer</code>为<code>Default</code>的物体很多，这会让我们增加很多不必要的判断。我们首先新建一个名为<code>Player</code>的<code>Layer</code>，然后在<code>Layer Collision Matrix</code>中取消<code>Player-Setting</code>项的勾选，不让<code>Player</code>和<code>Setting</code>这两个<code>Layer</code>的物体产生任何物理交互。最后，我们将物体<code>Player</code>的<code>Layer</code>设置为<code>Player</code>，并将其修改<code>Apply</code>至<code>Player</code>的Prefab上。</p><p><img src="https://github.com/AsanCai/BlogImage/raw/master/PotatoGloryTutorial/Essay13/Image2.png" alt="设置Layer Collision Matrix"></p><p>&amp;emsp;&amp;emsp;接着，我们在<code>Assets\Scripts\Weapons</code>新建一个名为<code>Bomb</code>的C#脚本，然后编辑<code>Bomb.cs</code>如下：</p><figure class="highlight csharp"><figcaption><span>Bomb.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br>[<span class="hljs-meta">RequireComponent(typeof(AudioSource))</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Bomb</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;炸弹产生的伤害值&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> DamageAmount = <span class="hljs-number">50f</span>;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;爆炸半径&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> BombRadius = <span class="hljs-number">10f</span>;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;爆炸时产生的冲击力&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> BombForce = <span class="hljs-number">800f</span>;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;炸弹爆炸时的音效&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> AudioClip BoomClip;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;引信燃烧的时间&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> FuseTime = <span class="hljs-number">1.5f</span>;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;燃烧引信的音效&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> AudioClip FuseClip;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;炸弹爆炸时的特效&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> GameObject BombExplosion;<br><br>    <span class="hljs-keyword">private</span> LayerMask m_LayerMask;<br>    <span class="hljs-keyword">private</span> AudioSource m_AudioSource;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Awake</span>()</span> &#123;<br>        <span class="hljs-comment">// 获取引用</span><br>        m_AudioSource = GetComponent&lt;AudioSource&gt;();<br>        <span class="hljs-comment">// 取消默认播放</span><br>        m_AudioSource.playOnAwake = <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span> &#123;<br>        <span class="hljs-comment">// 设置LayerMask检测Enemy和Player这两个Layer</span><br>        m_LayerMask = <span class="hljs-number">1</span> &lt;&lt; LayerMask.NameToLayer(<span class="hljs-string">&quot;Enemy&quot;</span>) | <span class="hljs-number">1</span> &lt;&lt; LayerMask.NameToLayer(<span class="hljs-string">&quot;Player&quot;</span>);<br><br>        <span class="hljs-keyword">if</span> (transform.root == transform)&#123;<br>            <span class="hljs-comment">// 如果不是附着在其他物体上，就开始执行燃烧引信的协程</span><br>            StartCoroutine(BombDetonation());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 燃烧引信的协程</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> IEnumerator <span class="hljs-title">BombDetonation</span>()</span> &#123;<br>        <span class="hljs-comment">// 设置燃烧引信的音效并播放</span><br>        <span class="hljs-keyword">if</span>(FuseClip != <span class="hljs-literal">null</span>) &#123;<br>            m_AudioSource.clip = FuseClip;<br>            m_AudioSource.Play();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            Debug.LogWarning(<span class="hljs-string">&quot;请设置FuseClip&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 等待FuseTime时间</span><br>        <span class="hljs-function"><span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title">WaitForSeconds</span>(<span class="hljs-params">FuseTime</span>)</span>;<br><br>        <span class="hljs-comment">// 等待FuseTime时间之后，执行爆炸函数</span><br>        Explode();<br>    &#125;<br><br>    <span class="hljs-comment">// 爆炸函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Explode</span>()</span> &#123;<br>        <span class="hljs-comment">// 获取一定范围内的所有Layer为Enemy或者Player物体</span><br>        Collider2D[] objects = Physics2D.OverlapCircleAll(transform.position, BombRadius, m_LayerMask);<br><br>        <span class="hljs-keyword">foreach</span>(Collider2D obj <span class="hljs-keyword">in</span> objects) &#123;<br>            <span class="hljs-comment">// 对怪物造成伤害</span><br>            <span class="hljs-keyword">if</span>(obj.tag == <span class="hljs-string">&quot;Enemy&quot;</span>) &#123;<br>                obj.GetComponent&lt;Enemy&gt;().TakeDamage(<span class="hljs-keyword">this</span>.transform, BombForce, DamageAmount);<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// 对角色造成伤害</span><br>            <span class="hljs-keyword">if</span>(obj.CompareTag(<span class="hljs-string">&quot;Player&quot;</span>)) &#123;<br>                obj.GetComponent&lt;PlayerHealth&gt;().TakeDamage(<span class="hljs-keyword">this</span>.transform, BombForce, DamageAmount);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 实例化爆炸特效</span><br>        <span class="hljs-keyword">if</span>(BombExplosion != <span class="hljs-literal">null</span>) &#123;<br>            Instantiate(BombExplosion, <span class="hljs-keyword">this</span>.transform.position, Quaternion.identity);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            Debug.LogWarning(<span class="hljs-string">&quot;请设置BombExplosion&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 播放爆炸音效</span><br>        <span class="hljs-keyword">if</span>(BoomClip != <span class="hljs-literal">null</span>) &#123;<br>            AudioSource.PlayClipAtPoint(BoomClip, transform.position);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            Debug.LogWarning(<span class="hljs-string">&quot;请设置BoomClip&quot;</span>);<br>        &#125;<br><br>        Destroy(gameObject);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>代码说明：</p></blockquote><ul><li><code>m_LayerMask</code>: 为了让大家能理解<code>LayerMask</code>的本质，我这里没有使用<code>LayerMask.GetMask</code>这个静态方法来获取<code>Layer Mask</code>，而是直接使用了<code>位运算</code></li><li><code>StartCoroutine</code>：用于开始执行一个<code>Coroutines（协程）</code>，<a href="https://docs.unity3d.com/Manual/Coroutines.html">Unity中的协程</a>是基于C#提供的<code>IEnumerator（迭代器）</code>实现的。<code>Unity的协程</code>功能非常强大，使用起来也比较简单。我们只需要先定义一个<code>返回类型为IEnumerator的方法</code>，然后在这个方法里面使用<code>yield语句</code>来设置协程等待的条件，并使用<code>StartCoroutine</code>来执行该方法。那么当程序执行到<code>yield语句</code>这里的时候，就会停止执行后面的代码，然后<code>每帧检查是否满足条件</code>，一旦满足条件就继续往下执行。</li><li><code>Physics2D.OverlapCircleAll</code>：Unity提供的api，用于获取在某个圆形范围内的所有<code>Collider2D</code>。</li></ul><p>&amp;emsp;&amp;emsp;编辑完毕之后，我们将<code>Bomb.cs</code>添加到<code>Hierarchy</code>窗口的<code>Bomb</code>物体上，可以看到Unity自动帮我们在<code>Bomb</code>物体上添加了<code>AudioSource</code>组件。为了让<code>炸弹</code>具有物理属性，能和场景里其他物体发生物理碰撞，我们还需要为<code>Bomb</code>物体添加<code>Rigidbody2D</code>和<code>Circle Collider2D</code>组件。然后，我们对每个组件进行以下的设置：</p><blockquote><p><code>Bomb</code>物体的组件设置：</p></blockquote><ol><li><code>Sprite Renderer</code>:<ul><li><code>Sorting Layer</code>: Weapons</li><li><code>Order In Layer</code>: 0</li></ul></li><li><code>Bomb</code>:<ul><li><code>DamageAmount</code>: 50</li><li><code>BombRadius</code>: 10</li><li><code>BombForce</code>: 800</li><li><code>BoomClip</code>: <code>Assets\Audio\FX</code>下的<code>bigboom</code></li><li><code>FuseTime</code>: 1.5f</li><li><code>FuseClip</code>: <code>Assets\Audio\FX</code>下的<code>bombfuse</code></li></ul></li><li><code>Circle Collider2D</code>:<ul><li><code>Is Trigger</code>: false</li><li><code>Offset</code>: (0, 0)</li><li><code>Radius</code>: 0.5</li></ul></li><li><code>Rigidbody2D</code><ul><li><code>Gravity Scale</code>: 3.1</li></ul></li></ol><p>&amp;emsp;&amp;emsp;设置完毕之后，保存修改，然后将<code>Bomb</code>物体从<code>Hierarchy</code>窗口拖拽至<code>Assets\Prefabs\Weapons</code>下将其做成Pfefab。接着，我们运行游戏，可以听到<code>炸弹</code>燃烧引信和爆炸的音效，也能看到角色和怪物被炸弹炸飞并受到伤害的效果。但<code>炸弹</code>在<code>燃烧引信</code>和<code>爆炸</code>的时候，没有任何的特效，无法让玩家直观地意识到<code>炸弹在燃烧引信</code>和<code>炸弹爆炸了</code>。因此，我们还需要为<code>炸弹</code>添加<code>引信燃烧特效</code>和<code>爆炸特效</code>。</p><hr><h2 id="为炸弹添加爆炸特效"><a href="#为炸弹添加爆炸特效" class="headerlink" title="为炸弹添加爆炸特效"></a>为炸弹添加爆炸特效</h2><p>&amp;emsp;&amp;emsp;接下来，我们首先为<code>炸弹</code>添加<code>爆炸</code>特效。首先，我们将<code>Assets\Sprites\FX</code>下的<code>Circle</code>拖拽到<code>Hierarchy</code>窗口中，并将<code>Circle</code>物体重命名为<code>BombExplosion</code>。接着，我们将<code>Assets\Scripts\Utility</code>下的<code>Destroyer.cs</code>添加到<code>BombExplosion</code>物体上，并修改<code>Destroyer.cs</code>如下：</p><figure class="highlight csharp"><figcaption><span>Destroyer.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Destroyer</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;是否在Awake时执行销毁操作&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> DestroyOnAwake = <span class="hljs-literal">false</span>;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;销毁延迟时间&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> AwakeDestroyDelay = <span class="hljs-number">0f</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Awake</span>()</span> &#123;<br>        <span class="hljs-keyword">if</span>(DestroyOnAwake) &#123;<br>            Destroy(<span class="hljs-keyword">this</span>.gameObject, AwakeDestroyDelay);<br>        &#125;<br>    &#125;<br><br><span class="hljs-comment">// 销毁自身</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DestroyGameObject</span>()</span> &#123;<br>        Destroy(gameObject);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;接着，我们设置<code>BombExplosion</code>物体的组件如下：</p><blockquote><p><code>BombExplosion</code>物体的组件设置：</p></blockquote><ol><li><code>Sprite Renderer</code>:<ul><li><code>Sorting Layer</code>: Weapons</li><li><code>Order In Layer</code>: 3</li></ul></li><li><code>Destroyer</code>:<ul><li><code>Destroy On Awake</code>: true</li><li><code>Awake Destroy Delay</code>: 0.1</li></ul></li></ol><p>&amp;emsp;&amp;emsp;修改完成之后，我们将<code>BombExplosion</code>物体拖拽至<code>Assets\Prefabs\Weapons</code>文件夹下将其制作为Prefab。然后我们删除场景中的<code>BombExplosion</code>物体，选中<code>Bomb</code>的Prefab，将其<code>Bomb.cs</code>下的<code>Bomb Explosion</code>属性设置为<code>BombExplosion</code>的Prefab。最后保存修改，运行游戏，可以看到炸弹爆炸时产生了爆炸特效。</p><p><img src="https://github.com/AsanCai/BlogImage/raw/master/PotatoGloryTutorial/Essay13/Image3.png" alt="设置爆炸特效"></p><hr><h2 id="为炸弹添加引信燃烧特效"><a href="#为炸弹添加引信燃烧特效" class="headerlink" title="为炸弹添加引信燃烧特效"></a>为炸弹添加引信燃烧特效</h2><p>&amp;emsp;&amp;emsp;为<code>炸弹</code>添加完<code>爆炸</code>特效之后，我们为<code>炸弹</code>添加<code>引信燃烧</code>特效。首先，我们在<code>Bomb</code>物体下创建一个名为<code>Sparks</code>的<code>Empty Gameobject</code>，然后我们为其添加<code>Particle System</code>组件。</p><blockquote><p><code>Sparks</code>物体的<code>Particle System</code>组件设置：</p></blockquote><ul><li>Main Module:<ul><li><code>Start Lifetime</code>: 0.5</li><li><code>Start Size(Random Between Two Constants)</code>: (0.2, 1)</li><li><code>Start Rotation(Random Between Two Constants)</code>: (0, 360)</li><li><code>Gravity Modefier</code>: 1</li><li><code>Simulation Space</code>: World</li><li><code>Scaling Mode</code>: Shape</li><li><code>Max Particles</code>: 100</li></ul></li><li>Emission:<ul><li><code>Rate Over Time</code>: 40</li></ul></li><li>Shape:<ul><li><code>Angle</code>: 36</li><li><code>Radius</code>: 0.01</li><li><code>Arc</code>: 0.01</li><li><code>Randomize Direction</code>: 1</li></ul></li><li>Size over Lifetime:<ul><li><code>Size(Random Between Two Constants)</code>: (0.4, 0.6)</li></ul></li><li>Rotation over Lifetime:<ul><li><code>Angular Velocity(Random Between Two Constants)</code>: (0, 180)</li></ul></li><li>Texture Sheet Animation<ul><li><code>Tiles</code>: (2, 2)</li></ul></li><li>Render<ul><li><code>Material</code>: <code>Assets\Materials</code>下的<code>ExplosionParticle</code></li><li><code>Sorting Layer</code>: Weapons</li><li><code>Order In Layer</code>: 4</li></ul></li></ul><p>&amp;emsp;&amp;emsp;修改完成之后，我们还需要调整<code>Sparks</code>的<code>Transform</code>组件。</p><blockquote><p><code>Sparks</code>物体的<code>Transform</code>组件设置：</p></blockquote><ul><li><code>Position</code>: (0.47, 0.53, 0)</li><li><code>Rotation</code>: (0, 90, 0)</li></ul><p>&amp;emsp;&amp;emsp;最后，我们将<code>Bomb</code>物体上的修改<code>Apply</code>至其Prefab上，然后运行游戏，可以看到<code>炸弹</code>已经有了<code>引信燃烧</code>特效了。</p><hr><h2 id="释放炸弹"><a href="#释放炸弹" class="headerlink" title="释放炸弹"></a>释放炸弹</h2><p>&amp;emsp;&amp;emsp;为<code>炸弹</code>添加好<code>引信燃烧</code>和<code>炸弹爆炸</code>特效之后，我们需要让角色能够释放炸弹。首先，我们删除场景中的<code>Bomb</code>物体。接着，我们修改<code>PlayerAttack.cs</code>如下：</p><figure class="highlight csharp"><figcaption><span>PlayerAttack.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-comment">// [RequireComponent(typeof(Animator))]</span><br>[<span class="hljs-meta">RequireComponent(typeof(PlayerController))</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PlayerAttack</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;导弹Prefab&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> Missile MissilePrefab;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;导弹发射点&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> Transform ShootingPoint;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;发射导弹的音效&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> AudioClip ShootEffect;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;炸弹Prefab&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> Rigidbody2D BombPrefab;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;炸弹的初始数量&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> InitBombNumber = <span class="hljs-number">4</span>;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;使用火箭筒抛射炸弹的力&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> ProjectileBombForce = <span class="hljs-number">1000f</span>;<br><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> m_CurrentBombNumber;<br><br>    <span class="hljs-comment">// private Animator m_Animator;</span><br>    <span class="hljs-keyword">private</span> PlayerController m_PlayerCtrl;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Awake</span>()</span> &#123;<br>        <span class="hljs-comment">// 获取引用</span><br>        <span class="hljs-comment">// m_Animator = GetComponent&lt;Animator&gt;();</span><br>        m_PlayerCtrl = GetComponent&lt;PlayerController&gt;();<br><br>        <span class="hljs-comment">// 检查关键属性是否赋值</span><br>        <span class="hljs-keyword">if</span>(MissilePrefab == <span class="hljs-literal">null</span>) &#123;<br>            Debug.LogError(<span class="hljs-string">&quot;请设置MissilePrefab&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(ShootingPoint == <span class="hljs-literal">null</span>) &#123;<br>            Debug.LogError(<span class="hljs-string">&quot;请设置ShootingPoint&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(BombPrefab == <span class="hljs-literal">null</span>) &#123;<br>            Debug.LogError(<span class="hljs-string">&quot;请设置BombPrefab&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span> &#123;<br>        m_CurrentBombNumber = InitBombNumber;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>()</span> &#123;<br>        <span class="hljs-keyword">if</span> (Input.GetButtonDown(<span class="hljs-string">&quot;Fire1&quot;</span>)) &#123;<br>            <span class="hljs-comment">// 发射导弹</span><br>            Fire();<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (Input.GetButtonDown(<span class="hljs-string">&quot;Fire2&quot;</span>)) &#123;<br>            <span class="hljs-comment">// 放置炸弹</span><br>            LayBomb();<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (Input.GetButtonDown(<span class="hljs-string">&quot;Fire3&quot;</span>)) &#123;<br>            <span class="hljs-comment">// 抛射炸弹</span><br>            ProjectileBomb();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 发射导弹</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Fire</span>()</span> &#123;<br>        <span class="hljs-comment">// // 播放射击动画</span><br>        <span class="hljs-comment">// m_Animator.SetTrigger(&quot;Shoot&quot;);</span><br><br>        <span class="hljs-comment">// 播放射击音效</span><br>        AudioSource.PlayClipAtPoint(ShootEffect, ShootingPoint.position);<br><br>        <span class="hljs-comment">// 创建导弹</span><br>        Missile instance = Instantiate(MissilePrefab, ShootingPoint.position, Quaternion.identity) <span class="hljs-keyword">as</span> Missile;<br><br>        <span class="hljs-comment">// 如果角色跟导弹的朝向不一致，就翻转导弹</span><br>        <span class="hljs-keyword">if</span>(m_PlayerCtrl.FacingRight ^ instance.FacingRight) &#123;<br>            instance.Flip();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 放置炸弹</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">LayBomb</span>()</span> &#123;<br>        <span class="hljs-keyword">if</span>(m_CurrentBombNumber &lt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 放置炸弹</span><br>        Instantiate(BombPrefab, <span class="hljs-keyword">this</span>.transform.position, Quaternion.identity);<br><br>        <span class="hljs-comment">// 减少炸弹数量</span><br>        m_CurrentBombNumber --;<br>    &#125;<br><br>    <span class="hljs-comment">// 抛射炸弹</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ProjectileBomb</span>()</span> &#123;<br>        <span class="hljs-keyword">if</span>(m_CurrentBombNumber &lt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 抛射炸弹</span><br>        Rigidbody2D body = Instantiate(BombPrefab, ShootingPoint.position, Quaternion.identity) <span class="hljs-keyword">as</span> Rigidbody2D;<br>        <span class="hljs-keyword">if</span>(m_PlayerCtrl.FacingRight) &#123;<br>            body.AddForce(Vector2.right * ProjectileBombForce);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            body.AddForce(Vector2.left * ProjectileBombForce);<br>        &#125;<br><br>        <span class="hljs-comment">// 减少炸弹数量</span><br>        m_CurrentBombNumber --;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;修改完成之后，我们将<code>BombPrefab</code>设置为<code>Bomb</code>的Prefab，运行游戏，此时我们可以通过<code>单击鼠标右键</code>来在<code>原地释放炸弹</code>以及通过<code>单击鼠标滚轮</code>来<code>向前抛射炸弹</code>。最后，我们将<code>Player</code>的修改<code>Apply</code>至其Prefab上，保存场景的修改。</p><hr><h2 id="后言"><a href="#后言" class="headerlink" title="后言"></a>后言</h2><p>&amp;emsp;&amp;emsp;至此，我们已完成实现放置炸弹的功能的所有工作。本篇文章涉及到的一些数值参数，大家可以根据自己的喜好进行修改。最后，本篇文章所做的修改，可以在<a href="https://github.com/AsanCai/PotatoGloryTutorial">PotatoGloryTutorial</a>这个仓库的<code>essay11</code>分支下看到，读者可以clone这个仓库到本地进行查看。</p><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://docs.unity3d.com/Manual/Coroutines.html">Unity的Coroutines</a></li><li><a href="https://docs.unity3d.com/Manual/ExecutionOrder.html">yield语句的检查时机</a></li><li><a href="https://docs.microsoft.com/en-us/dotnet/api/system.collections.ienumerator?redirectedfrom=MSDN&view=netframework-4.7.2">C#的IEnumerator</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
      <category>《土豆荣耀》</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《土豆荣耀》重构笔记（十二）对怪物造成伤害</title>
    <link href="/posts/39905599/"/>
    <url>/posts/39905599/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&amp;emsp;&amp;emsp;在<a href="https://asancai.github.io/tutorial/potato-glory/PotatoGloryTutorial-11/">上篇文章</a>，我们已经实现了发射导弹的功能，但此时导弹并不能对怪物造成任何伤害。接下来，我们来实现对怪物造成伤害的功能。</p><hr><h2 id="为怪物添加血量管理"><a href="#为怪物添加血量管理" class="headerlink" title="为怪物添加血量管理"></a>为怪物添加血量管理</h2><p>&amp;emsp;&amp;emsp;打开<code>Enemy.cs</code>，可以看到目前怪物只有在场景里面行走的功能。在实现导弹对怪物造成伤害的功能之前，我们首先为怪物增加血量管理的功能。</p><figure class="highlight csharp"><figcaption><span>Enemy.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br>[<span class="hljs-meta">RequireComponent(typeof(Wander))</span>]<br>[<span class="hljs-meta">RequireComponent(typeof(Rigidbody2D))</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Enemy</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;障碍物检测点&quot;</span>)</span>]<br>    [<span class="hljs-meta">SerializeField</span>]<br>    <span class="hljs-keyword">private</span> Transform FrontCheck;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;怪物的血量&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> MaxHP = <span class="hljs-number">10f</span>;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;怪物受伤时用来展示的图片&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> Sprite DamagedSprite;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;怪物死亡时用来展示的图片&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> Sprite DeadSprite;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;怪物死亡时用来展示DeadSprite&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> SpriteRenderer BodySpriteRenderer;<br><br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;怪物死亡时的音效&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> AudioClip[] DeathClips;<br><br>    <span class="hljs-keyword">private</span> Wander m_Wander;<br>    <span class="hljs-keyword">private</span> Rigidbody2D m_Rigidbody2D;<br><br>    <span class="hljs-keyword">private</span> LayerMask m_LayerMask;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">float</span> m_CurrentHP;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">bool</span> m_Hurt;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">bool</span> m_Dead;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Awake</span>()</span> &#123;<br>        <span class="hljs-comment">// 获取引用</span><br>        m_Wander = GetComponent&lt;Wander&gt;();<br>        m_Rigidbody2D = GetComponent&lt;Rigidbody2D&gt;();<br>    &#125;<br>        <br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span> &#123;<br>        <span class="hljs-comment">// 初始化变量</span><br>        m_LayerMask = LayerMask.GetMask(<span class="hljs-string">&quot;Obstacle&quot;</span>);<br>        m_CurrentHP = MaxHP;<br>        m_Hurt = <span class="hljs-literal">false</span>;<br>        m_Dead = <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Update</span> ()</span> &#123;<br>        <span class="hljs-comment">// 死亡之后不执行任何操作</span><br>        <span class="hljs-keyword">if</span>(m_Dead) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        Collider2D[] frontHits = Physics2D.OverlapPointAll(FrontCheck.position, m_LayerMask);<br><br>        <span class="hljs-keyword">if</span>(frontHits.Length &gt; <span class="hljs-number">0</span>) &#123;<br>            m_Wander.Flip();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 受伤函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">TakeDamage</span>(<span class="hljs-params">Transform weapon, <span class="hljs-built_in">float</span> hurtForce, <span class="hljs-built_in">float</span> damage</span>)</span> &#123;<br>        <span class="hljs-comment">// 减少当前的HP</span><br>        m_CurrentHP -= damage;<br><br>        <span class="hljs-comment">// 制造击退效果</span><br>        Vector3 hurtVector = transform.position - weapon.position;<br>        m_Rigidbody2D.AddForce(hurtVector.normalized * hurtForce);<br><br>        <span class="hljs-comment">// 判断当前是否第一次受伤</span><br>        <span class="hljs-keyword">if</span>(!m_Hurt) &#123;<br>            m_Hurt = <span class="hljs-literal">true</span>;<br><br>            <span class="hljs-keyword">if</span>(DamagedSprite != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// 禁用原有的Sprite</span><br>                SpriteRenderer[] children = GetComponentsInChildren&lt;SpriteRenderer&gt;();<br>                <span class="hljs-keyword">foreach</span>(SpriteRenderer child <span class="hljs-keyword">in</span> children) &#123;<br>                    child.enabled = <span class="hljs-literal">false</span>;<br>                &#125;<br><br>                <span class="hljs-comment">// 显示怪物受伤图片</span><br>                <span class="hljs-keyword">if</span>(BodySpriteRenderer != <span class="hljs-literal">null</span>) &#123;<br>                    BodySpriteRenderer.enabled = <span class="hljs-literal">true</span>;<br>                    BodySpriteRenderer.sprite = DamagedSprite;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    Debug.LogError(<span class="hljs-string">&quot;请设置BodySpriteRenderer&quot;</span>);<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                Debug.LogWarning(<span class="hljs-string">&quot;请设置DamagedSprite&quot;</span>);<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 判断当前的是否死亡</span><br>        <span class="hljs-keyword">if</span>(m_CurrentHP &lt;= <span class="hljs-number">0</span> &amp;&amp; !m_Dead) &#123;<br>            m_Dead = <span class="hljs-literal">true</span>;<br>            Death();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Death</span>()</span> &#123;<br>        <span class="hljs-comment">// 禁用Wander.cs</span><br>        m_Wander.enabled = <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">if</span>(DeadSprite != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 禁用原有的Sprite</span><br>            SpriteRenderer[] children = GetComponentsInChildren&lt;SpriteRenderer&gt;();<br>            <span class="hljs-keyword">foreach</span>(SpriteRenderer child <span class="hljs-keyword">in</span> children) &#123;<br>                child.enabled = <span class="hljs-literal">false</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// 显示怪物死亡图片</span><br>            <span class="hljs-keyword">if</span>(BodySpriteRenderer != <span class="hljs-literal">null</span>) &#123;<br>                BodySpriteRenderer.enabled = <span class="hljs-literal">true</span>;<br>                BodySpriteRenderer.sprite = DeadSprite;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                Debug.LogError(<span class="hljs-string">&quot;请设置BodySpriteRenderer&quot;</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            Debug.LogWarning(<span class="hljs-string">&quot;请设置DeadSprite&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 将所有的Collider2D都设置为Trigger，避免和其他物体产生物理碰撞</span><br>        Collider2D[] cols = GetComponents&lt;Collider2D&gt;();<br>        <span class="hljs-keyword">foreach</span>(Collider2D c <span class="hljs-keyword">in</span> cols) &#123;<br>            c.isTrigger = <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 随机播放死亡的音效</span><br>        <span class="hljs-keyword">if</span>(DeathClips != <span class="hljs-literal">null</span> &amp;&amp; DeathClips.Length &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">int</span> i = Random.Range(<span class="hljs-number">0</span>, DeathClips.Length);<br>            AudioSource.PlayClipAtPoint(DeathClips[i], transform.position);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            Debug.LogWarning(<span class="hljs-string">&quot;请设置DeathClips&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>代码说明：</p></blockquote><ul><li><code>AudioSource.PlayClipAtPoint</code>: 是<code>AudioSource</code>的一个静态函数，不需要添加<code>AudioSource</code>组件就能在游戏场景里面播放音效</li><li><code>GetComponentsInChildren</code>: 获取<code>自身</code>和<code>子物体</code>上所有目标组件的引用，注意，也<code>包括自身</code></li><li><code>enabled</code>: 当我们将某个组件的<code>enabled</code>属性设置为false的时候，该组件会被禁用，相当于我们在<code>Inspector</code>窗口中取消该组件的勾选</li></ul><p>&amp;emsp;&amp;emsp;修改完成之后，我们分别为<code>AlienShip</code>和<code>AlienSlug</code>的属性进行赋值：</p><blockquote><p><code>AlienShip</code>和<code>AlienSlug</code>的属性设置：</p></blockquote><ul><li><code>AlienShip</code><ul><li><code>MaxHP</code>: 20</li><li><code>Damaged Sprite</code>: <code>Assets\Sprites\Character</code>下的<code>char_enemy_alienShip-damaged</code></li><li><code>Dead Sprite</code>: <code>Assets\Sprites\Character</code>下的<code>char_enemy_alienShip-dead</code></li><li><code>Body Sprite Renderer</code>: <code>AlienShip</code>下的子物体<code>char_enemy_alienShip</code></li><li><code>Death Clips</code>: <code>Assets\Audio\Enemy</code>下的<code>enemy-death1</code>、<code>enemy-death2</code>和<code>enemy-death3</code></li></ul></li><li><code>AlienSlug</code><ul><li><code>MaxHP</code>: 10</li><li><code>Damaged Sprite</code>: None</li><li><code>Dead Sprite</code>: <code>Assets\Sprites\Character</code>下的<code>char_enemy_alienSlug-dead</code></li><li><code>Body Sprite Renderer</code>: <code>AlienShip</code>下的子物体<code>enemy1-body</code></li><li><code>Death Clips</code>: <code>Assets\Audio\Enemy</code>下的<code>enemy-death1</code>、<code>enemy-death2</code>和<code>enemy-death3</code></li></ul></li></ul><p>&amp;emsp;&amp;emsp;设置完成之后，我们将<code>AlienShip</code>和<code>AlienSlug</code>的修改Apply至它们的Prefab上，完成为怪物添加血量管理的工作。</p><hr><h2 id="让导弹伤害怪物的功能"><a href="#让导弹伤害怪物的功能" class="headerlink" title="让导弹伤害怪物的功能"></a>让导弹伤害怪物的功能</h2><p>&amp;emsp;&amp;emsp;为怪物添加血量管理之后，我们还需要为导弹添加伤害怪物的功能。根据软件设计原则的<code>单一职责原则（Single Responsibility Principle）</code>，导弹对怪物能造成伤害，那么应该由导弹维护<code>对怪物造成伤害的数值</code>以及<code>对怪物造成伤害时击退力的大小</code>等数值。清楚了这个以后，我们修改<code>Missile.cs</code>的代码如下：</p><figure class="highlight csharp"><figcaption><span>Missile.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br>[<span class="hljs-meta">RequireComponent(typeof(Rigidbody2D))</span>]<br>[<span class="hljs-meta">RequireComponent(typeof(CapsuleCollider2D))</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Missile</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;导弹是否朝向右边&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> FacingRight = <span class="hljs-literal">true</span>;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;爆炸效果&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> GameObject Explosion;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;导弹飞行的速度&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> Speed = <span class="hljs-number">25f</span>;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;导弹造成的伤害&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> DamageAmount = <span class="hljs-number">10f</span>;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;击退力的大小&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> HurtForce = <span class="hljs-number">50f</span>;<br><br>    <span class="hljs-keyword">private</span> Rigidbody2D m_Rigidbody2D;<br>    <span class="hljs-keyword">private</span> CapsuleCollider2D m_Trigger;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Awake</span>()</span> &#123;<br>        <span class="hljs-comment">// 获取引用</span><br>        m_Rigidbody2D = GetComponent&lt;Rigidbody2D&gt;();<br>        m_Trigger = GetComponent&lt;CapsuleCollider2D&gt;();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span> &#123;<br>        <span class="hljs-comment">// 确保Body Type为Kinematic</span><br>        m_Rigidbody2D.bodyType = RigidbodyType2D.Kinematic;<br>        <br>        <span class="hljs-comment">// 根据导弹朝向设置速度</span><br>        <span class="hljs-keyword">if</span>(FacingRight) &#123;<br>            m_Rigidbody2D.velocity = <span class="hljs-keyword">new</span> Vector2(Speed, <span class="hljs-number">0</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            m_Rigidbody2D.velocity = <span class="hljs-keyword">new</span> Vector2(-Speed, <span class="hljs-number">0</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 确保勾选了Trigger</span><br>        m_Trigger.isTrigger = <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Flip</span>()</span> &#123;<br>        <span class="hljs-comment">// 更新朝向</span><br>        FacingRight = !FacingRight;<br><br>        <span class="hljs-comment">// 修改scale的x分量实现转向</span><br>        <span class="hljs-keyword">this</span>.transform.localScale = Vector3.Scale(<br>            <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>),<br>            <span class="hljs-keyword">this</span>.transform.localScale<br>        );<br>    &#125;<br><br>    <span class="hljs-comment">// 导弹爆炸时调用的函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnExplode</span>()</span> &#123;<br>        <span class="hljs-keyword">if</span>(Explosion != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 随机生成一个四元数</span><br>            Quaternion randomRotation = Quaternion.Euler(<span class="hljs-number">0f</span>, <span class="hljs-number">0f</span>, Random.Range(<span class="hljs-number">0f</span>, <span class="hljs-number">360f</span>));<br>            <span class="hljs-comment">// 实例化爆炸对象</span><br>            Instantiate(Explosion, transform.position, randomRotation);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            Debug.LogWarning(<span class="hljs-string">&quot;请设置Explosion&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">//销毁自身</span><br>        Destroy(gameObject);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnTriggerEnter2D</span>(<span class="hljs-params">Collider2D collider</span>)</span> &#123;<br>        <span class="hljs-comment">// 不对角色产生任何操作</span><br>        <span class="hljs-keyword">if</span>(collider.CompareTag(<span class="hljs-string">&quot;Player&quot;</span>)) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 对怪物造成伤害</span><br>        <span class="hljs-keyword">if</span>(collider.CompareTag(<span class="hljs-string">&quot;Enemy&quot;</span>)) &#123;<br>            collider.GetComponent&lt;Enemy&gt;().TakeDamage(<span class="hljs-keyword">this</span>.transform, HurtForce, DamageAmount);<br>        &#125;<br><br>        OnExplode();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;修改完成之后运行游戏，然后发射导弹攻击怪物，可以看到怪物在导弹的攻击之下会受伤并死亡。</p><hr><h2 id="让怪物死亡后不再运动"><a href="#让怪物死亡后不再运动" class="headerlink" title="让怪物死亡后不再运动"></a>让怪物死亡后不再运动</h2><p>&amp;emsp;&amp;emsp;虽然这个时候，导弹已经能对怪物造成伤害了，但是怪物死亡之后下落的速度太慢，且水平方向上的速度不为0，我们需要加快怪物下落的速度，并让怪物死亡之后不再运动。</p><p>&amp;emsp;&amp;emsp;首先，我们将<code>AlienSlug</code>和<code>AlienShip</code>上<code>Rigidbody2D</code>组件的<code>Gravity Scale</code>都设置为和<code>Player</code>一样的<code>3.1</code>。然后，我们编辑<code>Wander.cs</code>，加入一个<code>OnDisable</code>函数。</p><figure class="highlight csharp"><figcaption><span>Wander.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Wander</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;是否朝向右边&quot;</span>)</span>]<br>    [<span class="hljs-meta">SerializeField</span>]<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">bool</span> FacingRight = <span class="hljs-literal">true</span>;<br><br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;怪物水平移动的速度&quot;</span>)</span>]<br>    [<span class="hljs-meta">SerializeField</span>]<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">float</span> MoveSpeed = <span class="hljs-number">2f</span>;<br><br><br>    <span class="hljs-comment">//用于设置怪物对象的物理属性</span><br>    <span class="hljs-keyword">private</span> Rigidbody2D m_Rigidbody;<br>    <span class="hljs-comment">// 用于保存当前的水平移动速度</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">float</span> m_CurrentMoveSpeed;<br><br>    <span class="hljs-comment">// 获取组件引用</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Awake</span>()</span> &#123;<br>        m_Rigidbody = GetComponent&lt;Rigidbody2D&gt;();<br>    &#125;<br><br>    <span class="hljs-comment">// 设置字段的初始值</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span> &#123;<br>        <span class="hljs-keyword">if</span>(FacingRight) &#123;<br>            m_CurrentMoveSpeed = MoveSpeed;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            m_CurrentMoveSpeed = -MoveSpeed;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 执行和物理相关的代码</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">FixedUpdate</span>()</span> &#123;<br>        m_Rigidbody.velocity = <span class="hljs-keyword">new</span> Vector2(m_CurrentMoveSpeed, m_Rigidbody.velocity.y);<br>    &#125;<br><br>    <span class="hljs-comment">// 在Wander.cs脚本被禁用时被调用</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDisable</span>()</span> &#123;<br>        <span class="hljs-comment">// 设置水平方向上的速度为0</span><br>        m_Rigidbody.velocity = <span class="hljs-keyword">new</span> Vector2(<span class="hljs-number">0f</span>, m_Rigidbody.velocity.y);<br>    &#125;<br><br>    <span class="hljs-comment">// 转向函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Flip</span>()</span> &#123;<br>        m_CurrentMoveSpeed *= <span class="hljs-number">-1</span>;<br>        <br>        <span class="hljs-keyword">this</span>.transform.localScale = Vector3.Scale(<span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>), <span class="hljs-keyword">this</span>.transform.localScale);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>代码说明：<br>&amp;emsp;&amp;emsp;<code>OnDisable</code>函数是Unity提供的生命周期函数之一，当脚本组件被禁用的时候，会先调用脚本组件的<code>OnDisable</code>函数，然后再禁用组件。</p></blockquote><p>&amp;emsp;&amp;emsp;修改完成之后，再次运行游戏，可以看到怪物死亡后的下落速度增快，且下落的过程中水平速度为0。</p><hr><h2 id="重构PlayerHealth-cs和Enemy-cs"><a href="#重构PlayerHealth-cs和Enemy-cs" class="headerlink" title="重构PlayerHealth.cs和Enemy.cs"></a>重构PlayerHealth.cs和Enemy.cs</h2><p>&amp;emsp;&amp;emsp;之前为了便于测试，我们在<code>PlayerHealth.cs</code>中实现了角色接触怪物受伤的功能。根据软件设计原则的<code>单一职责原则（Single Responsibility Principle）</code>，因为是怪物对角色造成伤害，那么我们应该在<code>Enemy.cs</code>中实现怪物对角色造成伤害的功能。因此，我们在<code>PlayerHealth.cs</code>中去掉被怪物伤害的代码。</p><figure class="highlight csharp"><figcaption><span>PlayerHealth.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br>[<span class="hljs-meta">RequireComponent(typeof(Rigidbody2D))</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PlayerHealth</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;角色的最大生命值&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> MaxHP = <span class="hljs-number">100f</span>;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;角色的受伤音效&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> AudioClip[] OuchClips;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;角色受伤后的免伤时间&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> FreeDamagePeriod = <span class="hljs-number">0.35f</span>;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;血量条&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> SpriteRenderer HealthSprite;<br><br>    <span class="hljs-comment">// 角色当前的血量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">float</span> m_CurrentHP;<br>    <span class="hljs-comment">// 上一次受到伤害的时间</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">float</span> m_LastFreeDamageTime;<br>    <span class="hljs-comment">// 血量条的初始长度</span><br>    <span class="hljs-keyword">private</span> Vector3 m_InitHealthScale;<br><br>    <span class="hljs-keyword">private</span> Rigidbody2D m_Rigidbody2D;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Awake</span>()</span> &#123;<br>        m_Rigidbody2D = GetComponent&lt;Rigidbody2D&gt;();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span> &#123;<br>        <span class="hljs-comment">// 初始化变量</span><br>        m_CurrentHP = MaxHP;<br>        m_LastFreeDamageTime = <span class="hljs-number">0f</span>;<br>        m_InitHealthScale = HealthSprite.transform.localScale;<br>    &#125;<br><br>    <span class="hljs-comment">// 受伤函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">TakeDamage</span>(<span class="hljs-params">Transform enemy, <span class="hljs-built_in">float</span> hurtForce, <span class="hljs-built_in">float</span> damage</span>)</span> &#123;<br>        <span class="hljs-comment">// 处于免伤状态，不执行任何操作</span><br>        <span class="hljs-keyword">if</span>(Time.time &lt;= m_LastFreeDamageTime + FreeDamagePeriod) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 更新上次受伤害的时间</span><br>        m_LastFreeDamageTime = Time.time;<br><br>        <span class="hljs-comment">// 给角色加上后退的力，制造击退效果</span><br>        Vector3 hurtVector = transform.position - enemy.position + Vector3.up * <span class="hljs-number">5f</span>;<br>        m_Rigidbody2D.AddForce(hurtVector.normalized * hurtForce);<br><br>        <span class="hljs-comment">// 更新角色的生命值</span><br>        m_CurrentHP -= damage;<br><br>        <span class="hljs-comment">// 更新生命条</span><br>        UpdateHealthBar();<br><br>        <span class="hljs-comment">// 随机播放受伤音频</span><br>        <span class="hljs-keyword">if</span>(OuchClips != <span class="hljs-literal">null</span> &amp;&amp; OuchClips.Length &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">int</span> i = Random.Range(<span class="hljs-number">0</span>, OuchClips.Length);<br>            AudioSource.PlayClipAtPoint(OuchClips[i], transform.position);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            Debug.LogWarning(<span class="hljs-string">&quot;请设置OuchClips&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 角色死亡</span><br>        <span class="hljs-keyword">if</span>(m_CurrentHP &lt;= <span class="hljs-number">0f</span>) &#123;<br>            Death();<br>        &#125;<br>    &#125;<br><br><span class="hljs-comment">// 更新血量条的函数</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">UpdateHealthBar</span>()</span> &#123;<br>        <span class="hljs-keyword">if</span>(HealthSprite != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-comment">// 更新血量条颜色</span><br>HealthSprite.color = Color.Lerp(Color.green, Color.red, <span class="hljs-number">1</span> - m_CurrentHP * <span class="hljs-number">0.01f</span>);<br><span class="hljs-comment">// 更新血量条长度</span><br>HealthSprite.transform.localScale = Vector3.Scale(m_InitHealthScale, <span class="hljs-keyword">new</span> Vector3(m_CurrentHP * <span class="hljs-number">0.01f</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>));<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>Debug.LogError(<span class="hljs-string">&quot;请设置HealthSprite&quot;</span>);<br>&#125;<br>    &#125;<br><br><span class="hljs-comment">// 死亡函数</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Death</span>()</span> &#123;<br><span class="hljs-comment">// 将碰撞体设置为Trigger，避免和其他物体产生碰撞效果</span><br>Collider2D[] cols = GetComponents&lt;Collider2D&gt;();<br><span class="hljs-keyword">foreach</span>(Collider2D c <span class="hljs-keyword">in</span> cols) &#123;<br>c.isTrigger = <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">// 禁用脚本</span><br>GetComponent&lt;PlayerController&gt;().enabled = <span class="hljs-literal">false</span>;<br><br><span class="hljs-comment">// 播放死亡动画</span><br>GetComponent&lt;Animator&gt;().SetTrigger(<span class="hljs-string">&quot;Death&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>代码说明：<br>&amp;emsp;&amp;emsp;这里，我们移除了<code>OnCollisionEnter2D</code>这个函数，修改了函数<code>TakeDamage</code>的参数，并将<code>角色当前是否处于免伤状态</code>和<code>角色当前是否死亡</code>这两个判断放在<code>TakeDamage</code>函数中执行。最后，因为之前没有涉及到<code>Trigger</code>，所以在<code>Death</code>函数中，我们直接禁用了角色所有<code>Collider2D</code>组件，这里，我们也需要将其改为<code>将角色的所有Collider2D组件设置为Trigger</code>。</p></blockquote><p>&amp;emsp;&amp;emsp;接着，我们要在<code>Enemy.cs</code>中加入怪物对角色造成伤害的代码。</p><figure class="highlight csharp"><figcaption><span>Enemy.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br>[<span class="hljs-meta">RequireComponent(typeof(Wander))</span>]<br>[<span class="hljs-meta">RequireComponent(typeof(Rigidbody2D))</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Enemy</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;角色受伤时减少的血量&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> DamageAmount = <span class="hljs-number">10f</span>;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;角色被怪物伤害时受到的击退力大小&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> HurtForce = <span class="hljs-number">500f</span>;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;障碍物检测点&quot;</span>)</span>]<br>    [<span class="hljs-meta">SerializeField</span>]<br>    <span class="hljs-keyword">private</span> Transform FrontCheck;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;怪物的血量&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> MaxHP = <span class="hljs-number">10f</span>;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;怪物受伤时用来展示的图片&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> Sprite DamagedSprite;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;怪物死亡时用来展示的图片&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> Sprite DeadSprite;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;怪物死亡时用来展示DeadSprite&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> SpriteRenderer BodySpriteRenderer;<br><br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;怪物死亡时的音效&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> AudioClip[] DeathClips;<br><br>    <span class="hljs-keyword">private</span> Wander m_Wander;<br>    <span class="hljs-keyword">private</span> Rigidbody2D m_Rigidbody2D;<br><br>    <span class="hljs-keyword">private</span> LayerMask m_LayerMask;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">float</span> m_CurrentHP;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">bool</span> m_Hurt;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">bool</span> m_Dead;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Awake</span>()</span> &#123;<br>        <span class="hljs-comment">// 获取引用</span><br>        m_Wander = GetComponent&lt;Wander&gt;();<br>        m_Rigidbody2D = GetComponent&lt;Rigidbody2D&gt;();<br>    &#125;<br>        <br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span> &#123;<br>        <span class="hljs-comment">// 初始化变量</span><br>        m_LayerMask = LayerMask.GetMask(<span class="hljs-string">&quot;Obstacle&quot;</span>);<br>        m_CurrentHP = MaxHP;<br>        m_Hurt = <span class="hljs-literal">false</span>;<br>        m_Dead = <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Update</span> ()</span> &#123;<br>        <span class="hljs-comment">// 死亡之后不执行任何操作</span><br>        <span class="hljs-keyword">if</span>(m_Dead) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        Collider2D[] frontHits = Physics2D.OverlapPointAll(FrontCheck.position, m_LayerMask);<br><br>        <span class="hljs-keyword">if</span>(frontHits.Length &gt; <span class="hljs-number">0</span>) &#123;<br>            m_Wander.Flip();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCollisionEnter2D</span>(<span class="hljs-params">Collision2D collision</span>)</span> &#123;<br>        <span class="hljs-comment">// 对角色造成伤害</span><br>        <span class="hljs-keyword">if</span>(collision.gameObject.CompareTag(<span class="hljs-string">&quot;Player&quot;</span>)) &#123;<br>            collision.gameObject.GetComponent&lt;PlayerHealth&gt;().TakeDamage(<span class="hljs-keyword">this</span>.transform, HurtForce, DamageAmount);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 受伤函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">TakeDamage</span>(<span class="hljs-params">Transform weapon, <span class="hljs-built_in">float</span> hurtForce, <span class="hljs-built_in">float</span> damage</span>)</span> &#123;<br>        <span class="hljs-comment">// 减少当前的HP</span><br>        m_CurrentHP -= damage;<br><br>        <span class="hljs-comment">// 制造击退效果</span><br>        Vector3 hurtVector = transform.position - weapon.position;<br>        m_Rigidbody2D.AddForce(hurtVector.normalized * hurtForce);<br><br>        <span class="hljs-comment">// 判断当前是否第一次受伤</span><br>        <span class="hljs-keyword">if</span>(!m_Hurt) &#123;<br>            m_Hurt = <span class="hljs-literal">true</span>;<br><br>            <span class="hljs-keyword">if</span>(DamagedSprite != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// 禁用原有的Sprite</span><br>                SpriteRenderer[] children = GetComponentsInChildren&lt;SpriteRenderer&gt;();<br>                <span class="hljs-keyword">foreach</span>(SpriteRenderer child <span class="hljs-keyword">in</span> children) &#123;<br>                    child.enabled = <span class="hljs-literal">false</span>;<br>                &#125;<br><br>                <span class="hljs-comment">// 显示怪物受伤图片</span><br>                <span class="hljs-keyword">if</span>(BodySpriteRenderer != <span class="hljs-literal">null</span>) &#123;<br>                    BodySpriteRenderer.enabled = <span class="hljs-literal">true</span>;<br>                    BodySpriteRenderer.sprite = DamagedSprite;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    Debug.LogError(<span class="hljs-string">&quot;请设置BodySpriteRenderer&quot;</span>);<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                Debug.LogWarning(<span class="hljs-string">&quot;请设置DamagedSprite&quot;</span>);<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 判断当前的是否死亡</span><br>        <span class="hljs-keyword">if</span>(m_CurrentHP &lt;= <span class="hljs-number">0</span> &amp;&amp; !m_Dead) &#123;<br>            m_Dead = <span class="hljs-literal">true</span>;<br>            Death();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Death</span>()</span> &#123;<br>        <span class="hljs-comment">// 禁用Wander.cs</span><br>        m_Wander.enabled = <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">if</span>(DeadSprite != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 禁用原有的Sprite</span><br>            SpriteRenderer[] children = GetComponentsInChildren&lt;SpriteRenderer&gt;();<br>            <span class="hljs-keyword">foreach</span>(SpriteRenderer child <span class="hljs-keyword">in</span> children) &#123;<br>                child.enabled = <span class="hljs-literal">false</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// 显示怪物死亡图片</span><br>            <span class="hljs-keyword">if</span>(BodySpriteRenderer != <span class="hljs-literal">null</span>) &#123;<br>                BodySpriteRenderer.enabled = <span class="hljs-literal">true</span>;<br>                BodySpriteRenderer.sprite = DeadSprite;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                Debug.LogError(<span class="hljs-string">&quot;请设置BodySpriteRenderer&quot;</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            Debug.LogWarning(<span class="hljs-string">&quot;请设置DeadSprite&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 将所有的Collider2D都设置为Trigger，避免和其他物体产生物理碰撞</span><br>        Collider2D[] cols = GetComponents&lt;Collider2D&gt;();<br>        <span class="hljs-keyword">foreach</span>(Collider2D c <span class="hljs-keyword">in</span> cols) &#123;<br>            c.isTrigger = <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 随机播放死亡的音效</span><br>        <span class="hljs-keyword">if</span>(DeathClips != <span class="hljs-literal">null</span> &amp;&amp; DeathClips.Length &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">int</span> i = Random.Range(<span class="hljs-number">0</span>, DeathClips.Length);<br>            AudioSource.PlayClipAtPoint(DeathClips[i], transform.position);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            Debug.LogWarning(<span class="hljs-string">&quot;请设置DeathClips&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>代码说明：<br>&amp;emsp;&amp;emsp;这里，我们主要增加了<code>HurtForce</code>和<code>DamageAmount</code>这两个字段，并增加了<code>OnCollisionEnter2D</code>函数，用于调用对角色造成伤害的<code>TakeDamage</code>函数。</p></blockquote><p>&amp;emsp;&amp;emsp;添加完毕之后，运行游戏，此时怪物能正常对角色造成伤害，没有出现Bug，重构顺利完成。</p><hr><h2 id="对参数的一些小调整"><a href="#对参数的一些小调整" class="headerlink" title="对参数的一些小调整"></a>对参数的一些小调整</h2><p>&amp;emsp;&amp;emsp;至此，所有的代码实现工作都做完了。但是为了游戏的可玩性和平衡性，我们需要对参数进行一些小调整。这里，<code>我们调整的思路是，血量低的怪物，移动速度快，对角色造成的伤害也高</code>。</p><blockquote><p><code>AlienShip</code>和<code>AlienSlug</code>的属性设置：</p></blockquote><ul><li><code>AlienShip</code><ul><li><code>Move Speed</code>: 2</li><li><code>Damage Amount</code>: 10</li><li><code>MaxHP</code>: 20</li></ul></li><li><code>AlienSlug</code><ul><li><code>Move Speed</code>: 3</li><li><code>Damage Amount</code>: 20</li><li><code>MaxHP</code>: 10</li></ul></li></ul><p>&amp;emsp;&amp;emsp;修改完成之后，将<code>AlienShip</code>和<code>AlienSlug</code>产生的修改Apply至它们的Prefab上，并保存场景产生的修改。</p><hr><h2 id="后言"><a href="#后言" class="headerlink" title="后言"></a>后言</h2><p>&amp;emsp;&amp;emsp;至此，我们所有的工作都已完成，本篇文章涉及到的一些数值参数，大家可以根据自己的喜好进行修改。最后，本篇文章所做的修改，可以在<a href="https://github.com/AsanCai/PotatoGloryTutorial">PotatoGloryTutorial</a>这个仓库的<code>essay10</code>分支下看到，读者可以clone这个仓库到本地进行查看。</p><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://docs.unity3d.com/Manual/class-AudioSource.html">Unity的AudioSource</a></li><li><a href="https://docs.unity3d.com/ScriptReference/AudioSource.html">AudioSource的API使用</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
      <category>《土豆荣耀》</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《土豆荣耀》重构笔记（十一）实现发射导弹的功能</title>
    <link href="/posts/29b00938/"/>
    <url>/posts/29b00938/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&amp;emsp;&amp;emsp;在实现了怪物攻击角色的功能之后，我们接下来需要实现玩家攻击怪物的功能。玩家攻击怪物的方式有<code>发射导弹</code>和<code>放置炸弹</code>。<code>导弹在场景中会以恒定速率飞行，碰到物体时爆炸，若碰到怪物则对怪物造成伤害</code>。接下来，我们开始制作能伤害怪物导弹并实现角色发射导弹的功能。</p><hr><h2 id="调整图片的Pixels-Per-Unit"><a href="#调整图片的Pixels-Per-Unit" class="headerlink" title="调整图片的Pixels Per Unit"></a>调整图片的Pixels Per Unit</h2><p>&amp;emsp;&amp;emsp;在<code>Hierarchy</code>创建一个名为<code>Missile</code>的<code>Empty GameObject</code>，然后将<code>Assets\Sprites\Props</code>下的<code>part_rocket</code>和<code>part_flame</code>拖拽到<code>Missile</code>成为其子物体<code>（由于part_flame是图集，所以添加到场景后会创建一个名为frame1的GameObject）</code>。可以看到，此时<code>part_rocket</code>和<code>flame1</code>比角色和怪物大了很多，这是因为<code>part_rocket</code>和<code>part_flame</code>的像素太大了，我们需要对<code>part_rocket</code>和<code>part_flame</code>进行调整。</p><p>&amp;emsp;&amp;emsp;我们可以在游戏场景中调整<code>part_rocket</code>和<code>flame1</code>的<code>Scale</code>将其缩小，但是这样的话，我们每次往场景里添加<code>part_rocket</code>和<code>part_flame</code>时，都必须手动将其缩小一遍。为了减少不必要的修改，我们直接修改<code>part_rocket</code>和<code>part_flame</code>的<code>Pixels Per Unit</code>。在Unity里，<code>Pixels Per Unit</code>表示<code>一个Unity3D单位对应该图片多少个图片像素</code>，我们增大图片的<code>Pixels Per Unit</code>，那么将该图片添加到游戏场景中时，其大小也会随之变小。</p><p>&amp;emsp;&amp;emsp;在<code>Project</code>窗口分别选中<code>part_rocket</code>和<code>part_flame</code>，然后将它们的<code>Pixels Per Unit</code>放大<code>5</code>倍，也就是分别修改为<code>500</code>和<code>125</code>。修改完成后，点击右下角的<code>Apply</code>，可以看到，游戏场景中的<code>part_rocket</code>和<code>part_flame</code>都缩小了。</p><p><img src="https://github.com/AsanCai/BlogImage/raw/master/PotatoGloryTutorial/Essay11/Image1.png" alt="修改Pixels Per Unit"></p><hr><h2 id="创建导弹Prefab"><a href="#创建导弹Prefab" class="headerlink" title="创建导弹Prefab"></a>创建导弹Prefab</h2><p>&amp;emsp;&amp;emsp;接下来，我们创建一个名为<code>Weapons</code>的<code>Sorting Layer</code>，然后调整<code>Weapons</code>这一<code>Sorting Layer</code>的位置，让其处于<code>Foreground</code>和<code>Character</code>之间。</p><p><img src="https://github.com/AsanCai/BlogImage/raw/master/PotatoGloryTutorial/Essay11/Image2.png" alt="Sorting Layer"></p><blockquote><p><code>Missile</code>子物体各属性的值：</p></blockquote><ul><li><code>part_rocket</code>:<ul><li><code>Position</code>: (0, 0, 0)</li><li><code>Sorting Layer</code>: Weapons, <code>Order In Layer</code>: 1</li></ul></li><li><code>flame1</code>:<ul><li><code>Position</code>: (-1.5, 0, 0)</li><li><code>Sorting Layer</code>: Weapons, <code>Order In Layer</code>: 0</li></ul></li></ul><p>&amp;emsp;&amp;emsp;修改完成之后，我们在<code>Assets\Prefabs</code>下创建一个名为<code>Weapons</code>的文件夹，并将<code>Missile</code>从<code>Hierarchy</code>窗口拖到<code>Weapons</code>文件夹下，将<code>Missile</code>做成Prefab。</p><hr><h2 id="让导弹飞起来"><a href="#让导弹飞起来" class="headerlink" title="让导弹飞起来"></a>让导弹飞起来</h2><p>&amp;emsp;&amp;emsp;为了导弹拥有速度这一物理属性，我们需要为<code>Missile</code>添加<code>Rigidbody2D</code>组件。为了避免导弹出现翻转的问题，我们需要勾选<code>Rigidbody2D</code>组件的<code>Freeze Rotation Z</code>。此外，因为导弹在飞行的过程中，不会受到重力影响下落，为了<code>提高游戏性能</code>，我们可以将其<code>Rigidbody2D</code>组件的<code>Body Type</code>设置为<code>Kinematic</code>。关于<code>Rigidbody2D</code>组件各种<code>Body Type</code>对应的作用，可以查阅<a href="https://docs.unity3d.com/Manual/class-Rigidbody2D.html">Unity关于Rigidbody2D的说明</a>。</p><p>&amp;emsp;&amp;emsp;接着，为了让导弹知道是否撞上场景内的其他物体，我们为<code>Missile</code>添加一个<code>Capsule Collider2D</code>组件。因为导弹和其他物体碰撞之后，不会产生一系列的物理碰撞效果，所以为了<code>提高游戏性能</code>，我们可以将勾选<code>Capsule Collider 2D</code>组件的<code>Is Trigger</code>属性。这样，当<code>Missile</code>和其他物体发生碰撞时，物理引擎将不对<code>Missile</code>和其他物体进行碰撞模拟。</p><p><img src="https://github.com/AsanCai/BlogImage/raw/master/PotatoGloryTutorial/Essay11/Image3.png" alt="Missile的组件属性"></p><p>&amp;emsp;&amp;emsp;添加完<code>Rigidbody2D</code>和<code>Capsule Collider2D</code>后，我们在<code>Assets\Scripts</code>下创建一个名为<code>Weapons</code>的文件夹，然后在<code>Weapons</code>文件夹下创建一个名为<code>Missile</code>的C#脚本。最后我们将<code>Missile.cs</code>添加到<code>Missile</code>上，并打开<code>Missile.cs</code>进行编辑。</p><figure class="highlight csharp"><figcaption><span>Missile.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br>[<span class="hljs-meta">RequireComponent(typeof(Rigidbody2D))</span>]<br>[<span class="hljs-meta">RequireComponent(typeof(CapsuleCollider2D))</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Missile</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;爆炸效果&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> GameObject Explosion;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;导弹飞行的速度&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> Speed = <span class="hljs-number">25f</span>;<br><br>    <span class="hljs-keyword">private</span> Rigidbody2D m_Rigidbody2D;<br>    <span class="hljs-keyword">private</span> CapsuleCollider2D m_Trigger;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Awake</span>()</span> &#123;<br>        <span class="hljs-comment">// 获取引用</span><br>        m_Rigidbody2D = GetComponent&lt;Rigidbody2D&gt;();<br>        m_Trigger = GetComponent&lt;CapsuleCollider2D&gt;();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span> &#123;<br>        <span class="hljs-comment">// 确保Body Type为Kinematic</span><br>        m_Rigidbody2D.bodyType = RigidbodyType2D.Kinematic;<br>        <span class="hljs-comment">// 设置速度</span><br>        m_Rigidbody2D.velocity = <span class="hljs-keyword">new</span> Vector2(Speed, <span class="hljs-number">0</span>);<br><br>        <span class="hljs-comment">// 确保勾选了Trigger</span><br>        m_Trigger.isTrigger = <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 导弹爆炸时调用的函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnExplode</span>()</span> &#123;<br>        <span class="hljs-keyword">if</span>(Explosion != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 随机生成一个四元数</span><br>            Quaternion randomRotation = Quaternion.Euler(<span class="hljs-number">0f</span>, <span class="hljs-number">0f</span>, Random.Range(<span class="hljs-number">0f</span>, <span class="hljs-number">360f</span>));<br>            <span class="hljs-comment">// 实例化爆炸对象</span><br>            Instantiate(Explosion, transform.position, randomRotation);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            Debug.LogWarning(<span class="hljs-string">&quot;请设置Explosion&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">//销毁自身</span><br>        Destroy(gameObject);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnTriggerEnter2D</span>(<span class="hljs-params">Collider2D collider</span>)</span> &#123;<br>        <span class="hljs-comment">// 不对角色产生任何操作</span><br>        <span class="hljs-keyword">if</span>(collider.CompareTag(<span class="hljs-string">&quot;Player&quot;</span>))&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        OnExplode();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>代码说明：</p></blockquote><ul><li><code>Rigidbody2D.bodyType</code>：我们可以通过修改<code>Rigidbody2D.bodyType</code>的值来动态修改<code>Rigidbody2D</code>的类型</li><li><code>Collider2D.isTrigger</code>：我们可以通过修改<code>Collider2D.isTrigger</code>的值来动态设置Collider2D是否开启<code>Trigger</code>属性</li><li><code>OnTriggerEnter2D</code>：当我们开启Collider2D的<code>Trigger</code>属性时，我们需要使用<code>OnTriggerEnter</code>来知道Collider2D正和哪些物体发生接触。类似的可用于Trigger检测的函数还有<code>OnTriggerStay</code>和<code>OnTriggerExit</code>。</li></ul><p>&amp;emsp;&amp;emsp;编辑完<code>Missile.cs</code>之后，运行游戏，可以看到导弹在场景内以恒定速率飞行，在接触到其他物体之后消失。</p><hr><h2 id="制作导弹爆炸动画"><a href="#制作导弹爆炸动画" class="headerlink" title="制作导弹爆炸动画"></a>制作导弹爆炸动画</h2><p>&amp;emsp;&amp;emsp;导弹在接触到其他物体之后直接消失游戏体验不佳，因此我们还需要一个爆炸的动画。</p><p>&amp;emsp;&amp;emsp;首先，在<code>Assets\Animation</code>和<code>Assets\Animator</code>下创建一个名为<code>Weapons</code>的文件夹。接着，打开<code>Assets\Sprites\FX</code>文件夹，可以看到<code>part_explosion</code>的<code>Sprite Mode</code>为<code>Multiple</code>，被切割为四张图片。因为导弹爆炸动画是更换当前显示的图片实现的，<code>四张图片分别代表爆炸动画的四个关键帧</code>，这里，我们<code>采用一种新的制作帧动画的方式来快速制作帧动画</code>。</p><p>&amp;emsp;&amp;emsp;在场景中新建一个名为<code>MissileExplosion</code>的Empty GameObject，然后同时选中<code>part_explosion</code>切割出来的四张图片，然后将它们拖拽到<code>Hierarchy</code>窗口中<code>MissileExplosion</code>上。因为我们同时给游戏场景里面添加了多个Sprite，Unity会认为我们想使用这些Sprite为<code>MissileExplosion</code>制作帧动画，所以会询问我们新建的帧动画保存的位置。这里，我们将该帧动画命名为<code>MissileExplosion.anim</code>并将其保存至<code>Assets\Animation\Weapons</code>文件夹下，<code>Unity会自动利用我们选择的四张图片帮我们创建好帧动画</code>。</p><p><img src="https://github.com/AsanCai/BlogImage/raw/master/PotatoGloryTutorial/Essay11/Image4.png" alt="制作导弹爆炸动画"></p><p>&amp;emsp;&amp;emsp;接着，我们在<code>Project</code>窗口将<code>Assets\Animation\Weapons</code>文件夹下的<code>MissileExplosion.controller</code>移动至<code>Assets\Animator\Weapons</code>文件夹下。因为我们是为空物体创建的动画，因此我们看不到动画的位置。为了便于观察，我们需要为<code>MissileExplosion</code>添加一个初始Sprite，这里我们选择<code>Assets\Sprites\FX</code>下<code>part_explosion</code>切割出来的<code>part_explosion_0</code>作为<code>MissileExplosion</code>的初始Sprite。</p><p><img src="https://github.com/AsanCai/BlogImage/raw/master/PotatoGloryTutorial/Essay11/Image5.png" alt="设置初始Sprite"></p><p>&amp;emsp;&amp;emsp;最后，我们还需要在<code>导弹爆炸时</code>播放爆炸音效。在<code>MissileExplosion</code>下添加<code>AudioSource</code>组件，然后将<code>Assets\Audio\FX</code>下的<code>rocketExplode</code>拖拽到<code>AudioClip</code>的赋值框处。</p><p><img src="https://github.com/AsanCai/BlogImage/raw/master/PotatoGloryTutorial/Essay11/Image6.png" alt="添加爆炸音效"></p><p>&amp;emsp;&amp;emsp;添加完音效之后，我们将<code>MissileExplosion</code>拖拽到<code>Assets\Prefabs\Weapons</code>文件夹下做成Prefab。运行游戏，可以听到播放了一次导弹爆炸音效，且导弹爆炸动画在不断循环播放。</p><hr><h2 id="添加Animation-Event"><a href="#添加Animation-Event" class="headerlink" title="添加Animation Event"></a>添加Animation Event</h2><p>&amp;emsp;&amp;emsp;我们不希望导弹爆炸动画一直在游戏场景中循环播放，我们希望导弹爆炸动画播放完之后，动画能自动被销毁。也就是说，我们希望导弹爆炸动画在播放至最后一帧时，能调用一个销毁自己的函数，我们可以使用<a href="https://docs.unity3d.com/Manual/animeditor-AnimationEvents.html">Animation Event</a>来完成这件事。</p><p>&amp;emsp;&amp;emsp;首先，我们在<code>Assets\Scripts\Utility</code>文件夹下创建一个名为<code>Destroyer</code>的C#脚本后，编辑<code>Destroyer.cs</code>。</p><figure class="highlight csharp"><figcaption><span>Destroyer.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Destroyer</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br><br>    <span class="hljs-comment">// 销毁自身</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DestroyGameObject</span>()</span> &#123;<br>        Destroy(gameObject);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;接着，把<code>Destroyer.cs</code>添加到<code>Hierarchy</code>窗口的<code>MissileExplosion</code>上。我们打开<code>Animation</code>窗口并选择<code>MissileExplosion</code>，在最后一帧处右击鼠标选择<code>Add Animation Event</code>并设置调用的函数为<code>DestroyGameObject</code>。</p><p><img src="https://github.com/AsanCai/BlogImage/raw/master/PotatoGloryTutorial/Essay11/Image7.png" alt="Animation Event"></p><p>&amp;emsp;&amp;emsp;运行游戏，可以看到爆炸动画播放完之后，被自动销毁。最后，我们将<code>MissileExplosion</code>产生的修改Apply至Prefab上，删除<code>Hierarchy</code>窗口中的<code>MissileExplosion</code>物体，并选中<code>Assets\Prefabs\Weapons</code>下的<code>Missile</code>，将<code>MissileExplosion</code>拖拽到<code>Explosion</code>赋值框。<code>因为我们是在Prefab做修改，所以场景中所有Prefab的实例都会同步修改</code>。再次运行游戏，可以看到导弹接触到物体之后，已经能正常产生爆炸效果了。</p><p><img src="https://github.com/AsanCai/BlogImage/raw/master/PotatoGloryTutorial/Essay11/Image8.png" alt="修改导弹Prefab"></p><hr><h2 id="制作导弹飞行特效"><a href="#制作导弹飞行特效" class="headerlink" title="制作导弹飞行特效"></a>制作导弹飞行特效</h2><p>&amp;emsp;&amp;emsp;为了避免让玩家决定导弹是在平移而不是飞行，我们需要在导弹飞行过程中加入<code>火焰喷射动画</code>和<code>烟雾拖尾粒子</code>。</p><p>&amp;emsp;&amp;emsp;首先，我们使用跟创建导弹爆炸动画一样的方式创建导弹的飞行过程中的火焰喷射动画。在<code>Project</code>窗口中同时选中<code>flame1</code>和<code>flame2</code>两张图片，并将它们拖动至<code>Missile</code>的子物体<code>flame1</code>上。接着，我们将新创建的动画命名为<code>Flame.anim</code>并将其保存至<code>Assets\Animation\Weapons</code>下，并将<code>Assets\Animation\Weapons</code>下的<code>flame1.controller</code>移动至<code>Assets\Animator\Weapons</code>文件夹即可。此时，将导弹的飞行速度调小至<code>2</code>，然后运行游戏，就可以看到导弹飞行的过程中在播放火焰喷射动画。</p><p>&amp;emsp;&amp;emsp;除了创建火焰喷射动画，我们还需要使用<code>粒子系统（Particle System）</code>来制作导弹飞行时的烟雾拖尾效果。</p><p>&amp;emsp;&amp;emsp;首先，在<code>Missile</code>下创建一个名为<code>trail</code>的Empty GameObject，然后设置其<code>Position</code>为<code>(-0.5, 0, 0)</code>。接着，我们为<code>trail</code>添加<code>Particle System</code>组件，因为<code>Particle System</code>组件里面还内嵌了很多包括<code>Emission</code>、<code>Render</code>等模块，我们不在这里一一细讲每个模块，感兴趣的同学可以参阅<a href="https://docs.unity3d.com/Manual/ParticleSystemModules.html">Particle System modules</a>来了解例子系统各个模块的功能。</p><blockquote><p><code>trail</code>物体的<code>Particle System</code>组件设置：</p></blockquote><ul><li>Main Module:<ul><li><code>Start Lifetime</code>: 0.3</li><li><code>Start Size(Random Between Two Constants)</code>: (0.3, 0.8)</li><li><code>Start Rotation(Random Between Two Constants)</code>: (-30, 30)</li><li><code>Start Color(Random Between Two Colors)</code> :((255, 255, 255, 255), (147, 142, 138, 255))</li><li><code>Gravity Modefier</code>: 0.1</li><li><code>Simulation Space</code>: World</li><li><code>Scaling Mode</code>: Shape</li></ul></li><li>Emission:<ul><li><code>Rate Over Time</code>: 30</li></ul></li><li>Limit Velocity Over Lifetime:<ul><li><code>Dampen</code>: 0.7</li></ul></li><li>Size over Lifetime:<ul><li><code>Size(Random Between Two Constants)</code>: (1, 2)</li></ul></li><li>Rotation over Lifetime:<ul><li><code>Angular Velocity(Random Between Two Constants)</code>: (-10, 10)</li></ul></li><li>Texture Sheet Animation<ul><li><code>Animation</code>: Single Row</li><li><code>Randow Row</code>: false</li><li><code>Frame over Time(Random Between Two Constants)</code>: (1, 3.9996)</li></ul></li><li>Render<ul><li><code>Material</code>: Smoke</li><li><code>Max Particle Size</code>: 5</li><li><code>Sorting Layer</code>: Weapons</li></ul></li></ul><p>&amp;emsp;&amp;emsp;修改完成后，将导弹的速度调回<code>25</code>，运行游戏，可以看到导弹飞行的过程中出现了烟雾拖尾的效果。此时，我们将<code>Missile</code>的修改Apply至它的Prefab上，保存修改，然后在<code>Hierarchy</code>窗口中删除<code>Missile</code>物体。需要注意的是，为了方便阐述，上面大部分属性都没有使用<code>Curve</code>，为了做出效果更好的粒子系统，大家可以根据自己的喜好来调整各个<code>Particle System modules</code>的属性。</p><p><img src="https://github.com/AsanCai/BlogImage/raw/master/PotatoGloryTutorial/Essay11/Image9.png" alt="Particle System modules"></p><hr><h2 id="发射导弹"><a href="#发射导弹" class="headerlink" title="发射导弹"></a>发射导弹</h2><p>&amp;emsp;&amp;emsp;接下来，我们可以实现发射导弹的功能。在<code>Assets\Scripts\Player</code>下创建一个名为<code>PlayerAttack</code>的C#脚本。然后编辑<code>PlayerAttack.cs</code>如下</p><figure class="highlight csharp"><figcaption><span>PlayerAttack.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-comment">// [RequireComponent(typeof(Animator))]</span><br>[<span class="hljs-meta">RequireComponent(typeof(PlayerController))</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PlayerAttack</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;导弹Prefab&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> Missile MissilePrefab;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;导弹发射点&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> Transform ShootingPoint;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;发射导弹的音效&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> AudioClip ShootEffect;<br><br>    <span class="hljs-comment">// private Animator m_Animator;</span><br>    <span class="hljs-keyword">private</span> PlayerController m_PlayerCtrl;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Awake</span>()</span> &#123;<br>        <span class="hljs-comment">// 获取引用</span><br>        <span class="hljs-comment">// m_Animator = GetComponent&lt;Animator&gt;();</span><br>        m_PlayerCtrl = GetComponent&lt;PlayerController&gt;();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>()</span> &#123;<br>        <span class="hljs-keyword">if</span> (Input.GetButtonDown(<span class="hljs-string">&quot;Fire1&quot;</span>)) &#123;<br>            <span class="hljs-comment">// 发射导弹</span><br>            Fire();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Fire</span>()</span> &#123;<br>        <span class="hljs-comment">// // 播放射击动画</span><br>        <span class="hljs-comment">// m_Animator.SetTrigger(&quot;Shoot&quot;);</span><br>        <span class="hljs-comment">// 播放射击音效</span><br>        AudioSource.PlayClipAtPoint(ShootEffect, ShootingPoint.position);<br><br>        <span class="hljs-keyword">if</span>(ShootingPoint != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 创建导弹</span><br>            Missile instance = Instantiate(MissilePrefab, ShootingPoint.position, Quaternion.identity) <span class="hljs-keyword">as</span> Missile;<br><br>            <span class="hljs-comment">// 如果角色跟导弹的朝向不一致，就翻转导弹</span><br>            <span class="hljs-keyword">if</span>(m_PlayerCtrl.FacingRight ^ instance.FacingRight) &#123;<br>                instance.Flip();<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            Debug.LogError(<span class="hljs-string">&quot;请设置ShootingPoint&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此外，我们还需要编辑<code>Missile.cs</code>，加入<code>Flip函数</code>，并且添加根据朝向来设置速度的代码。</p><figure class="highlight csharp"><figcaption><span>Missile.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br>[<span class="hljs-meta">RequireComponent(typeof(Rigidbody2D))</span>]<br>[<span class="hljs-meta">RequireComponent(typeof(CapsuleCollider2D))</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Missile</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;导弹是否朝向右边&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> FacingRight = <span class="hljs-literal">true</span>;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;爆炸效果&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> GameObject Explosion;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;导弹飞行的速度&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> Speed = <span class="hljs-number">25f</span>;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;导弹造成的伤害&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> DamageAmount = <span class="hljs-number">10</span>;<br><br>    <span class="hljs-keyword">private</span> Rigidbody2D m_Rigidbody2D;<br>    <span class="hljs-keyword">private</span> CapsuleCollider2D m_Trigger;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Awake</span>()</span> &#123;<br>        <span class="hljs-comment">// 获取引用</span><br>        m_Rigidbody2D = GetComponent&lt;Rigidbody2D&gt;();<br>        m_Trigger = GetComponent&lt;CapsuleCollider2D&gt;();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span> &#123;<br>        <span class="hljs-comment">// 确保Body Type为Kinematic</span><br>        m_Rigidbody2D.bodyType = RigidbodyType2D.Kinematic;<br>        <br>        <span class="hljs-comment">// 根据导弹朝向设置速度</span><br>        <span class="hljs-keyword">if</span>(FacingRight) &#123;<br>            m_Rigidbody2D.velocity = <span class="hljs-keyword">new</span> Vector2(Speed, <span class="hljs-number">0</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            m_Rigidbody2D.velocity = <span class="hljs-keyword">new</span> Vector2(-Speed, <span class="hljs-number">0</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 确保勾选了Trigger</span><br>        m_Trigger.isTrigger = <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Flip</span>()</span> &#123;<br>        <span class="hljs-comment">// 更新朝向</span><br>        FacingRight = !FacingRight;<br><br>        <span class="hljs-comment">// 修改scale的x分量实现转向</span><br>        <span class="hljs-keyword">this</span>.transform.localScale = Vector3.Scale(<br>            <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>),<br>            <span class="hljs-keyword">this</span>.transform.localScale<br>        );<br>    &#125;<br><br>    <span class="hljs-comment">// 导弹爆炸时调用的函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnExplode</span>()</span> &#123;<br>        <span class="hljs-keyword">if</span>(Explosion != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 随机生成一个四元数</span><br>            Quaternion randomRotation = Quaternion.Euler(<span class="hljs-number">0f</span>, <span class="hljs-number">0f</span>, Random.Range(<span class="hljs-number">0f</span>, <span class="hljs-number">360f</span>));<br>            <span class="hljs-comment">// 实例化爆炸对象</span><br>            Instantiate(Explosion, transform.position, randomRotation);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            Debug.LogWarning(<span class="hljs-string">&quot;请设置Explosion&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">//销毁自身</span><br>        Destroy(gameObject);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnTriggerEnter2D</span>(<span class="hljs-params">Collider2D collider</span>)</span> &#123;<br>        <span class="hljs-comment">// 不对角色产生任何操作</span><br>        <span class="hljs-keyword">if</span>(collider.CompareTag(<span class="hljs-string">&quot;Player&quot;</span>))&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        OnExplode();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;编辑完成之后，我们在<code>Player</code>下新建一个名为<code>ShootingPoint</code>的Empty GameObject，然后将其<code>Position</code>设置为<code>(1.2, 0.25, 0)</code>。接着，我们将<code>Missile</code>的Prefab拖拽至<code>MissilePrefab</code>的赋值框处，将<code>Player</code>的子物体<code>ShootingPoint</code>拖拽至<code>ShootingPoint</code>的赋值框处，将<code>Assets\Audio\FX</code>下的<code>bazooka</code>拖拽到<code>ShootEffect</code>的赋值框处，最后点击<code>Apply</code>将修改应用至<code>Player</code>的Prefab，保存场景产生的修改。运行游戏，我们已经可以<code>通过点击鼠标左键来发射导弹</code>了。</p><p><img src="https://github.com/AsanCai/BlogImage/raw/master/PotatoGloryTutorial/Essay11/Image10.png" alt="设置PlayerAttack的属性"></p><hr><h2 id="后言"><a href="#后言" class="headerlink" title="后言"></a>后言</h2><p>&amp;emsp;&amp;emsp;至此，我们已经完成了角色发射导弹的功能。由于篇幅限制，我们将会在下一篇文章里实现利用导弹对怪物造成伤害的功能。最后，本篇文章所做的修改，可以在<a href="https://github.com/AsanCai/PotatoGloryTutorial">PotatoGloryTutorial</a>这个仓库的<code>essay9</code>分支下看到，读者可以clone这个仓库到本地进行查看。</p><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://docs.unity3d.com/Manual/Tilemap-Isometric-SpritesImport.html">Importing and preparing Sprites</a></li><li><a href="https://docs.unity3d.com/Manual/class-Rigidbody2D.html">Unity的Rigidbody2D</a></li><li><a href="https://docs.unity3d.com/Manual/animeditor-AnimationEvents.html">Using Animation Events</a></li><li><a href="https://docs.unity3d.com/Manual/ParticleSystemModules.html">Particle System modules</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
      <category>《土豆荣耀》</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《土豆荣耀》重构笔记（十）实现摄像机跟随角色移动的功能</title>
    <link href="/posts/70269960/"/>
    <url>/posts/70269960/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&amp;emsp;&amp;emsp;当角色在场景中移动时，为了更好地观察角色，我们需要让摄像机跟随角色移动。又因为场景的大小一般是有限的，为了避免穿帮，我们还需要限制摄像机移动的范围。也就是说，我们需要让摄像机在可移动的范围内跟随角色进行移动。</p><hr><h2 id="跟随角色移动"><a href="#跟随角色移动" class="headerlink" title="跟随角色移动"></a>跟随角色移动</h2><p>&amp;emsp;&amp;emsp;首先，我们在<code>Assets\Scripts</code>下创建一个名为<code>Utility</code>的文件夹，并在<code>Utility</code>下创建一个名为<code>CameraFollow</code>的C#脚本。然后我们将<code>CameraFollow.cs</code>添加到<code>Main Camera</code>上。</p><figure class="highlight csharp"><figcaption><span>CameraFollow.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">CameraFollow</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;水平方向上最大偏移量&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> HorizontalMargin = <span class="hljs-number">2f</span>;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;竖直方向上最大偏移量&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> VerticalMargin = <span class="hljs-number">2f</span>;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;水平方向上跟随角色的速度&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> HorizontalFollowSpeed = <span class="hljs-number">2f</span>;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;竖直方向上跟随角色的速度&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> VerticalFollowSpeed = <span class="hljs-number">2f</span>;<br><br>    <span class="hljs-comment">// 角色Transform组件的引用</span><br>    <span class="hljs-keyword">private</span> Transform m_Player;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Awake</span>()</span> &#123;<br>        <span class="hljs-comment">// 获取引用</span><br>        m_Player = GameObject.FindGameObjectWithTag(<span class="hljs-string">&quot;Player&quot;</span>).transform;<br><br>        <span class="hljs-keyword">if</span>(m_Player == <span class="hljs-literal">null</span>) &#123;<br>Debug.LogError(<span class="hljs-string">&quot;请添加Tag为Player的GameObject&quot;</span>);<br>&#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">LateUpdate</span>()</span> &#123;<br>        TrackPlayer();<br>    &#125;<br><br>    <span class="hljs-comment">// 跟随玩家</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">TrackPlayer</span>()</span> &#123;<br>        <span class="hljs-built_in">float</span> targetX = transform.position.x;<br>        <span class="hljs-built_in">float</span> targetY = transform.position.y;<br><br>        <span class="hljs-comment">// 如果超出了偏移量，计算摄像机跟随后的位置</span><br>        <span class="hljs-keyword">if</span> (CheckHorizontalMargin()) &#123;<br>            targetX = Mathf.Lerp(transform.position.x, m_Player.position.x, HorizontalFollowSpeed * Time.deltaTime);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (CheckVerticalMargin()) &#123;<br>            targetY = Mathf.Lerp(transform.position.y, m_Player.position.y, VerticalFollowSpeed * Time.deltaTime);<br>        &#125;<br><br>        <span class="hljs-comment">// 更新摄像机的位置</span><br>        transform.position = <span class="hljs-keyword">new</span> Vector3(targetX, targetY, transform.position.z);<br>    &#125;<br><br>    <span class="hljs-comment">// 判断水平方向上是否超出了最大偏移量</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">CheckHorizontalMargin</span>()</span> &#123;<br>        <span class="hljs-keyword">return</span> Mathf.Abs(transform.position.x - m_Player.position.x) &gt; HorizontalMargin;<br>    &#125;<br><br>    <span class="hljs-comment">// 判断竖直方向上是否超出了最大偏移量</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">CheckVerticalMargin</span>()</span> &#123;<br>        <span class="hljs-keyword">return</span> Mathf.Abs(transform.position.y - m_Player.position.y) &gt; VerticalMargin;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>代码说明：<br>&amp;emsp;&amp;emsp;<code>GameObject.FindGameObjectWithTag(&quot;Player&quot;)</code>表示获取场景中Tag为<code>Player</code>的GameObject的引用，如果场景中没有Tag为<code>Player</code>的GameObject，那么它会返回null。这里，我们使用<code>GameObject.FindGameObjectWithTag(&quot;Player&quot;).transform</code>来获取角色的<code>Transform</code>组件的引用。</p></blockquote><p>&amp;emsp;&amp;emsp;编辑完<code>CameraFollow.cs</code>之后，我们设置<code>Player</code>的Tag为<code>Player</code>，并将修改Apply到<code>Player</code>的Prefab上。接着，我们运行游戏，可以看到摄像机已经可以跟随角色进行移动。</p><p><img src="https://github.com/AsanCai/BlogImage/raw/master/PotatoGloryTutorial/Essay10/Image1.png" alt="修改Player的Tag"></p><hr><h2 id="获取摄像机的视口大小"><a href="#获取摄像机的视口大小" class="headerlink" title="获取摄像机的视口大小"></a>获取摄像机的视口大小</h2><p>&amp;emsp;&amp;emsp;在Unity里，<code>正交摄像机（Orthographic Camera）</code>的视口高度是固定的，大小为<code>Camera的Size属性的值 * 2</code>个Unity基本单位。而视口的宽度则是根据输出画面的<code>高度分辨率和宽度分辨率的比例</code>，乘上<code>视口的高度</code>得到的。在<code>CameraFollow.cs</code>加入以下代码。</p><figure class="highlight csharp"><figcaption><span>CameraFollow.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">CameraFollow</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br>    ...<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span> &#123;<br>        Camera camera = <span class="hljs-keyword">this</span>.GetComponent&lt;Camera&gt;();<br>        <br><span class="hljs-comment">// 获取视口右上角对应的世界坐标</span><br>        Vector3 cornerPos = camera.ViewportToWorldPoint(<span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">1f</span>, <span class="hljs-number">1f</span>, Mathf.Abs(transform.position.z)));<br><br><span class="hljs-comment">// 此时，摄像机的世界坐标就是视口中心点的世界坐标</span><br><span class="hljs-comment">// 计算摄像机视口的宽度</span><br><span class="hljs-built_in">float</span> cameraWidth = <span class="hljs-number">2</span> * (cornerPos.x - transform.position.x);<br><span class="hljs-comment">// 计算视口的高度</span><br><span class="hljs-built_in">float</span> cameraHeight = <span class="hljs-number">2</span> * (cornerPos.y - transform.position.y);<br><br>        Debug.Log(<span class="hljs-string">&quot;Width: &quot;</span> + cameraWidth);<br>        Debug.Log(<span class="hljs-string">&quot;Height: &quot;</span> + cameraHeight);<br>    &#125;<br><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;修改完成后，运行游戏，因为此时摄像机的<code>Size为11</code>，设置的屏幕分辨率为<code>1920 * 1080</code>，所以输出的<code>Height应为22</code>，输出的<code>Weight应为1920 / 1080 * 22 = 39.11</code>，也就是我们计算得到的结果正确。</p><p><img src="https://github.com/AsanCai/BlogImage/raw/master/PotatoGloryTutorial/Essay10/Image2.png" alt="计算结果"></p><hr><h2 id="定义摄像机的移动范围"><a href="#定义摄像机的移动范围" class="headerlink" title="定义摄像机的移动范围"></a>定义摄像机的移动范围</h2><p>&amp;emsp;&amp;emsp;接下来，我们来限制摄像机的移动范围。因为摄像机的移动范围大小和场景的大小有关，为了能清晰地在游戏场景里看到我们当前编辑的边界大小，我们不使用数值来定义摄像机移动的范围，我们<code>使用Box Collider2D组件来定义摄像机的移动范围</code>。</p><p>&amp;emsp;&amp;emsp;首先，我们在<code>Hierarchy</code>中创建一个名为<code>SceneBounds</code>的Empty GameObject，并<code>Reset</code>它的<code>Transform</code>组件。接着，我们给<code>SceneBounds</code>添加一个<code>Box Collider2D</code>组件，并调整<code>Box Collider2D</code>组件的<code>Offset</code>和<code>Size</code>属性，直到<code>Box Collider2D</code>覆盖整个游戏场景为止。</p><blockquote><p>Box Collider2D的属性为：</p></blockquote><ul><li><code>Offset</code>: (0, 0)</li><li><code>Size</code>: (48, 27)</li></ul><p>&amp;emsp;&amp;emsp;调整完毕之后，为了避免<code>SceneBounds</code>的<code>Box Collider2D</code>组件对游戏场景里的其他物体产生影响，我们需要新建一个名为<code>Setting</code>的Layer，将<code>SceneBounds</code>的Layer设置为<code>Setting</code>之后，在<code>Layer Collision Matrix</code>里设置<code>Setting</code>与所有其他Layer不产生任何交互。</p><p><img src="https://github.com/AsanCai/BlogImage/raw/master/PotatoGloryTutorial/Essay10/Image3.png" alt="Layer Collision Matrix"></p><hr><h2 id="限制摄像机的移动"><a href="#限制摄像机的移动" class="headerlink" title="限制摄像机的移动"></a>限制摄像机的移动</h2><p>&amp;emsp;&amp;emsp;最后，我们在<code>CameraFollow.cs</code>加入以下代码。</p><figure class="highlight csharp"><figcaption><span>CameraFollow.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">CameraFollow</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br>...<br>[<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;摄像机可移动的范围&quot;</span>)</span>]<br><span class="hljs-keyword">public</span> BoxCollider2D Region;<br><br><span class="hljs-comment">// 摄像机中心点在水平方向上可移动的范围</span><br><span class="hljs-keyword">private</span> Vector2 m_HorizontalRegion;<br><span class="hljs-comment">// 摄像机中心点在竖直方向上可移动的范围</span><br><span class="hljs-keyword">private</span> Vector2 m_VerticalRegion;<br><br>...<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span> &#123;<br>...<br><br><span class="hljs-comment">// 计算Box Collider2D中心点的世界坐标</span><br>Vector2 regionPosition = <span class="hljs-keyword">new</span> Vector2(<br>Region.transform.position.x + Region.offset.x,<br>Region.transform.position.y + Region.offset.y<br>);<br><br><span class="hljs-comment">// 计算Box Collider2D和摄像机视口的宽度差的一半</span><br><span class="hljs-built_in">float</span> halfDeltaWidth = (Region.size.x - cameraWidth) / <span class="hljs-number">2</span>;<br><span class="hljs-comment">// 计算Box Collider2D和摄像机视口的高度差的一半</span><br><span class="hljs-built_in">float</span> halfDeltaHeight = (Region.size.y - cameraHeight) / <span class="hljs-number">2</span>;<br><br><span class="hljs-keyword">if</span>(halfDeltaWidth &lt; <span class="hljs-number">0</span>) &#123;<br>Debug.LogError(<span class="hljs-string">&quot;Box Collider2D的宽度小于摄像机视口的宽度&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">if</span>(halfDeltaHeight &lt; <span class="hljs-number">0</span>) &#123;<br>Debug.LogError(<span class="hljs-string">&quot;Box Collider2D的高度小于摄像机视口的高度&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// 计算摄像机中心点水平方向上可移动的范围</span><br>m_HorizontalRegion = <span class="hljs-keyword">new</span> Vector2(<br>regionPosition.x - halfDeltaWidth,<br>regionPosition.x + halfDeltaWidth<br>);<br><br><span class="hljs-comment">// 计算摄像机中心点竖直方向上可移动的范围</span><br>m_VerticalRegion = <span class="hljs-keyword">new</span> Vector2(<br>regionPosition.y - halfDeltaHeight,<br>regionPosition.y + halfDeltaHeight<br>);<br>&#125;<br><br>...<br><br><span class="hljs-comment">// 跟随玩家</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">TrackPlayer</span>()</span> &#123;<br>        ...<br><br>targetX = Mathf.Clamp(targetX, m_HorizontalRegion.x, m_HorizontalRegion.y);<br>        targetY = Mathf.Clamp(targetY, m_VerticalRegion.x, m_VerticalRegion.y);<br><br><span class="hljs-comment">// 更新摄像机的位置</span><br>        transform.position = <span class="hljs-keyword">new</span> Vector3(targetX, targetY, transform.position.z);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>代码说明：<br>&amp;emsp;&amp;emsp;<code>Box Collider2D</code>组件的<code>Offset</code>属性表示<code>Box Collider2D</code>中心点和<code>Transform</code>组件中心点的偏移量。我们想获得<code>Box Collider2D</code>组件的中心点，就需要在<code>Transform</code>组件的<code>Position</code>属性的值上加上<code>Box Collider2D</code>组件的<code>Offset</code>属性的值。</p></blockquote><p>&amp;emsp;&amp;emsp;编辑完<code>CameraFollow.cs</code>之后，我们将<code>SceneBounds</code>拖拽到<code>Region</code>属性的赋值框，运行游戏，可以看到摄像机被正确限制在<code>Box Collider2D</code>组件定义的范围内。</p><p><img src="https://github.com/AsanCai/BlogImage/raw/master/PotatoGloryTutorial/Essay10/Image4.png" alt="设置Region"></p><hr><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><p>&amp;emsp;&amp;emsp;本篇文章涉及到的所有完整代码如下：</p><figure class="highlight csharp"><figcaption><span>CameraFollow.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">CameraFollow</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;水平方向上最大偏移量&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> HorizontalMargin = <span class="hljs-number">2f</span>;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;竖直方向上最大偏移量&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> VerticalMargin = <span class="hljs-number">2f</span>;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;水平方向上跟随角色的速度&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> HorizontalFollowSpeed = <span class="hljs-number">2f</span>;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;竖直方向上跟随角色的速度&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> VerticalFollowSpeed = <span class="hljs-number">2f</span>;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;摄像机可移动的范围&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> BoxCollider2D Region;<br><br>    <span class="hljs-comment">// 摄像机中心点在水平方向上可移动的范围</span><br>    <span class="hljs-keyword">private</span> Vector2 m_HorizontalRegion;<br>    <span class="hljs-comment">// 摄像机中心点在竖直方向上可移动的范围</span><br>    <span class="hljs-keyword">private</span> Vector2 m_VerticalRegion;<br><br>    <span class="hljs-comment">// 角色Transform组件的引用</span><br>    <span class="hljs-keyword">private</span> Transform m_Player;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Awake</span>()</span> &#123;<br>        <span class="hljs-comment">// 获取引用</span><br>        m_Player = GameObject.FindGameObjectWithTag(<span class="hljs-string">&quot;Player&quot;</span>).transform;<br><br>        <span class="hljs-keyword">if</span>(m_Player == <span class="hljs-literal">null</span>) &#123;<br>            Debug.LogError(<span class="hljs-string">&quot;请添加Tag为Player的GameObject&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span> &#123;<br>        Camera camera = <span class="hljs-keyword">this</span>.GetComponent&lt;Camera&gt;();<br>        <br>        <span class="hljs-comment">// 获取视口右上角对应的世界坐标</span><br>        Vector3 cornerPos = camera.ViewportToWorldPoint(<span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">1f</span>, <span class="hljs-number">1f</span>, Mathf.Abs(transform.position.z)));<br><br>        <span class="hljs-comment">// 此时，摄像机的世界坐标就是视口中心点的世界坐标</span><br>        <span class="hljs-comment">// 计算摄像机视口的宽度</span><br>        <span class="hljs-built_in">float</span> cameraWidth = <span class="hljs-number">2</span> * (cornerPos.x - transform.position.x);<br>        <span class="hljs-comment">// 计算视口的高度</span><br>        <span class="hljs-built_in">float</span> cameraHeight = <span class="hljs-number">2</span> * (cornerPos.y - transform.position.y);<br><br><br>        <span class="hljs-comment">// 计算Box Collider2D中心点的世界坐标</span><br>        Vector2 regionPosition = <span class="hljs-keyword">new</span> Vector2(<br>            Region.transform.position.x + Region.offset.x,<br>            Region.transform.position.y + Region.offset.y<br>        );<br><br>        Debug.Log(regionPosition.x);<br>        Debug.Log(regionPosition.y);<br><br>        <span class="hljs-comment">// 计算Box Collider2D和摄像机视口的宽度差的一半</span><br>        <span class="hljs-built_in">float</span> halfDeltaWidth = (Region.size.x - cameraWidth) / <span class="hljs-number">2</span>;<br>        <span class="hljs-comment">// 计算Box Collider2D和摄像机视口的高度差的一半</span><br>        <span class="hljs-built_in">float</span> halfDeltaHeight = (Region.size.y - cameraHeight) / <span class="hljs-number">2</span>;<br><br>        <span class="hljs-keyword">if</span>(halfDeltaWidth &lt; <span class="hljs-number">0</span>) &#123;<br>            Debug.LogError(<span class="hljs-string">&quot;Box Collider2D的宽度小于摄像机视口的宽度&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(halfDeltaHeight &lt; <span class="hljs-number">0</span>) &#123;<br>            Debug.LogError(<span class="hljs-string">&quot;Box Collider2D的高度小于摄像机视口的高度&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 计算摄像机中心点水平方向上可移动的范围</span><br>        m_HorizontalRegion = <span class="hljs-keyword">new</span> Vector2(<br>            regionPosition.x - halfDeltaWidth,<br>            regionPosition.x + halfDeltaWidth<br>        );<br><br>        <span class="hljs-comment">// 计算摄像机中心点竖直方向上可移动的范围</span><br>        m_VerticalRegion = <span class="hljs-keyword">new</span> Vector2(<br>            regionPosition.y - halfDeltaHeight,<br>            regionPosition.y + halfDeltaHeight<br>        );<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">LateUpdate</span>()</span> &#123;<br>        TrackPlayer();<br>    &#125;<br><br>    <span class="hljs-comment">// 跟随玩家</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">TrackPlayer</span>()</span> &#123;<br>        <span class="hljs-built_in">float</span> targetX = transform.position.x;<br>        <span class="hljs-built_in">float</span> targetY = transform.position.y;<br><br>        <span class="hljs-comment">// 如果超出了偏移量，计算摄像机跟随后的位置</span><br>        <span class="hljs-keyword">if</span> (CheckHorizontalMargin()) &#123;<br>            targetX = Mathf.Lerp(transform.position.x, m_Player.position.x, HorizontalFollowSpeed * Time.deltaTime);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (CheckVerticalMargin()) &#123;<br>            targetY = Mathf.Lerp(transform.position.y, m_Player.position.y, VerticalFollowSpeed * Time.deltaTime);<br>        &#125;<br><br>        targetX = Mathf.Clamp(targetX, m_HorizontalRegion.x, m_HorizontalRegion.y);<br>        targetY = Mathf.Clamp(targetY, m_VerticalRegion.x, m_VerticalRegion.y);<br><br>        <span class="hljs-comment">// 更新摄像机的位置</span><br>        transform.position = <span class="hljs-keyword">new</span> Vector3(targetX, targetY, transform.position.z);<br>    &#125;<br><br>    <span class="hljs-comment">// 判断水平方向上是否超出了最大偏移量</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">CheckHorizontalMargin</span>()</span> &#123;<br>        <span class="hljs-keyword">return</span> Mathf.Abs(transform.position.x - m_Player.position.x) &gt; HorizontalMargin;<br>    &#125;<br><br>    <span class="hljs-comment">// 判断竖直方向上是否超出了最大偏移量</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">CheckVerticalMargin</span>()</span> &#123;<br>        <span class="hljs-keyword">return</span> Mathf.Abs(transform.position.y - m_Player.position.y) &gt; VerticalMargin;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="后言"><a href="#后言" class="headerlink" title="后言"></a>后言</h2><p>&amp;emsp;&amp;emsp;至此，我们已实现了摄像机跟随角色移动的功能，摄像机跟随的速度、摄像机与角色的偏移量以及摄像机可移动的范围可以根据自己的喜好进行设置。最后，本篇文章所做的修改，可以在<a href="https://github.com/AsanCai/PotatoGloryTutorial">PotatoGloryTutorial</a>这个仓库的<code>essay8</code>分支下看到，读者可以clone这个仓库到本地进行查看。</p><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://docs.unity3d.com/Manual/class-Camera.html">Unity的Camera</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
      <category>《土豆荣耀》</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《土豆荣耀》重构笔记（九）实现角色的血量控制功能</title>
    <link href="/posts/9a177db7/"/>
    <url>/posts/9a177db7/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&amp;emsp;&amp;emsp;本篇文章的内容是实现实现角色的血量控制功能，在开始实现之前，我们需要知道<code>角色血量控制功能</code>的需求是什么。</p><blockquote><p>角色血量控制功能的需求</p></blockquote><ol><li>角色头上需要显示一个跟随角色移动的<code>血量条</code>，实时显示角色当前的血量</li><li>角色的<code>最大血量</code>可以任意修改</li><li>角色<code>接触怪物</code>时会受伤，并播放受伤音效</li><li>角色受伤时，除了<code>减少相应的血量</code>，还需要有一个<code>向后击退</code>的效果</li><li>为了避免角色被怪物卡住时，出现不断受伤的问题，角色在受伤后，将在<code>短暂时间内</code>获得免伤效果</li><li>当角色<code>血量为0</code>时，角色死亡，播放死亡动画，游戏结束</li></ol><p>在弄清楚并整理好需求之后，我们开始一一实现这些功能。</p><hr><h2 id="制作血量条"><a href="#制作血量条" class="headerlink" title="制作血量条"></a>制作血量条</h2><p>&amp;emsp;&amp;emsp;首先，我们来制作血量条。因为<code>血量条</code>要一直跟随移动，所以我们不妨将<code>血量条</code>作为<code>Player</code>的子物体。在<code>Player</code>下新建一个名为<code>HealthBarDisplay</code>的空物体，然后将<code>Assets\Sprites\UI</code>下的<code>Health</code>以及<code>Health-bg</code>拖拽到<code>HealthBarDisplay</code>下面。</p><p><img src="https://github.com/AsanCai/BlogImage/raw/master/PotatoGloryTutorial/Essay9/Image1.png" alt="制作血量条"></p><blockquote><p>它们的具体属性如下：</p></blockquote><ul><li><code>HealthBarDisplay</code>: <ul><li><code>Position</code>: (0, 0, 0)</li></ul></li><li><code>Health</code>:<ul><li><code>Position</code>: (-0.8, 1.5, 0)</li><li><code>Color</code>: (0, 255, 0, 255)</li><li><code>Sorting Layer</code>: Character, <code>Order In Layer</code>: 4</li></ul></li><li><code>Health-bg</code>:<ul><li><code>Position</code>: (0, 1.5, 0)</li><li><code>Sorting Layer</code>: Character, <code>Order In Layer</code>: 4</li></ul></li></ul><p>&amp;emsp;&amp;emsp;此时，将<code>Health</code>的<code>Scale</code>属性的<code>X分量</code>缓慢<code>从1减少至0</code>，我们可以看到血量条逐渐变短。但为了避免角色在转向时，<code>血量条</code>跟着翻转，我们还需要在<code>PlayerController.cs</code>中加入以下代码：</p><figure class="highlight csharp"><figcaption><span>PlayerController.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PlayerController</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br>    ...<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;显示血量条的物体&quot;</span>)</span>]<br><span class="hljs-keyword">public</span> Transform HealthBarDisplay;<br><br>    ...<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Flip</span>()</span> &#123;<br>        ...<br><br>        <span class="hljs-keyword">if</span>(HealthBarDisplay != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-comment">// 在角色转向时翻转HealthBarDisplay，确保HealthBarDisplay不随角色转向而翻转</span><br>HealthBarDisplay.localScale = Vector3.Scale(<br><span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>),<br>HealthBarDisplay.localScale<br>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>Debug.LogWarning(<span class="hljs-string">&quot;请设置HealthBarDisplay&quot;</span>);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;接着，我们将<code>HealthBarDisplay</code>拖拽到<code>PlayerController.cs</code>下<code>HealthBarDisplay</code>属性的赋值框，然后<code>Health</code>的<code>Scale</code>设置为<code>(0.5, 1, 1)</code>，运行游戏，让角色左右翻转，可以看到<code>血量条</code>不随着角色转向而翻转。停止运行游戏，将<code>Health</code>的<code>Scale</code>设置为<code>(1, 1, 1)</code>，然后保存游戏，将我们所做的修改应用至<code>Player</code>对于的Prefab。</p><hr><h2 id="创建血量控制脚本"><a href="#创建血量控制脚本" class="headerlink" title="创建血量控制脚本"></a>创建血量控制脚本</h2><p>&amp;emsp;&amp;emsp;我们在<code>Assets\Scripts\Player</code>下创建一个名为<code>PlayerHealth</code>的C#脚本。因为角色的<code>最大血量</code>需要能被修改，角色受伤时不仅要<code>播放受伤音效</code>，还要有<code>向后击退</code>的效果，因此我们需要在<code>PlayerHealth.cs</code>脚本中添加以下代码：</p><figure class="highlight csharp"><figcaption><span>PlayerHealth.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PlayerHealth</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;角色的最大生命值&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> MaxHP = <span class="hljs-number">100f</span>;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;角色被怪物伤害时受到的击退力大小&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> HurtForce = <span class="hljs-number">100f</span>;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;角色受伤后的免伤时间&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> FreeDamagePeriod = <span class="hljs-number">0.35f</span>;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;角色的受伤音效&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> AudioClip[] OuchClips;<br>&#125;<br></code></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;添加完毕之后，将<code>PlayerHealth.cs</code>添加到物体<code>Player</code>上，并将<code>Assets\Audio\Player\Ouch</code>下的四个音频文件拖动到<code>OuchClips</code>的赋值框，然后保存修改。</p><p><img src="https://github.com/AsanCai/BlogImage/raw/master/PotatoGloryTutorial/Essay9/Image2.png" alt="设置音效"></p><hr><h2 id="实现接触怪物时受伤"><a href="#实现接触怪物时受伤" class="headerlink" title="实现接触怪物时受伤"></a>实现接触怪物时受伤</h2><p>&amp;emsp;&amp;emsp;在Unity中，当一个带<code>Collider2D</code>的物体和其他带有<code>Collider2D</code>的物体发生了碰撞时，将会触发<code>OnCollisionEnter2D</code>，我们可以通过<code>OnCollisionEnter2D</code>这个函数来获取物体的碰撞信息。那我们如何判断碰撞的物体是怪物呢？答案是利用Unity提供的<code>Tag</code>，通过设置<code>Tag</code>这一属性，我们可以方便地对物体进行标识。</p><p>&amp;emsp;&amp;emsp;选中<code>AlienSlug</code>，点击<code>Tag</code>下拉框，然后点击<code>Add Tag</code>，创建一个名为<code>Enemy</code>的Tag并将<code>AlienSlug</code>和<code>AlienShip</code>的Tag都设置为<code>Enemy</code>。最后，将<code>AlienSlug</code>和<code>AlienShip</code>的修改应用至Prefab。</p><p><img src="https://github.com/AsanCai/BlogImage/raw/master/PotatoGloryTutorial/Essay9/Image3.png" alt="创建Tag"></p><p>&amp;emsp;&amp;emsp;添加完成之后，我们在<code>PlayerHealth.cs</code>脚本中添加以下代码：</p><figure class="highlight csharp"><figcaption><span>PlayerHealth.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCollisionEnter2D</span>(<span class="hljs-params">Collision2D collision</span>)</span> &#123;<br>    <span class="hljs-comment">//假如撞到怪物</span><br>    <span class="hljs-keyword">if</span>(collision.gameObject.tag == <span class="hljs-string">&quot;Enemy&quot;</span>) &#123;<br>        Debug.Log(<span class="hljs-string">&quot;Enemy&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;运行游戏，控制人物移动去接触怪物，可以看到<code>Console</code>输出<code>Enemy</code>字符串，说明已经检测到了角色和怪物发生碰撞。接下来，我们在<code>PlayerHealth.cs</code>加入角色受伤的代码：</p><figure class="highlight csharp"><figcaption><span>PlayerHealth.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PlayerHealth</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br>    ...<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;角色受伤时减少的血量&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> DamageAmount = <span class="hljs-number">10f</span>;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;角色受伤后的免伤时间&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> FreeDamagePeriod = <span class="hljs-number">0.35f</span>;<br><br>    <span class="hljs-comment">// 角色当前的血量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">float</span> m_CurrentHP;<br>    <span class="hljs-comment">// 上一次受到伤害的时间</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">float</span> m_LastFreeDamageTime;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span> &#123;<br>        <span class="hljs-comment">// 初始化变量</span><br>        m_CurrentHP = MaxHP;<br>        m_LastFreeDamageTime = <span class="hljs-number">0f</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCollisionEnter2D</span>(<span class="hljs-params">Collision2D collision</span>)</span> &#123;<br>        <span class="hljs-comment">// 判断此时是否处于免伤状态</span><br>        <span class="hljs-keyword">if</span>(Time.time &gt; m_LastFreeDamageTime + FreeDamagePeriod) &#123;<br>            <span class="hljs-comment">// 假如撞到怪物</span><br>            <span class="hljs-keyword">if</span>(collision.gameObject.tag == <span class="hljs-string">&quot;Enemy&quot;</span>) &#123;<br>                <span class="hljs-comment">// 检测当前血量</span><br>                <span class="hljs-keyword">if</span>(m_CurrentHP &gt; <span class="hljs-number">0f</span>) &#123;<br>                    <span class="hljs-comment">// 调用受伤函数</span><br>                    TakeDamage(collision.transform);<br>                    <br>                    <span class="hljs-comment">// 更新上次受伤害的时间</span><br>                    m_LastFreeDamageTime = Time.time;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// 角色死亡</span><br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 受伤函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">TakeDamage</span>(<span class="hljs-params">Transform enemy</span>)</span> &#123;<br>        <span class="hljs-comment">// 给角色加上后退的力，制造击退效果</span><br>        Vector3 hurtVector = transform.position - enemy.position + Vector3.up * <span class="hljs-number">5f</span>;<br>        GetComponent&lt;Rigidbody2D&gt;().AddForce(hurtVector * HurtForce);<br><br>        <span class="hljs-comment">// 更新角色的生命值</span><br>        m_CurrentHP -= DamageAmount;<br><br>        <span class="hljs-comment">// 更新生命条</span><br>        Debug.Log(m_CurrentHP);<br><br>        <span class="hljs-comment">// 随机播放音频</span><br>        <span class="hljs-built_in">int</span> i = Random.Range(<span class="hljs-number">0</span>, OuchClips.Length);<br>        AudioSource.PlayClipAtPoint(OuchClips[i], transform.position);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;运行游戏，控制人物移动去接触怪物，可以看到角色在触碰怪物时，角色会受到一个击退力的作用，同时<code>Console</code>窗口输出当前的生命值。</p><hr><h2 id="更新血量条的显示"><a href="#更新血量条的显示" class="headerlink" title="更新血量条的显示"></a>更新血量条的显示</h2><p>&amp;emsp;&amp;emsp;接下来，我们要根据角色当前的生命值来实时更新血量条的显示，也就是我们需要根据角色当前的生命值，来更新<code>HealthBarDisplay</code>的子物体<code>Health</code>的<code>Scale</code>和<code>Color</code>。我们在<code>PlayerHealth.cs</code>中加入以下代码：</p><figure class="highlight csharp"><figcaption><span>PlayerHealth.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PlayerHealth</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br>    ...<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;血量条&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> SpriteRenderer HealthSprite;<br><br>    ...<br>    <span class="hljs-comment">// 血量条的初始长度</span><br>    <span class="hljs-keyword">private</span> Vector3 m_InitHealthScale;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span> &#123;<br><span class="hljs-comment">// 初始化变量</span><br>...<br>m_InitHealthScale = HealthSprite.transform.localScale;<br>&#125;<br><br>    <span class="hljs-comment">//受伤函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">TakeDamage</span>(<span class="hljs-params">Transform enemy</span>)</span> &#123;<br>        ...<br><br>        <span class="hljs-comment">// 更新生命条</span><br>        UpdateHealthBar();<br><br>        ...<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">UpdateHealthBar</span>()</span> &#123;<br>        <span class="hljs-keyword">if</span>(HealthSprite != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 更新血量条颜色</span><br>            HealthSprite.color = Color.Lerp(Color.green, Color.red, <span class="hljs-number">1</span> - m_CurrentHP * <span class="hljs-number">0.01f</span>);<br>            <span class="hljs-comment">// 更新血量条长度</span><br>            HealthSprite.transform.localScale = Vector3.Scale(m_InitHealthScale, <span class="hljs-keyword">new</span> Vector3(m_CurrentHP * <span class="hljs-number">0.01f</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>));<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            Debug.LogError(<span class="hljs-string">&quot;请设置HealthSprite&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;将<code>HealthBarDisplay</code>的子物体<code>Health</code>拖动到<code>HealthSprite</code>的赋值框，运行游戏，控制人物移动去接触怪物，可以看到当角色的生命值变化时，<code>血量条</code>也随之更新。</p><hr><h2 id="控制角色的死亡"><a href="#控制角色的死亡" class="headerlink" title="控制角色的死亡"></a>控制角色的死亡</h2><p>&amp;emsp;&amp;emsp;最后，我们还需要控制角色的死亡。我们知道，当角色死亡时，<code>不能再和场景中的任何物体发生交互</code>，<code>玩家也不能再控制角色</code>。因此，我们在<code>PlayerHealth.cs</code>中加入以下代码：</p><figure class="highlight csharp"><figcaption><span>PlayerHealth.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PlayerHealth</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br>    ...<br><br>    <span class="hljs-comment">//受伤函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">TakeDamage</span>(<span class="hljs-params">Transform enemy</span>)</span> &#123;<br>        ...<br><br>        <span class="hljs-comment">// 检测当前血量</span><br>        <span class="hljs-keyword">if</span>(m_CurrentHP &gt; <span class="hljs-number">0f</span>) &#123;<br>            ...<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 角色死亡</span><br>            Death();<br>        &#125;<br><br>        ...<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Death</span>()</span> &#123;<br>        <span class="hljs-comment">// 禁用碰撞体</span><br>        Collider2D[] cols = GetComponents&lt;Collider2D&gt;();<br>        <span class="hljs-keyword">foreach</span>(Collider2D c <span class="hljs-keyword">in</span> cols) &#123;<br>            c.enabled = <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 禁用脚本</span><br>        GetComponent&lt;PlayerController&gt;().enabled = <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-comment">// 播放死亡动画</span><br>        GetComponent&lt;Animator&gt;().SetTrigger(<span class="hljs-string">&quot;Death&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;运行游戏，控制人物移动去接触怪物，可以看到当角色的<code>生命值减少至0</code>时，角色播放死亡动画，且不与场景中的其他物体发生交互，玩家也不能再控制角色。将<code>Player</code>的修改应用至Prefab，并保存场景产生的修改。</p><hr><h2 id="PlayerHealth-cs的完整代码"><a href="#PlayerHealth-cs的完整代码" class="headerlink" title="PlayerHealth.cs的完整代码"></a>PlayerHealth.cs的完整代码</h2><p>&amp;emsp;&amp;emsp;此时，<code>PlayerHealth.cs</code>的完整代码如下所示：</p><figure class="highlight csharp"><figcaption><span>PlayerHealth.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PlayerHealth</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;角色的最大生命值&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> MaxHP = <span class="hljs-number">100f</span>;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;角色被怪物伤害时受到的击退力大小&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> HurtForce = <span class="hljs-number">100f</span>;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;角色的受伤音效&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> AudioClip[] OuchClips;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;角色受伤时减少的血量&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> DamageAmount = <span class="hljs-number">10f</span>;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;角色受伤后的免伤时间&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> FreeDamagePeriod = <span class="hljs-number">0.35f</span>;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;血量条&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> SpriteRenderer HealthSprite;<br><br>    <span class="hljs-comment">// 角色当前的血量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">float</span> m_CurrentHP;<br>    <span class="hljs-comment">// 上一次受到伤害的时间</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">float</span> m_LastFreeDamageTime;<br>    <span class="hljs-comment">// 血量条的初始长度</span><br>    <span class="hljs-keyword">private</span> Vector3 m_InitHealthScale;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span> &#123;<br>        <span class="hljs-comment">// 初始化变量</span><br>        m_CurrentHP = MaxHP;<br>        m_LastFreeDamageTime = <span class="hljs-number">0f</span>;<br>        m_InitHealthScale = HealthSprite.transform.localScale;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCollisionEnter2D</span>(<span class="hljs-params">Collision2D collision</span>)</span> &#123;<br>        <span class="hljs-comment">// 判断此时是否处于免伤状态</span><br>        <span class="hljs-keyword">if</span>(Time.time &gt; m_LastFreeDamageTime + FreeDamagePeriod) &#123;<br>            <span class="hljs-comment">// 假如撞到怪物</span><br>            <span class="hljs-keyword">if</span>(collision.gameObject.tag == <span class="hljs-string">&quot;Enemy&quot;</span>) &#123;<br>                <span class="hljs-comment">// 检测当前血量</span><br>                <span class="hljs-keyword">if</span>(m_CurrentHP &gt; <span class="hljs-number">0f</span>) &#123;<br>                    <span class="hljs-comment">// 调用受伤函数</span><br>                    TakeDamage(collision.transform);<br>                    <br>                    <span class="hljs-comment">// 更新上次受伤害的时间</span><br>                    m_LastFreeDamageTime = Time.time;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// 角色死亡</span><br>                    Death();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 受伤函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">TakeDamage</span>(<span class="hljs-params">Transform enemy</span>)</span> &#123;<br>        <span class="hljs-comment">// 给角色加上后退的力，制造击退效果</span><br>        Vector3 hurtVector = transform.position - enemy.position + Vector3.up * <span class="hljs-number">5f</span>;<br>        GetComponent&lt;Rigidbody2D&gt;().AddForce(hurtVector * HurtForce);<br><br>        <span class="hljs-comment">// 更新角色的生命值</span><br>        m_CurrentHP -= DamageAmount;<br><br>        <span class="hljs-comment">// 更新生命条</span><br>        UpdateHealthBar();<br><br>        <span class="hljs-comment">// 随机播放音频</span><br>        <span class="hljs-built_in">int</span> i = Random.Range(<span class="hljs-number">0</span>, OuchClips.Length);<br>        AudioSource.PlayClipAtPoint(OuchClips[i], transform.position);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">UpdateHealthBar</span>()</span> &#123;<br>        <span class="hljs-keyword">if</span>(HealthSprite != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 更新血量条颜色</span><br>            HealthSprite.color = Color.Lerp(Color.green, Color.red, <span class="hljs-number">1</span> - m_CurrentHP * <span class="hljs-number">0.01f</span>);<br>            <span class="hljs-comment">// 更新血量条长度</span><br>            HealthSprite.transform.localScale = Vector3.Scale(m_InitHealthScale, <span class="hljs-keyword">new</span> Vector3(m_CurrentHP * <span class="hljs-number">0.01f</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>));<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            Debug.LogError(<span class="hljs-string">&quot;请设置HealthSprite&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Death</span>()</span> &#123;<br>        <span class="hljs-comment">// 禁用碰撞体</span><br>        Collider2D[] cols = GetComponents&lt;Collider2D&gt;();<br>        <span class="hljs-keyword">foreach</span>(Collider2D c <span class="hljs-keyword">in</span> cols) &#123;<br>            c.enabled = <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 禁用脚本</span><br>        GetComponent&lt;PlayerController&gt;().enabled = <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-comment">// 播放死亡动画</span><br>        GetComponent&lt;Animator&gt;().SetTrigger(<span class="hljs-string">&quot;Death&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="后言"><a href="#后言" class="headerlink" title="后言"></a>后言</h2><p>&amp;emsp;&amp;emsp;至此，我们已经完成了角色的血量控制功能，本篇文章提到的数值参数都可以根据自己的喜好进行调整。最后，本篇文章所做的修改，可以在<a href="https://github.com/AsanCai/PotatoGloryTutorial">PotatoGloryTutorial</a>这个仓库的<code>essay7</code>分支下看到，读者可以clone这个仓库到本地进行查看。</p><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://docs.unity3d.com/Manual/Tags.html">Tags</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
      <category>《土豆荣耀》</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《土豆荣耀》重构笔记（八）给角色添加动画</title>
    <link href="/posts/d472be5c/"/>
    <url>/posts/d472be5c/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&amp;emsp;&amp;emsp;为了提高玩家的游戏体验，我们常常需要在角色运动的时候，根据它的运动状态播放对应的动画。为了能够控制当前播放什么动画，我们首先需要制作<a href="https://docs.unity3d.com/Manual/class-AnimatorController.html">动画状态机</a>，再用代码去控制动画状态机切换当前的状态，从而切换当前播放的动画。</p><hr><h2 id="制作角色的动画状态机"><a href="#制作角色的动画状态机" class="headerlink" title="制作角色的动画状态机"></a>制作角色的动画状态机</h2><p>&amp;emsp;&amp;emsp;我们在给角色制作动画状态机来控制我们之前制作好的角色动画之前，我们需要确定我们<code>有哪些状态</code>，以及控制这些<code>状态转移的条件</code>是什么。</p><blockquote><p>各个角色动画之间的状态转换规则如下：</p></blockquote><ol><li>当角色不<code>着地</code>时，不播放任何状态</li><li>角色<code>着地</code>时播放Idle播放动画</li><li>当角色<code>着地</code>且<code>水平移动</code>时，播放Walk动画</li><li>当角色触发<code>跳跃</code>事件时，播放Jump动画</li><li>Jump动画播放完之后，<code>着地</code>播放Idle动画</li><li>当角色触发<code>射击</code>事件时，播放Shoot动画</li><li>Shoot动画播放完之后，<code>着地</code>播放Idle动画</li><li>当角色触发<code>死亡</code>事件时，播放Death动画</li><li>Death动画播放完之后，自动播放Falling动画</li></ol><p>&amp;emsp;&amp;emsp;根据状态转换规则，我们可以得出控制状态转换的所有参数</p><blockquote><p>状态转换参数：</p></blockquote><ul><li>Grounded：Bool</li><li>Speed：Float</li><li>Jump：Trigger</li><li>Death：Trigger</li><li>Shoot：Trigger</li></ul><p>&amp;emsp;&amp;emsp;接着，我们在Unity顶部菜单栏选中<code>Window-&gt;Animator</code>打开动画状态机编辑窗口，然后在<code>Hierarchy</code>窗口中选中<code>Player</code>编辑角色的动画状态机。在Unity中，一个状态控制一个动画。根据上面状态转换规则，我们还需要创建一个没有任何动画的空状态，并将其作为整个状态机的默认状态。我们在<code>Animator</code>窗口中点击鼠标右键选择<code>Empty</code>创建一个空状态，将其命名为<code>Empty</code>之后，点击鼠标右键编辑这个状态，然后选择<code>Set as Layer Default State</code>将其设置为默认状态。最后，我们根据上面得到的控制状态转换的所有参数来创建状态转换参数，并构建角色的动画状态机如下：</p><p><img src="https://github.com/AsanCai/BlogImage/raw/master/PotatoGloryTutorial/Essay8/Image1.png" alt="创建状态机"></p><p>&amp;emsp;&amp;emsp;创建完动画状态机之后，我们为状态之间的转移边设置条件。点击状态之间的转移边，然后在右侧的Inspector面板进行设置。</p><p><img src="https://github.com/AsanCai/BlogImage/raw/master/PotatoGloryTutorial/Essay8/Image2.png" alt="设置转移边"></p><blockquote><p>每条转移边的具体设置如下：</p></blockquote><ul><li>Empty -&gt; Idle:<ul><li>Has Exit Time: <code>false</code></li><li>Interruption Source”: <code>Next State</code></li><li>Conditions: <code>Grounded(true)</code></li></ul></li><li>Idle -&gt; Empty:<ul><li>Has Exit Time: <code>false</code></li><li>Conditions: <code>Grounded(false)</code></li></ul></li><li>Idle -&gt; Walk:<ul><li>Has Exit Time: <code>false</code></li><li>Conditions: <code>Speed(Greater 0.1)</code></li></ul></li><li>Walk -&gt; Idle:<ul><li>Has Exit Time: <code>false</code></li><li>Interruption Source”: <code>Next State</code></li><li>Conditions: <code>Speed(Less 0.1)</code></li></ul></li><li>Walk -&gt; Empty:<ul><li>Has Exit Time: <code>false</code></li><li>Conditions: <code>Grounded(false)</code></li></ul></li><li>AnyState -&gt; Jump:<ul><li>Has Exit Time: <code>false</code></li><li>Can Transition To Self: <code>false</code></li><li>Conditions: <code>Jump(Trigger)</code></li></ul></li><li>Jump -&gt; Empty:<ul><li>Has Exit Time: <code>true</code></li><li>Interruption Source”: <code>Next State</code></li><li>Conditions: List is Empty</li></ul></li><li>AnyState -&gt; Shoot:<ul><li>Has Exit Time: <code>false</code></li><li>Can Transition To Self: <code>True</code></li><li>Conditions: <code>Shoot(Trigger)</code></li></ul></li><li>Shoot -&gt; Empty:<ul><li>Has Exit Time: <code>true</code></li><li>Interruption Source”: <code>Current State then Next State</code></li><li>Conditions: List is Empty</li></ul></li><li>AnyState -&gt; Death:<ul><li>Has Exit Time: <code>false</code></li><li>Can Transition To Self: <code>false</code></li><li>Conditions: <code>Death(Trigger)</code></li></ul></li><li>Death -&gt; Falling:<ul><li>Has Exit Time: <code>true</code></li><li>Conditions: List is Empty</li></ul></li></ul><hr><h2 id="加入控制代码"><a href="#加入控制代码" class="headerlink" title="加入控制代码"></a>加入控制代码</h2><p>&amp;emsp;&amp;emsp;角色的动画状态机编辑完成之后，我们还需要使用代码来控制动画状态机的状态转移。打开<code>PlayerController.cs</code>，插入动画控制代码：</p><figure class="highlight csharp"><figcaption><span>PlayerController.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br>[<span class="hljs-meta">RequireComponent(typeof(Rigidbody2D))</span>]<br>[<span class="hljs-meta">RequireComponent(typeof(AudioSource))</span>]<br>[<span class="hljs-meta">RequireComponent(typeof(Animator))</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PlayerController</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;角色初始朝向是否朝向右边&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> FacingRight = <span class="hljs-literal">true</span>;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;移动时角色加速的力大小&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> MoveForce = <span class="hljs-number">365f</span>;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;角色移动的最大速度&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> MaxSpeed = <span class="hljs-number">5f</span>;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;跳跃时向上加速的力大小&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> JumpForce = <span class="hljs-number">1000f</span>;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;检测角色是否落地&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> Transform GroundCheck;<br><br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;跳跃音效&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> AudioClip[] JumpClips;<br><br>    <span class="hljs-comment">// 记录角色当前是否处于准备跳跃状态</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">bool</span> m_IsReadyToJump;<br>    <span class="hljs-comment">// 记录角色当前是否正处于跳跃状态</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">bool</span> m_IsJumping;<br>    <span class="hljs-comment">// 记录角色当前是否处于着地状态</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">bool</span> m_GroundedStatus;<br><br>    <span class="hljs-comment">// 组件引用变量</span><br>    <span class="hljs-keyword">private</span> Rigidbody2D m_Rigidbody2D;<br>    <span class="hljs-keyword">private</span> AudioSource m_AudioSource;<br>    <span class="hljs-keyword">private</span> Animator m_Animator;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Awake</span>()</span> &#123;<br>        <span class="hljs-comment">// 获取组件引用</span><br>        m_Rigidbody2D = GetComponent&lt;Rigidbody2D&gt;();<br>        m_AudioSource = GetComponent&lt;AudioSource&gt;();<br>        m_Animator = GetComponent&lt;Animator&gt;();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span> &#123;<br>        <span class="hljs-comment">// 监测变量是否正确赋值</span><br>        <span class="hljs-keyword">if</span>(GroundCheck == <span class="hljs-literal">null</span>) &#123;<br>            Debug.LogError(<span class="hljs-string">&quot;请先设置GroundCheck&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 初始化变量</span><br>        m_IsReadyToJump = <span class="hljs-literal">false</span>;<br>        m_IsJumping = <span class="hljs-literal">false</span>;<br>        m_GroundedStatus = <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>()</span> &#123;<br>        <span class="hljs-comment">// 通过检测角色和groundCheck之间是否存在Ground层的物体来判断当前是否落地</span><br>        m_GroundedStatus = Physics2D.Linecast(<br>            transform.position,<br>            GroundCheck.position,<br>            LayerMask.GetMask(<span class="hljs-string">&quot;Obstacle&quot;</span>)<br>        );<br>        <br>        <span class="hljs-comment">// 设置动画状态机控制参数</span><br>        m_Animator.SetBool(<span class="hljs-string">&quot;Grounded&quot;</span>, m_GroundedStatus);<br><br>        <span class="hljs-comment">// 着地时，如果当前不处于跳跃状态且按下了跳跃键，进入准备跳跃状态</span><br>        <span class="hljs-keyword">if</span>(m_GroundedStatus &amp;&amp; !m_IsJumping &amp;&amp; Input.GetButtonDown(<span class="hljs-string">&quot;Jump&quot;</span>)) &#123;<br>            m_IsReadyToJump = <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 刚刚落地，退出跳跃状态</span><br>        <span class="hljs-keyword">if</span>(m_GroundedStatus &amp;&amp; m_IsJumping) &#123;<br>            m_IsJumping = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">FixedUpdate</span>()</span> &#123;<br>        <span class="hljs-comment">//获取水平输入</span><br>        <span class="hljs-built_in">float</span> h = Input.GetAxis(<span class="hljs-string">&quot;Horizontal&quot;</span>);<br><br>        <span class="hljs-comment">// 设置动画状态机控制参数</span><br>        m_Animator.SetFloat(<span class="hljs-string">&quot;Speed&quot;</span>, Mathf.Abs(h));<br><br>        <span class="hljs-comment">// 若h * m_Rigidbody2D.velocity.x为正数且小于MaxSpeed，表示需要继续加速</span><br>        <span class="hljs-comment">// 若h * m_Rigidbody2D.velocity.x为负数，则表示需要反向加速</span><br>        <span class="hljs-keyword">if</span>(h * m_Rigidbody2D.velocity.x &lt; MaxSpeed) &#123;<br>            m_Rigidbody2D.AddForce(Vector2.right * h * MoveForce);<br>        &#125;<br><br>        <span class="hljs-comment">//设置物体速度的阈值</span><br>        <span class="hljs-keyword">if</span>(Mathf.Abs(m_Rigidbody2D.velocity.x) &gt; MaxSpeed) &#123;<br>            m_Rigidbody2D.velocity = <span class="hljs-keyword">new</span> Vector2(<br>                Mathf.Sign(m_Rigidbody2D.velocity.x) * MaxSpeed,<br>                m_Rigidbody2D.velocity.y<br>            );<br>        &#125;<br><br>        <span class="hljs-comment">//判断当前是否需要转向</span><br>        <span class="hljs-keyword">if</span>(h &gt; <span class="hljs-number">0</span> &amp;&amp; !FacingRight) &#123;<br>            Flip();<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(h &lt; <span class="hljs-number">0</span> &amp;&amp; FacingRight) &#123;<br>            Flip();<br>        &#125;<br><br>        <span class="hljs-comment">// 跳跃</span><br>        <span class="hljs-keyword">if</span>(m_IsReadyToJump) &#123;<br>            Jump();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Jump</span>()</span> &#123;<br>        <span class="hljs-comment">// 进入跳跃状态</span><br>        m_IsJumping = <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-comment">// 设置一个竖直向上的力</span><br>        m_Rigidbody2D.AddForce(<span class="hljs-keyword">new</span> Vector2(<span class="hljs-number">0f</span>, JumpForce));<br><br>        <span class="hljs-comment">// 设置动画状态机控制参数</span><br>        m_Animator.SetTrigger(<span class="hljs-string">&quot;Jump&quot;</span>);<br><br>        <span class="hljs-comment">// 退出准备跳跃状态，避免重复跳跃</span><br>        m_IsReadyToJump = <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-comment">//随机在角色当前所处的位置播放一个跳跃的音频</span><br>        <span class="hljs-keyword">if</span>(JumpClips.Length &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">int</span> i = Random.Range(<span class="hljs-number">0</span>, JumpClips.Length);<br>            AudioSource.PlayClipAtPoint(JumpClips[i], transform.position);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Flip</span>()</span> &#123;<br>        <span class="hljs-comment">// 修改当前朝向</span><br>        FacingRight = !FacingRight;<br><br>        <span class="hljs-comment">// 修改scale的x分量实现转向</span><br>        <span class="hljs-keyword">this</span>.transform.localScale = Vector3.Scale(<br>            <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>),<br>            <span class="hljs-keyword">this</span>.transform.localScale<br>        );<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="修改动画和状态设置"><a href="#修改动画和状态设置" class="headerlink" title="修改动画和状态设置"></a>修改动画和状态设置</h2><p>&amp;emsp;&amp;emsp;点击运行游戏，可以看到角色已经有了动画。但是，我们发现角色跳跃的时候，一直在重复播放<code>Jump</code>动画。这是因为我们在制作动画的时候，为了便于预览，Unity默认将我们的动画设置为循环动画。我们需要修改一下<code>Jump</code>、<code>Shoot</code>和<code>Death</code>这三个动画的动画设置。打开<code>Assets\Animation\Player</code>，分别选中这三个动画，然后取消<code>Loop Time</code>的勾选。</p><p><img src="https://github.com/AsanCai/BlogImage/raw/master/PotatoGloryTutorial/Essay8/Image3.png" alt="修改动画设置"></p><p>&amp;emsp;&amp;emsp;此外，为了让优化动画效果，我们还可以在<code>Animator</code>设置各个状态的动画播放速度。这里，我们将<code>Jump</code>和<code>Shoot</code>这两个状态的<code>Speed</code>分别设置为<code>2.5</code>和<code>4</code>。</p><p><img src="https://github.com/AsanCai/BlogImage/raw/master/PotatoGloryTutorial/Essay8/Image4.png" alt="修改状态设置"></p><p>&amp;emsp;&amp;emsp;修改完成之后，再次运行游戏，可以看到<code>Jump</code>动画的播放速度变快了。</p><hr><h2 id="后言"><a href="#后言" class="headerlink" title="后言"></a>后言</h2><p>&amp;emsp;&amp;emsp;至此，我们已经制作好了角色的动画状态机，并使用代码控制<code>Idle</code>、<code>Walk</code>和<code>Jump</code>这三个动画的切换，剩下的动画控制将在后面提到。最后，本篇文章所做的修改，可以在<a href="https://github.com/AsanCai/PotatoGloryTutorial">PotatoGloryTutorial</a>这个仓库的<code>essay6</code>分支下看到，读者可以clone这个仓库到本地进行查看。</p><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://docs.unity3d.com/Manual/class-AnimatorController.html">Animator Controller</a></li><li><a href="https://docs.unity3d.com/Manual/class-State.html">Animation States</a></li><li><a href="https://docs.unity3d.com/Manual/class-Transition.html">Animation transitions</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
      <category>《土豆荣耀》</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《土豆荣耀》重构笔记（七）控制角色移动并添加音效</title>
    <link href="/posts/ce911e84/"/>
    <url>/posts/ce911e84/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&amp;emsp;&amp;emsp;为了便于测试，我们会先使用<code>PC端的键盘和鼠标输入</code>来控制人物的移动，等到功能测试完成之后，再将<code>PC端的键盘和鼠标输入</code>换成移动端的<code>虚拟摇杆和按钮输入</code>。这里，我们首先使用<code>PC端的键盘和鼠标输入</code>来实现控制角色进行移动的功能。</p><hr><h2 id="为角色添加Collider和Rigidbody"><a href="#为角色添加Collider和Rigidbody" class="headerlink" title="为角色添加Collider和Rigidbody"></a>为角色添加Collider和Rigidbody</h2><p>&amp;emsp;&amp;emsp;为了让角色具有物理属性，我们需要为角色添加Collider和Rigidbody。此外，为了避免角色出现翻滚的问题，让角色一直保持直立，因此我们需要在<code>Rigidbody2D</code>的<code>Constraints</code>属性里设置勾选<code>Freeze Rotation Z</code>，不让角色在进行物理模拟时，绕Z轴进行旋转。</p><p><img src="https://github.com/AsanCai/BlogImage/raw/master/PotatoGloryTutorial/Essay7/Image1.png" alt="角色添加的组件信息"></p><hr><h2 id="控制角色移动"><a href="#控制角色移动" class="headerlink" title="控制角色移动"></a>控制角色移动</h2><p>&amp;emsp;&amp;emsp;接下来，我们开始编写脚本来实现让怪物在场景中移动的功能。我们在<code>Assets\Scripts</code>文件夹下创建一个名为<code>Player</code>的文件夹用于保存和角色相关的脚本。创建完毕后，我们在<code>Player</code>文件夹下创建一个名为<code>PlayerController</code>的C#脚本，然后添加以下代码：</p><figure class="highlight csharp"><figcaption><span>PlayerController.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br>[<span class="hljs-meta">RequireComponent(typeof(Rigidbody2D))</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PlayerController</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;角色初始朝向是否朝向右边&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> FacingRight = <span class="hljs-literal">true</span>;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;移动时角色加速的力大小&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> MoveForce = <span class="hljs-number">365f</span>;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;角色移动的最大速度&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> MaxSpeed = <span class="hljs-number">5f</span>;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;跳跃时向上加速的力大小&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> JumpForce = <span class="hljs-number">1000f</span>;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;检测角色是否落地&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> Transform GroundCheck;<br><br>    <span class="hljs-comment">// 记录角色当前是否处于准备跳跃状态</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">bool</span> m_IsReadyToJump;<br>    <span class="hljs-comment">// 记录角色当前是否正处于跳跃状态</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">bool</span> m_IsJumping;<br>    <span class="hljs-comment">// 记录角色当前是否处于着地状态</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">bool</span> m_GroundedStatus;<br><br>    <span class="hljs-comment">// 组件引用变量</span><br>    <span class="hljs-keyword">private</span> Rigidbody2D m_Rigidbody2D;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Awake</span>()</span> &#123;<br>        <span class="hljs-comment">// 获取组件引用</span><br>        m_Rigidbody2D = GetComponent&lt;Rigidbody2D&gt;();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span> &#123;<br>        <span class="hljs-comment">// 监测变量是否正确赋值</span><br>        <span class="hljs-keyword">if</span>(GroundCheck == <span class="hljs-literal">null</span>) &#123;<br>            Debug.LogError(<span class="hljs-string">&quot;请先设置GroundCheck&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 初始化变量</span><br>        m_IsReadyToJump = <span class="hljs-literal">false</span>;<br>        m_IsJumping = <span class="hljs-literal">false</span>;<br>        m_GroundedStatus = <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>()</span> &#123;<br>        <span class="hljs-comment">// 通过检测角色和groundCheck之间是否存在Ground层的物体来判断当前是否落地</span><br>        m_GroundedStatus = Physics2D.Linecast(<br>            transform.position,<br>            GroundCheck.position,<br>            LayerMask.GetMask(<span class="hljs-string">&quot;Obstacle&quot;</span>)<br>        );<br>        <br>        <span class="hljs-comment">// 着地时，如果当前不处于跳跃状态且按下了跳跃键，进入准备跳跃状态</span><br>        <span class="hljs-keyword">if</span>(m_GroundedStatus &amp;&amp; !m_IsJumping &amp;&amp; Input.GetButtonDown(<span class="hljs-string">&quot;Jump&quot;</span>)) &#123;<br>            m_IsReadyToJump = <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 刚刚落地，退出跳跃状态</span><br>        <span class="hljs-keyword">if</span>(m_GroundedStatus &amp;&amp; m_IsJumping) &#123;<br>            m_IsJumping = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">FixedUpdate</span>()</span> &#123;<br>        <span class="hljs-comment">//获取水平输入</span><br>        <span class="hljs-built_in">float</span> h = Input.GetAxis(<span class="hljs-string">&quot;Horizontal&quot;</span>);<br><br>        <span class="hljs-comment">// 若h * m_Rigidbody2D.velocity.x为正数且小于MaxSpeed，表示需要继续加速</span><br>        <span class="hljs-comment">// 若h * m_Rigidbody2D.velocity.x为负数，则表示需要反向加速</span><br>        <span class="hljs-keyword">if</span>(h * m_Rigidbody2D.velocity.x &lt; MaxSpeed) &#123;<br>            m_Rigidbody2D.AddForce(Vector2.right * h * MoveForce);<br>        &#125;<br><br>        <span class="hljs-comment">//设置物体速度的阈值</span><br>        <span class="hljs-keyword">if</span>(Mathf.Abs(m_Rigidbody2D.velocity.x) &gt; MaxSpeed) &#123;<br>            m_Rigidbody2D.velocity = <span class="hljs-keyword">new</span> Vector2(<br>                Mathf.Sign(m_Rigidbody2D.velocity.x) * MaxSpeed,<br>                m_Rigidbody2D.velocity.y<br>            );<br>        &#125;<br><br>        <span class="hljs-comment">//判断当前是否需要转向</span><br>        <span class="hljs-keyword">if</span>(h &gt; <span class="hljs-number">0</span> &amp;&amp; !FacingRight) &#123;<br>            Flip();<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(h &lt; <span class="hljs-number">0</span> &amp;&amp; FacingRight) &#123;<br>            Flip();<br>        &#125;<br><br>        <span class="hljs-comment">// 跳跃</span><br>        <span class="hljs-keyword">if</span>(m_IsReadyToJump) &#123;<br>            Jump();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Jump</span>()</span> &#123;<br>        <span class="hljs-comment">// 进入跳跃状态</span><br>        m_IsJumping = <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-comment">// 设置一个竖直向上的力</span><br>        m_Rigidbody2D.AddForce(<span class="hljs-keyword">new</span> Vector2(<span class="hljs-number">0f</span>, JumpForce));<br><br>        <span class="hljs-comment">// 退出准备跳跃状态，避免重复跳跃</span><br>        m_IsReadyToJump = <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Flip</span>()</span> &#123;<br>        <span class="hljs-comment">// 修改当前朝向</span><br>        FacingRight = !FacingRight;<br><br>        <span class="hljs-comment">// 修改scale的x分量实现转向</span><br>        <span class="hljs-keyword">this</span>.transform.localScale = Vector3.Scale(<br>            <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>),<br>            <span class="hljs-keyword">this</span>.transform.localScale<br>        );<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>代码说明：</p></blockquote><ul><li>Input.GetAxis(“Horizontal”)：Unity提供的默认输入项，能获取键盘上<code>A\D</code>键和<code>&lt;-\-&gt;</code>方向键的输入</li><li>Input.GetButtonDown(“Jump”)：Unity提供的默认输入项，能获取键盘上空格键的输入</li><li>Physics2D.Linecast：来获取场景里两个点之间属于某个Layer的所有Collider</li><li>因为<code>和角色物理模拟有关的操作都应该在FixedUpdate里执行</code>，所以Jump函数需要在FixedUpdate里调用</li><li>我们为了避免出现多次按跳跃键导致Jump函数被多次调用的问题，我们使用变量<code>m_IsJumping</code>来判断当前是否处于跳跃状态</li></ul><hr><h2 id="添加Physics-Material"><a href="#添加Physics-Material" class="headerlink" title="添加Physics Material"></a>添加Physics Material</h2><p>&amp;emsp;&amp;emsp;添加完成后，将<code>PlayerController.cs</code>添加到<code>Hierarchy</code>窗口的<code>Player</code>上，运行游戏，我们发现角色在运动时，会出现很明显的滑动现象。这是因为我们没有为角色和平台上的Collider设置<code>Physics Material</code>，导致角色和平台之间的摩擦力为0。</p><blockquote><p>添加Physics Material的步骤</p></blockquote><ol><li>在<code>Assets</code>目录下新建一个名为<code>Physics Material</code>的文件夹</li><li>在<code>Physics Material</code>的文件夹创建两个<code>Physics Material 2D</code>，并将它们分别命名为<code>Platform</code>和<code>Player</code></li><li>将<code>Platform</code>和<code>Player</code>这两个<code>Physics Material 2D</code>的<code>Friction</code>属性都设置为<code>1</code></li><li>将<code>Platform</code>和<code>Player</code>这两个<code>Physics Material 2D</code>分别设置到所有<code>角色可移动的平台</code>和<code>角色的Rigidbody2D</code>上</li></ol><p>&amp;emsp;&amp;emsp;因为平台数量较多，我们可以批量操作。按住<code>shift</code>键选择多个GameObject，右侧<code>Inspector</code>就会显示它们同时都具备的组件，我们可以同时对它们同时都具备的组件进行编辑。</p><p><img src="https://github.com/AsanCai/BlogImage/raw/master/PotatoGloryTutorial/Essay7/Image2.png" alt="批量操作"></p><p>&amp;emsp;&amp;emsp;此外，角色在跳跃时，我们发现角色跳跃的高度很高，且下落的速度很慢，游戏体验较差。为了提高游戏体验，我们需要增大游戏角色的重力加速度。将<code>Player</code>下<code>Rigidbody2D</code>组件的<code>Gravity Scale</code>设置为<code>3.1</code>，表示将角色的重力加大至原有的<code>3.1</code>倍。</p><p><img src="https://github.com/AsanCai/BlogImage/raw/master/PotatoGloryTutorial/Essay7/Image3.png" alt="设置Gravity Scale"></p><p>&amp;emsp;&amp;emsp;从上面的图片可以看到，我将<code>Player</code>这一<code>Physics Material 2D</code>设置到<code>角色的Rigidbody2D</code>上，这表示角色的所有没设置<code>Physics Material 2D</code>的Collider都会使用<code>Player</code>这一<code>Physics Material 2D</code>。</p><p>&amp;emsp;&amp;emsp;设置完成之后，运行游戏，可以看到之前的滑动和下落缓慢的问题都消失了，但是出现了一个新的问题，那就是当我们按住方向键不动的时候，角色会贴在平台边缘。之所以会出现这个问题，是因为角色和平台之间有摩擦力，为了避免这一情况，我们需要创建一个名为<code>Wall</code>的<code>Physics Material 2D</code>，将其<code>Friction</code>属性都设置为<code>0</code>，然后在各个平台的末端处创建一个使用<code>Wall</code>这一<code>Physics Material 2D</code>的Collider。</p><blockquote><p>Foreground添加Collider的情况如下：</p></blockquote><ul><li>env_TowerFull和env_TowerFull (1)：<ul><li>不添加新的Collider</li><li>设置原有Collider的<code>Physics Material 2D</code>为<code>Wall</code></li></ul></li><li>env_PlatformBridge和env_PlatformBridge (1)：<ul><li>新添加一个BoxCollider2D</li><li><code>Material</code>：Wall</li><li><code>Offset</code>：(0.8, 0.8)</li><li><code>Size</code>: (15.5, 0.6)</li></ul></li><li>env_PlatformTop和env_PlatformTop (1):<ul><li>新添加一个BoxCollider2D</li><li><code>Material</code>：Wall</li><li><code>Offset</code>：(4.7, 0.12)</li><li><code>Size</code>: (0.5, 2.6)</li></ul></li><li>env_PlatformUfo:<ul><li>新添加两个CircleCollider2D</li><li><code>Material</code>：都为Wall</li><li><code>Offset</code>：(-15.3, -0.65)和(15.3, -0.65)</li><li><code>Radius</code>: 都为0.5</li></ul></li></ul><p>&amp;emsp;&amp;emsp;添加完毕之后，再次运行游戏，可以看到不再出现角色贴在平台边缘的问题。</p><hr><h2 id="添加音效"><a href="#添加音效" class="headerlink" title="添加音效"></a>添加音效</h2><p>&amp;emsp;&amp;emsp;接着，我们需要为角色添加音效。首先，在<code>PlayerController.cs</code>内加入以下代码，其中<code>...</code>表示原有的代码：</p><figure class="highlight csharp"><figcaption><span>PlayerController.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs csharp">...<br>[<span class="hljs-meta">RequireComponent(typeof(AudioSource))</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PlayerController</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br>    ...<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;跳跃音效&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> AudioClip[] JumpClips;<br><br>    ...<br>    <span class="hljs-keyword">private</span> AudioSource m_AudioSource;<br><br>    ...<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Awake</span>()</span> &#123;<br>        ...<br>        m_AudioSource = GetComponent&lt;AudioSource&gt;();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Jump</span>()</span> &#123;<br>        ...<br><br>        <span class="hljs-comment">//随机在角色当前所处的位置播放一个跳跃的音频</span><br>        <span class="hljs-keyword">if</span>(JumpClips.Length &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">int</span> i = Random.Range(<span class="hljs-number">0</span>, JumpClips.Length);<br>            AudioSource.PlayClipAtPoint(JumpClips[i], transform.position);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;添加完毕之后，我们给Player添加<code>AudioSource</code>组件，并将<code>Assets\Audio\Player\Jumps</code>添加到<code>JumpClips</code>属性上。接着运行游戏，可以听到角色在跳跃的时候已经有了音效。最后，将我们在<code>Player</code>上做的修改<code>Apply</code>到Prefab上，并保存场景产生的修改即可。</p><p><img src="https://github.com/AsanCai/BlogImage/raw/master/PotatoGloryTutorial/Essay7/Image4.png" alt="设置音效"></p><hr><h2 id="PlayerController-cs完整代码"><a href="#PlayerController-cs完整代码" class="headerlink" title="PlayerController.cs完整代码"></a>PlayerController.cs完整代码</h2><p>&amp;emsp;&amp;emsp;此时，<code>PlayerController.cs</code>完整代码如下：</p><figure class="highlight csharp"><figcaption><span>PlayerController.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br>[<span class="hljs-meta">RequireComponent(typeof(Rigidbody2D))</span>]<br>[<span class="hljs-meta">RequireComponent(typeof(AudioSource))</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PlayerController</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;角色初始朝向是否朝向右边&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> FacingRight = <span class="hljs-literal">true</span>;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;移动时角色加速的力大小&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> MoveForce = <span class="hljs-number">365f</span>;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;角色移动的最大速度&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> MaxSpeed = <span class="hljs-number">5f</span>;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;跳跃时向上加速的力大小&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> JumpForce = <span class="hljs-number">1000f</span>;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;检测角色是否落地&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> Transform GroundCheck;<br><br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;跳跃音效&quot;</span>)</span>]<br>    <span class="hljs-keyword">public</span> AudioClip[] JumpClips;<br><br>    <span class="hljs-comment">// 记录角色当前是否处于准备跳跃状态</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">bool</span> m_IsReadyToJump;<br>    <span class="hljs-comment">// 记录角色当前是否正处于跳跃状态</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">bool</span> m_IsJumping;<br>    <span class="hljs-comment">// 记录角色当前是否处于着地状态</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">bool</span> m_GroundedStatus;<br><br>    <span class="hljs-comment">// 组件引用变量</span><br>    <span class="hljs-keyword">private</span> Rigidbody2D m_Rigidbody2D;<br>    <span class="hljs-keyword">private</span> AudioSource m_AudioSource;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Awake</span>()</span> &#123;<br>        <span class="hljs-comment">// 获取组件引用</span><br>        m_Rigidbody2D = GetComponent&lt;Rigidbody2D&gt;();<br>        m_AudioSource = GetComponent&lt;AudioSource&gt;();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span> &#123;<br>        <span class="hljs-comment">// 监测变量是否正确赋值</span><br>        <span class="hljs-keyword">if</span>(GroundCheck == <span class="hljs-literal">null</span>) &#123;<br>            Debug.LogError(<span class="hljs-string">&quot;请先设置GroundCheck&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 初始化变量</span><br>        m_IsReadyToJump = <span class="hljs-literal">false</span>;<br>        m_IsJumping = <span class="hljs-literal">false</span>;<br>        m_GroundedStatus = <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>()</span> &#123;<br>        <span class="hljs-comment">// 通过检测角色和groundCheck之间是否存在Ground层的物体来判断当前是否落地</span><br>        m_GroundedStatus = Physics2D.Linecast(<br>            transform.position,<br>            GroundCheck.position,<br>            LayerMask.GetMask(<span class="hljs-string">&quot;Obstacle&quot;</span>)<br>        );<br>        <br>        <span class="hljs-comment">// 着地时，如果当前不处于跳跃状态且按下了跳跃键，进入准备跳跃状态</span><br>        <span class="hljs-keyword">if</span>(m_GroundedStatus &amp;&amp; !m_IsJumping &amp;&amp; Input.GetButtonDown(<span class="hljs-string">&quot;Jump&quot;</span>)) &#123;<br>            m_IsReadyToJump = <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 刚刚落地，退出跳跃状态</span><br>        <span class="hljs-keyword">if</span>(m_GroundedStatus &amp;&amp; m_IsJumping) &#123;<br>            m_IsJumping = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">FixedUpdate</span>()</span> &#123;<br>        <span class="hljs-comment">//获取水平输入</span><br>        <span class="hljs-built_in">float</span> h = Input.GetAxis(<span class="hljs-string">&quot;Horizontal&quot;</span>);<br><br>        <span class="hljs-comment">// 若h * m_Rigidbody2D.velocity.x为正数且小于MaxSpeed，表示需要继续加速</span><br>        <span class="hljs-comment">// 若h * m_Rigidbody2D.velocity.x为负数，则表示需要反向加速</span><br>        <span class="hljs-keyword">if</span>(h * m_Rigidbody2D.velocity.x &lt; MaxSpeed) &#123;<br>            m_Rigidbody2D.AddForce(Vector2.right * h * MoveForce);<br>        &#125;<br><br>        <span class="hljs-comment">//设置物体速度的阈值</span><br>        <span class="hljs-keyword">if</span>(Mathf.Abs(m_Rigidbody2D.velocity.x) &gt; MaxSpeed) &#123;<br>            m_Rigidbody2D.velocity = <span class="hljs-keyword">new</span> Vector2(<br>                Mathf.Sign(m_Rigidbody2D.velocity.x) * MaxSpeed,<br>                m_Rigidbody2D.velocity.y<br>            );<br>        &#125;<br><br>        <span class="hljs-comment">//判断当前是否需要转向</span><br>        <span class="hljs-keyword">if</span>(h &gt; <span class="hljs-number">0</span> &amp;&amp; !FacingRight) &#123;<br>            Flip();<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(h &lt; <span class="hljs-number">0</span> &amp;&amp; FacingRight) &#123;<br>            Flip();<br>        &#125;<br><br>        <span class="hljs-comment">// 跳跃</span><br>        <span class="hljs-keyword">if</span>(m_IsReadyToJump) &#123;<br>            Jump();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Jump</span>()</span> &#123;<br>        <span class="hljs-comment">// 进入跳跃状态</span><br>        m_IsJumping = <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-comment">// 设置一个竖直向上的力</span><br>        m_Rigidbody2D.AddForce(<span class="hljs-keyword">new</span> Vector2(<span class="hljs-number">0f</span>, JumpForce));<br><br>        <span class="hljs-comment">// 退出准备跳跃状态，避免重复跳跃</span><br>        m_IsReadyToJump = <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-comment">//随机在角色当前所处的位置播放一个跳跃的音频</span><br>        <span class="hljs-keyword">if</span>(JumpClips.Length &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">int</span> i = Random.Range(<span class="hljs-number">0</span>, JumpClips.Length);<br>            AudioSource.PlayClipAtPoint(JumpClips[i], transform.position);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Flip</span>()</span> &#123;<br>        <span class="hljs-comment">// 修改当前朝向</span><br>        FacingRight = !FacingRight;<br><br>        <span class="hljs-comment">// 修改scale的x分量实现转向</span><br>        <span class="hljs-keyword">this</span>.transform.localScale = Vector3.Scale(<br>            <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>),<br>            <span class="hljs-keyword">this</span>.transform.localScale<br>        );<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="后言"><a href="#后言" class="headerlink" title="后言"></a>后言</h2><p>&amp;emsp;&amp;emsp;可以看到，目前角色在运动的时候还没有动画。因为给角色加上动画设计到动画状态机的制作，较为复杂，在下一篇文章将会介绍如何给角色添加动画。最后，本篇文章所做的修改，可以在<a href="https://github.com/AsanCai/PotatoGloryTutorial">PotatoGloryTutorial</a>这个仓库的<code>essay5</code>分支下看到，读者可以clone这个仓库到本地进行查看。</p><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://docs.unity3d.com/Manual/class-Rigidbody2D.html">Gravity Scale</a></li><li><a href="https://docs.unity3d.com/Manual/ConventionalGameInput.html">Conventional Game Input</a></li><li><a href="https://docs.unity3d.com/Manual/class-PhysicsMaterial2D.html">Physics Material 2D</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
      <category>《土豆荣耀》</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《土豆荣耀》重构笔记（六）实现怪物的AI</title>
    <link href="/posts/635461e0/"/>
    <url>/posts/635461e0/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&amp;emsp;&amp;emsp;在游戏里面，为了提高游戏的难度，增加游戏的趣味性，往往会根据游戏的需要实现怪物AI。一般来说，一个最基本的怪物AI需要包括<code>自动巡逻</code>、<code>看到玩家攻击玩家</code>、<code>玩家离开恢复自动巡逻</code>等功能。对于一些状态比较复杂的怪物AI，还需要使用<code>行为树</code>来辅助实现。</p><p>&amp;emsp;&amp;emsp;在本篇文章中，我们要实现的怪物AI逻辑十分简单，<code>怪物只需要在场景中以恒定速度移动，当遇到障碍物时转弯朝反方向继续行走即可</code>。因此，我们在实现怪物AI的逻辑时没有用到<code>行为树</code>或者<code>状态机</code>。</p><p>&amp;emsp;&amp;emsp;此外，因为本篇文章是<code>《土豆荣耀》重构笔记</code>系列文章中第一篇涉及脚本编写的文章，所以在开始阅读本篇文章之间，可以先看一下<a href="https://asancai.github.io/environment/VSCodeWithUnity/">如何使用VS Code编写Unity脚本</a>。此外，本篇文章默认读者已经知道Unity脚本是如何工作的，熟悉获取组件的引用以及使用Unity提供的api等基本操作，对C#的基本语法也有一定的了解。</p><hr><h2 id="为场景添加Collider"><a href="#为场景添加Collider" class="headerlink" title="为场景添加Collider"></a>为场景添加Collider</h2><p>&amp;emsp;&amp;emsp;为了能让怪物在场景上行走，我们需要为怪物和场景添加Collider。在<code>Hierarchy</code>窗口中选中需要添加碰撞体的GameObject，然后点击右侧<code>Inspector</code>窗口中的<code>Add Componnet</code>按钮，选择<code>Physics 2D</code>之后，我们就可以选择Collider类型并添加。</p><p><img src="https://github.com/AsanCai/BlogImage/raw/master/PotatoGloryTutorial/Essay6/Image1.png" alt="添加Collider"></p><p>&amp;emsp;&amp;emsp;了解了如何添加Collider之后，我们先为场景添加Collider。场景中能和角色、怪物产生交互的物体都存放在<code>Foreground</code>下，它们添加的Collider属性如下所示：</p><blockquote><p>Foreground下的物体添加的Collider：</p></blockquote><ul><li>env_TowerFull:<ul><li><code>Collider</code>: Box Collider 2D</li><li><code>Offset</code>: (0, 0)</li><li><code>Size</code>:   (7.3, 27)</li></ul></li><li>env_TowerFull (1):<ul><li><code>Collider</code>: Box Collider 2D</li><li><code>Offset</code>: (0, 0)</li><li><code>Size</code>:   (7.3, 27)</li></ul></li><li>env_PlatformBridge:<ul><li><code>Collider</code>: Box Collider 2D</li><li><code>Offset</code>: (0.8, 0.8)</li><li><code>Size</code>:   (15.5, 1.6)</li></ul></li><li>env_PlatformBridge (1):<ul><li><code>Collider</code>: Box Collider 2D</li><li><code>Offset</code>: (0.8, 0.8)</li><li><code>Size</code>:   (15.5, 1.6)</li></ul></li><li>env_PlatformTop:<ul><li><code>Collider</code>: Box Collider 2D</li><li><code>Offset</code>: (0, 0.12)</li><li><code>Size</code>:   (9.6, 2.6)</li></ul></li><li>env_PlatformTop (1):<ul><li><code>Collider</code>: Box Collider 2D</li><li><code>Offset</code>: (0, 0.12)</li><li><code>Size</code>:   (9.6, 2.6)</li></ul></li><li>env_PlatformUfo:<ul><li><code>Collider</code>: Polygon Collider 2D</li></ul></li></ul><hr><h2 id="为怪物添加Collider和Rigidbody"><a href="#为怪物添加Collider和Rigidbody" class="headerlink" title="为怪物添加Collider和Rigidbody"></a>为怪物添加Collider和Rigidbody</h2><p>&amp;emsp;&amp;emsp;接着，我们在<code>Hierarchy</code>选中<code>AlienSlug</code>和<code>AlienShip</code>为它们添加Collider。</p><blockquote><p><code>AlienSlug</code>和<code>AlienShip</code>添加的Collider信息如下：</p></blockquote><ul><li>AlienSlug:<ul><li><code>Collider</code>: Capsule Collider 2D</li><li><code>Offset</code>: (0, 0)</li><li><code>Size</code>: (1.14, 1.74)</li></ul></li><li>AlienShip:<ul><li><code>Collider</code>: Circle Collider 2D</li><li><code>Offset</code>: (0.1, 0)</li><li><code>Radius</code>: 0.9</li></ul></li></ul><p>&amp;emsp;&amp;emsp;点击运行游戏，我们发现怪物悬浮在空中，这是因为我们<code>没有给它们添加刚体组件</code>，<code>它们没有物理属性</code>。在2D项目中，如果我们想让一个物体具有重力、速度等物理属性，我们需要给这个物体添加<code>Rigidbody2D</code>组件。<code>Rigidbody2D</code>组件也位于<code>Add Component\Physics 2D</code>目录下。接下来，我们为<code>AlienSlug</code>和<code>AlienShip</code>添加<code>Rigidbody2D</code>组件。</p><p>&amp;emsp;&amp;emsp;添加完成后，再次运行游戏，可以看到怪物受重力影响掉落下来，且发生了翻滚。我们想让怪物一直保持直立，因此我们需要在<code>Rigidbody2D</code>的<code>Constraints</code>属性里设置勾选<code>Freeze Rotation Z</code>，不让物体在进行物理模拟时，绕Z轴进行旋转。</p><p><img src="https://github.com/AsanCai/BlogImage/raw/master/PotatoGloryTutorial/Essay6/Image2.png" alt="限制旋转"></p><p>&amp;emsp;&amp;emsp;设置完成之后，我们再次运行游戏，可以看到怪物会受到重力影响，且一直保持直立，不会翻滚。最后，我们需要将我们所做的修改应用到它们的Prefab上。在<code>Hierarchy</code>分别选中<code>AlienSlug</code>和<code>AlienShip</code>，然后在<code>Inspector</code>窗口中点击<code>Apply</code>按钮即可。</p><p><img src="https://github.com/AsanCai/BlogImage/raw/master/PotatoGloryTutorial/Essay6/Image3.png" alt="应用修改到Prefab上"></p><hr><h2 id="让怪物动起来"><a href="#让怪物动起来" class="headerlink" title="让怪物动起来"></a>让怪物动起来</h2><p>&amp;emsp;&amp;emsp;接下来，我们开始编写脚本来实现让怪物在场景中移动的功能。我们在<code>Assets</code>下创建一个名为<code>Scripts</code>的文件夹，然后在<code>Scripts</code>文件夹下创建一个名为<code>Enemy</code>的文件夹用于保存和怪物相关的脚本。创建完毕后，我们在<code>Enemy</code>文件夹下创建脚本<code>Wander.cs</code>，然后双击打开。</p><p>&amp;emsp;&amp;emsp;既然想要让怪物在场景中移动，那么我们就需要先知道怪物移动的速度以及方向。首先在<code>Wander.cs</code>加入以下代码：</p><figure class="highlight csharp"><figcaption><span>Wander.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs csharp">[<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;是否朝向右边&quot;</span>)</span>]<br>[<span class="hljs-meta">SerializeField</span>]<br><span class="hljs-keyword">private</span> <span class="hljs-built_in">bool</span> FacingRight = <span class="hljs-literal">true</span>;<br><br>[<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;怪物移动的速度&quot;</span>)</span>]<br>[<span class="hljs-meta">SerializeField</span>]<br><span class="hljs-keyword">private</span> <span class="hljs-built_in">float</span> MoveSpeed = <span class="hljs-number">2f</span>;<br></code></pre></td></tr></table></figure><blockquote><p>代码说明：</p></blockquote><ul><li><code>Tooltip</code>：<ul><li>Unity提供的一个Attribute，参数为string；</li><li>我们可以使用<code>Tooltip</code>这一Attribute来设置提示的内容，当我们将鼠标悬停在<code>Inspector</code>窗口显示的参数上时，我们可以看到提示的内容</li></ul></li><li><code>SerializeField</code>：<ul><li>Unity提供的一个Attribute，没有参数；</li><li>Unity只会在<code>Inspector</code>窗口中显示可见性为<code>public</code>的字段，通过使用<code>SerializeField</code>这一Attribute，可以强制在<code>Inspector</code>窗口中显示可见性为<code>private</code>和<code>protected</code>的字段</li></ul></li></ul><p>&amp;emsp;&amp;emsp;接下来，我们要让怪物动起来，需要给怪物的<code>Rigidbody2D</code>组件设置速度，在<code>Wander.cs</code>加入以下代码：</p><figure class="highlight csharp"><figcaption><span>Wander.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">//用于设置怪物对象的物理属性</span><br><span class="hljs-keyword">private</span> Rigidbody2D m_Rigidbody;<br><span class="hljs-comment">// 用于保存当前的水平移动速度</span><br><span class="hljs-keyword">private</span> <span class="hljs-built_in">float</span> m_CurrentMoveSpeed;<br><br><span class="hljs-comment">// 获取组件引用</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Awake</span>()</span> &#123;<br>    m_Rigidbody = GetComponent&lt;Rigidbody2D&gt;();<br>&#125;<br><br><span class="hljs-comment">// 设置字段的初始值</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span> &#123;<br>    <span class="hljs-keyword">if</span>(FacingRight) &#123;<br>        m_CurrentMoveSpeed = MoveSpeed;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        m_CurrentMoveSpeed = -MoveSpeed;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 执行和物理相关的代码</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">FixedUpdate</span>()</span> &#123;<br>    m_Rigidbody.velocity = <span class="hljs-keyword">new</span> Vector2(m_CurrentMoveSpeed, m_Rigidbody.velocity.y);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>代码说明：<br>&amp;emsp;&amp;emsp;上面代码涉及到的<code>Awake</code>、<code>Start</code>和<code>FixedUpdate</code>都是Unity提供的生命周期函数，感兴趣的读者可以查看<a href="https://docs.unity3d.com/Manual/ExecutionOrder.html">Unity各生命周期函数的执行顺序</a>来了解它们的执行顺序和作用。</p></blockquote><p>&amp;emsp;&amp;emsp;接着，我们将<code>Wander.cs</code>添加到<code>AlienSlug</code>和<code>AlienShip</code>上并运行游戏，可以看到场景中的两个怪物已经动了起来，但是出现了重叠的现象。我们不希望场景中的怪物会产生碰撞等物理交互，所以，我们还需要做一些额外的工作。</p><hr><h2 id="一些额外的工作"><a href="#一些额外的工作" class="headerlink" title="一些额外的工作"></a>一些额外的工作</h2><p>&amp;emsp;&amp;emsp;Unity为了方便我们决定Sprite的渲染顺序，提供了<code>Sorting Layer</code>。类似地，为了让我们更方便地管理场景中物体的渲染和物理模拟，Unity也提供了<a href="https://docs.unity3d.com/Manual/Layers.html">Layer</a>。首先，我们新建一个名为<code>Enemy</code>的Layer，然后将<code>AlienSlug</code>和<code>AlienShip</code>的Layer都设置为<code>Enemy</code>。切换Layer时，我们选择<code>Yes, Change the children</code>将子物体的Layer都设置为<code>Enemy</code>。</p><p><img src="https://github.com/AsanCai/BlogImage/raw/master/PotatoGloryTutorial/Essay6/Image4.png" alt="创建Layer"></p><p>&amp;emsp;&amp;emsp;接着，我们在Unity的顶部菜单栏选择<code>Edit-&gt;Project Settings-&gt;Physics 2D</code>打开2D项目的物理设置窗口，然后在<code>Layer Collision Matrix</code>中取消<code>Enemy-Enemy</code>那一项的勾选，告诉Unity，不对都处于<code>Enemy</code>这一Layer的两个物体进行任何物理碰撞模拟。再次运行游戏，可以看到两个怪物已经不会重叠了。</p><p><img src="https://github.com/AsanCai/BlogImage/raw/master/PotatoGloryTutorial/Essay6/Image5.png" alt="Layer Collision Matrix"></p><hr><h2 id="实现怪物遇到障碍物转向的功能"><a href="#实现怪物遇到障碍物转向的功能" class="headerlink" title="实现怪物遇到障碍物转向的功能"></a>实现怪物遇到障碍物转向的功能</h2><p>&amp;emsp;&amp;emsp;目前我们的怪物还只有移动的功能，当它们遇到障碍物的时候，会被卡住，我们需要让它们在遇到障碍物时自动转向。我们可以使用<code>Physics2D.OverlapPointAll</code>来获取场景里某个点上所有的Collider，但我们如何辨别这些Collider是障碍物，还是其他物体呢？答案是，通过<code>Layer</code>和<code>LayerMask</code>。所谓的<a href="https://docs.unity3d.com/Manual/Layers.html">LayerMask</a>，其实就是一个用<code>二进制来表示的int类型变量</code>，<code>哪个位上的值为1</code>，就代表对以该位为下标的<code>Layer</code>执行相应的操作。</p><blockquote><p>例如，我们之前创建的<code>Enemy</code>的Layer下标为8，那么当<code>LayerMask</code>的值为<code>128（二进制的10000000）</code>时，代表我们会对所有Layer为<code>Enemy</code>的物体进行操作</p></blockquote><p>&amp;emsp;&amp;emsp;新建一个名为<code>Obstacle</code>的Layer，然后将所有障碍物的Layer都设置为<code>Obstacle</code>。设置完毕之后，我们在<code>Assets\Scripts\Enemy</code>下新建一个名为<code>Enemy</code>的C#脚本，然后在<code>Enemy.cs</code>中加入以下代码：</p><figure class="highlight csharp"><figcaption><span>Enemy.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br>[<span class="hljs-meta">RequireComponent(typeof(Wander))</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Enemy</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;障碍物检测点&quot;</span>)</span>]<br>    [<span class="hljs-meta">SerializeField</span>]<br>    <span class="hljs-keyword">private</span> Transform FrontCheck;<br><br>    <span class="hljs-keyword">private</span> Wander m_Wander;<br>    <span class="hljs-keyword">private</span> LayerMask m_LayerMask;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Awake</span>()</span> &#123;<br>        m_Wander = GetComponent&lt;Wander&gt;();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span> &#123;<br>        m_LayerMask = LayerMask.GetMask(<span class="hljs-string">&quot;Obstacle&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Update</span> ()</span> &#123;<br>        Collider2D[] frontHits = Physics2D.OverlapPointAll(FrontCheck.position, m_LayerMask);<br><br>        <span class="hljs-keyword">if</span>(frontHits.Length &gt; <span class="hljs-number">0</span>) &#123;<br>            m_Wander.Flip();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>代码说明：</p></blockquote><ul><li><code>RequireComponent</code>：<ul><li>Unity提供的一个Attribute，参数为<code>Type</code></li><li><code>RequireComponent[(typeof(Wander))]</code>表示在添加前，必须给该物体添加定义了<code>Wander</code>这个类的脚本，不然会报错</li></ul></li><li><code>LayerMask.GetMask(&quot;Obstacle&quot;)</code>表示直接获得<code>Obstacle</code>这个Layer对应的LayerMask</li></ul><p>&amp;emsp;&amp;emsp;接着，我们在<code>Wander.cs</code>脚本里添加<code>Flip</code>函数，<code>Wander.cs</code>完整代码如下：</p><figure class="highlight csharp"><figcaption><span>Wander.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> UnityEngine;<br><br>[<span class="hljs-meta">RequireComponent(typeof(Rigidbody2D))</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Wander</span> : <span class="hljs-title">MonoBehaviour</span> &#123;<br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;是否朝向右边&quot;</span>)</span>]<br>    [<span class="hljs-meta">SerializeField</span>]<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">bool</span> FacingRight = <span class="hljs-literal">true</span>;<br><br>    [<span class="hljs-meta">Tooltip(<span class="hljs-string">&quot;怪物水平移动的速度&quot;</span>)</span>]<br>    [<span class="hljs-meta">SerializeField</span>]<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">float</span> MoveSpeed = <span class="hljs-number">2f</span>;<br><br><br>    <span class="hljs-comment">//用于设置怪物对象的物理属性</span><br>    <span class="hljs-keyword">private</span> Rigidbody2D m_Rigidbody;<br>    <span class="hljs-comment">// 用于保存当前的水平移动速度</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">float</span> m_CurrentMoveSpeed;<br><br>    <span class="hljs-comment">// 获取组件引用</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Awake</span>()</span> &#123;<br>        m_Rigidbody = GetComponent&lt;Rigidbody2D&gt;();<br>    &#125;<br><br>    <span class="hljs-comment">// 设置字段的初始值</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span> &#123;<br>        <span class="hljs-keyword">if</span>(FacingRight) &#123;<br>            m_CurrentMoveSpeed = MoveSpeed;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            m_CurrentMoveSpeed = -MoveSpeed;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 执行和物理相关的代码</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">FixedUpdate</span>()</span> &#123;<br>        m_Rigidbody.velocity = <span class="hljs-keyword">new</span> Vector2(m_CurrentMoveSpeed, m_Rigidbody.velocity.y);<br>    &#125;<br><br>    <span class="hljs-comment">// 转向函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Flip</span>()</span> &#123;<br>        m_CurrentMoveSpeed *= <span class="hljs-number">-1</span>;<br>        <br>        <span class="hljs-keyword">this</span>.transform.localScale = Vector3.Scale(<span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>), <span class="hljs-keyword">this</span>.transform.localScale);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;最后，我们将<code>Enemy.cs</code>添加到<code>AlienSlug</code>和<code>AlienShip</code>中，并在<code>AlienSlug</code>和<code>AlienShip</code>下新建一个名为<code>FrontCheck</code>的<code>Empty GameObject</code>。设置<code>FrontCheck</code>的<code>Position</code>为<code>(1, 0, 0)</code>，接着拖拽<code>FrontCheck</code>，将其复制给<code>Enemy.cs</code>脚本上的<code>FrontCheck</code>属性。运行游戏，可以看到怪物已经能正常转向了。</p><hr><h2 id="修改Sorting-Layer"><a href="#修改Sorting-Layer" class="headerlink" title="修改Sorting Layer"></a>修改Sorting Layer</h2><p>&amp;emsp;&amp;emsp;运行游戏的时候，我们发现<code>AlienSlug</code>的尾巴被UFO遮住了，我们需要调整一下<code>Sorting Layer</code>的渲染顺序。在<code>Hierarchy</code>窗口下点击<code>AlienShip</code>的子物体<code>char_enemy_alienShip</code>，然后点击<code>Add Sorting Layer</code>将<code>Sorting Layer</code>的顺序调整为下图所示的顺序：</p><p><img src="https://github.com/AsanCai/BlogImage/raw/master/PotatoGloryTutorial/Essay6/Image6.png" alt="修改Sorting Layer"></p><p>&amp;emsp;&amp;emsp;至此，我们所有的修改就都完成了，点击<code>AlienSlug</code>和<code>AlienShip</code>在<code>Inspector</code>窗口中的<code>Apply</code>按钮将我们所做的修改应用到Prefab中，再保存场景产生的修改即可。</p><hr><h2 id="后言"><a href="#后言" class="headerlink" title="后言"></a>后言</h2><p>&amp;emsp;&amp;emsp;<code>AlienSlug</code>和<code>AlienShip</code>下<code>Wander</code>脚本的<code>MoveSpeed</code>的值我默认给的是2，大家可以根据自己的喜好进行调整。最后，本篇文章所做的修改，可以在<a href="https://github.com/AsanCai/PotatoGloryTutorial">PotatoGloryTutorial</a>这个仓库的<code>essay4</code>分支下看到，读者可以clone这个仓库到本地进行查看。</p><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://asancai.github.io/environment/VSCodeWithUnity/">使用VS Code编写Unity脚本</a></li><li><a href="https://docs.unity3d.com/Manual/ExecutionOrder.html">Execution Order of Event Functions</a></li><li><a href="https://docs.unity3d.com/Manual/EditingPrefabViaInstance.html">Editing a Prefab via its instances</a></li><li><a href="https://docs.unity3d.com/Manual/Layers.html">Layer和LayerMask</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
      <category>《土豆荣耀》</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《土豆荣耀》重构笔记（五）创建角色以及怪物的动画</title>
    <link href="/posts/d483ec30/"/>
    <url>/posts/d483ec30/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&amp;emsp;&amp;emsp;在游戏中，角色和AI的移动都需要配上相应的动画，以免让玩家产生游戏中的角色或者AI在平移的不真实感。一般来说，角色和AI的动画都会比前面介绍的游戏背景动画复杂很多，因为角色和AI的动画既需要精心编辑动画让身体各个部位的运动看起来很真实，又需要协调身体各个部位的运动。本篇文章的主要内容，就是讲述如何使用Unity制作角色和怪物的动画。</p><hr><h2 id="创建角色和怪物"><a href="#创建角色和怪物" class="headerlink" title="创建角色和怪物"></a>创建角色和怪物</h2><p>&amp;emsp;&amp;emsp;在开始制作角色和怪物的动画之前，我们需要先创建角色和怪物。在<code>Project</code>窗口打开<code>Sprites\Character</code>目录，可以看到<code>char_enemy_alienSlug</code>和<code>char_hero_beanMan</code>并不是一张完整的图片，而是多张图片拼在一起的<code>图集</code>。点击<code>char_hero_beanMan</code>，在<code>Inspector</code>窗口我们可以看到它的<code>Sprite Mode</code>为<code>Multiple</code>，这表示这张图片是多张图片拼接而成，Unity会自动帮我们切成多张单独的图片。当然，我们也可以点击<code>Sprite Editor</code>来决定自己要怎么切割图片，<code>Sprite Editor</code>的具体用法可见<a href="https://docs.unity3d.com/Manual/SpriteEditor.html">Unity的Sprite Editor</a>。切割完成之后，点击<code>char_hero_beanMan</code>右下角的<code>三角形图标</code>，我们可以看到有许多张小图片以列表的形式展示出来，这些就是切割产生的图片，<code>我们可以像使用普通Sprite一样使用它们</code>。</p><p><img src="https://github.com/AsanCai/BlogImage/raw/master/PotatoGloryTutorial/Essay5/Image1.png" alt="Multiple Sprite"></p><p>&amp;emsp;&amp;emsp;接着，我们在<code>Hierarchy</code>列表中创建一个<code>Empty GameObject</code>，将其命名为<code>Player</code>后，在它下面创建一个名为<code>Character</code>的<code>Empty GameObject</code>并将<code>char_hero_beanMan</code>切割得到的图片都拖拽到<code>Character</code>下。</p><p><img src="https://github.com/AsanCai/BlogImage/raw/master/PotatoGloryTutorial/Essay5/Image2.png" alt="Player的结构"></p><p>&amp;emsp;&amp;emsp;为了让<code>Character</code>下各个Sprite都能正常显示，我们还需要创建一个<code>名为Character的Sorting Layer</code>，该Sorting Layer与其他Sorting Layer的关系如下：</p><p><img src="https://github.com/AsanCai/BlogImage/raw/master/PotatoGloryTutorial/Essay5/Image3.png" alt="Sorting Layer"></p><blockquote><p>Player各个子物体的被修改的属性如下：</p></blockquote><ul><li>Character: <code>Scale</code>: (0.48, 0.48, 0.48)</li><li>bazooka: <ul><li><code>Position</code>: (0.234, 0.394, 0)</li><li><code>Sorting Layer</code>: Character, <code>Order In Layer</code>: 0</li></ul></li><li>body: <code>Sorting Layer</code>: Character, <code>Order In Layer</code>: 1</li><li>hat: <ul><li><code>Position</code>: (-0.4, 1.43, 0), <code>Rotation</code>: (0, 0, -5.724)</li><li><code>Sorting Layer</code>: Character, <code>Order In Layer</code>: 2</li></ul></li><li>leftEye<ul><li><code>Position</code>: (0.39, 0.892, 0)</li><li><code>Sorting Layer</code>: Character, <code>Order In Layer</code>: 3</li></ul></li><li>leftFoot<ul><li><code>Position</code>: (0.81, -1.63, 0)</li><li><code>Sorting Layer</code>: Character, <code>Order In Layer</code>: 3</li></ul></li><li>leftHand<ul><li><code>Position</code>: (0.937, -0.058, 0)</li><li><code>Sorting Layer</code>: Character, <code>Order In Layer</code>: 3</li></ul></li><li>rightEye<ul><li><code>Position</code>: (-0.212, 0.801, 0)</li><li><code>Sorting Layer</code>: Character, <code>Order In Layer</code>: 3</li></ul></li><li>rightFoot<ul><li><code>Position</code>: (-0.49, -1.87, 0)</li><li><code>Sorting Layer</code>: Character, <code>Order In Layer</code>: 3</li></ul></li><li>rightHand<ul><li><code>Position</code>: (-0.975, -0.386, 0)</li><li><code>Sorting Layer</code>: Character, <code>Order In Layer</code>: 3</li></ul></li><li>tache<ul><li><code>Position</code>: (-0.019, 0.173, 0)</li><li><code>Sorting Layer</code>: Character, <code>Order In Layer</code>: 3</li></ul></li></ul><p>&amp;emsp;&amp;emsp;接着，我们创建一个名为<code>AlienSlug</code>的<code>Empty GameObject</code>，然后在<code>AlienSlug</code>下创建一个名为<code>Character</code>的<code>Empty GameObject</code>，并将<code>char_enemy_alienSlug</code>切割得到的图片拖拽到<code>Character</code>下面。</p><p><img src="https://github.com/AsanCai/BlogImage/raw/master/PotatoGloryTutorial/Essay5/Image4.png" alt="AlienSlug的结构"></p><blockquote><p>AlienSlug各个子物体的被修改的属性如下：</p></blockquote><ul><li>Character: <code>Scale</code>: (0.4, 0.4, 0.4)</li><li>enemy1-eye: <ul><li><code>Position</code>: (0.06, 0.59, 0)</li><li><code>Sorting Layer</code>: Character, <code>Order In Layer</code>: 0</li></ul></li><li>enemy1-eyelid: <ul><li><code>Position</code>: (-0.07, 1.07, 0)</li><li><code>Sorting Layer</code>: Character, <code>Order In Layer</code>: 1</li></ul></li><li>enemy1-body: <ul><li><code>Position</code>: (0, 0, 0)</li><li><code>Sorting Layer</code>: Character, <code>Order In Layer</code>: 2</li></ul></li><li>enemy1-tail: <ul><li><code>Position</code>: (-1.52, -1.49, 0)</li><li><code>Sorting Layer</code>: Character, <code>Order In Layer</code>: 1</li></ul></li></ul><p>&amp;emsp;&amp;emsp;最后，我们创建一个名为<code>AlienShip</code>的<code>Empty GameObject</code>，然后在<code>AlienShip</code>下创建一个名为<code>Character</code>的<code>Empty GameObject</code>。因为<code>char_enemy_alienShip</code>的<code>Sprite Mode</code>为<code>Single</code>，因此我们直接将这张图片拖拽到<code>AlienShip</code>下的<code>Character</code>下并将<code>Character</code>的<code>Scale</code>设置为<code>(0.4, 0.4, 0.4)</code>即可。</p><p><img src="https://github.com/AsanCai/BlogImage/raw/master/PotatoGloryTutorial/Essay5/Image5.png" alt="AlienShip的结构"></p><hr><h2 id="创建怪物的动画"><a href="#创建怪物的动画" class="headerlink" title="创建怪物的动画"></a>创建怪物的动画</h2><p>&amp;emsp;&amp;emsp;首先，我们在<code>Animation</code>和<code>Animator</code>文件夹下都创建一个名为<code>Enemy</code>的文件夹用于保存怪物的动画和状态机。然后打开<code>Animation Editor</code>，在<code>Hierarchy</code>窗口选中<code>AlienShip</code>创建一个名为<code>AlienShip.anim</code>的动画，并将<code>AlienShip.controller</code>移动到<code>Animator\Enemy</code>文件夹下。创建完毕后，我们为<code>AlienShip</code>添加<code>char_enemy_alienShip的Rotation</code>为动画控制属性，然后添加关键帧。</p><p><img src="https://github.com/AsanCai/BlogImage/raw/master/PotatoGloryTutorial/Essay5/Image6.png" alt="AlienShip关键帧"></p><p>&amp;emsp;&amp;emsp;为了使动画在循环播放时顺畅播放，不产生明显的停滞感，我们不能在KeyFrame处对<code>Animation Curve</code>作平滑处理，因此这里，所有的KeyFrame的<code>Tangent Type</code>我们都设置为<code>Auto</code>。</p><blockquote><p>AlienShip新增的关键帧的属性值如下（起始帧和结尾帧不变，<code>Tangent Type</code>都为Auto）：</p></blockquote><ul><li>KeyFrame 1:<ul><li><code>frame</code>: 15, <code>Rotation</code>: (0, 0, 4.8)</li><li><code>Tangent Type</code>: Auto</li></ul></li><li>KeyFrame 2:<ul><li><code>frame</code>: 30, <code>Rotation</code>: (0, 0, 0)</li><li><code>Tangent Type</code>: Auto</li></ul></li><li>KeyFrame 3:<ul><li><code>frame</code>: 45, <code>Rotation</code>: (0, 0, -4.8)</li><li><code>Tangent Type</code>: Auto</li></ul></li></ul><p>&amp;emsp;&amp;emsp;接着，我们用相同的办法创建一个名为<code>AlienSlug.anim</code>的动画。创建完毕后，我们为<code>AlienSlug</code>添加<code>enemy1-eyelid的Positon</code>和<code>enemy1-tail的Scale</code>这两个动画控制属性，然后添加关键帧。</p><p><img src="https://github.com/AsanCai/BlogImage/raw/master/PotatoGloryTutorial/Essay5/Image7.png" alt="AlienSlug关键帧"></p><p>&amp;emsp;&amp;emsp;因为在眨眼和伸缩尾巴时，有短暂的停顿并不会影响动画效果，因此，所有的KeyFrame的<code>Tangent Type</code>我们都使用默认的<code>Clamped Auto</code>，以确保能产生一条光滑的曲线。</p><blockquote><p>AlienSlug新增的关键帧的属性值如下（起始帧和结尾帧不变。<code>Tangent Type</code>都为Clamped Auto ）：</p></blockquote><ul><li>KeyFrame 1:<ul><li><code>frame</code>: 20</li><li><code>enemy1-tail的Scale</code>: (1.6, 1, 1)</li><li><code>Tangent Type</code>: Clamped Auto</li></ul></li><li>KeyFrame 2:<ul><li><code>frame</code>: 30</li><li><code>enemy1-eyelid的Rotation</code>: (-0.07, 1.31, 0)</li><li><code>Tangent Type</code>: Clamped Auto</li></ul></li></ul><hr><h2 id="创建角色动画"><a href="#创建角色动画" class="headerlink" title="创建角色动画"></a>创建角色动画</h2><p>&amp;emsp;&amp;emsp;角色的动画比较复杂，除了静止时的<code>Idle</code>动画，我们还需要创建行走时的<code>Walk</code>、跳跃时的<code>Jump</code>、射击时的<code>Shoot</code>和死亡时的<code>Death</code>。我们先从最简单的<code>Idle</code>动画做起。</p><p>&amp;emsp;&amp;emsp;首先，我们在<code>Animation</code>和<code>Animator</code>文件夹下都创建一个名为<code>Player</code>的文件夹用于保存角色的动画和状态机。然后打开<code>Animation Editor</code>，在<code>Hierarchy</code>窗口选中<code>Player</code>创建一个名为<code>Idle.anim</code>的动画，并将<code>Player.controller</code>移动到<code>Animator\Player</code>文件夹下。创建完毕之后，我们为<code>Idle</code>动画添加<code>body的Position</code>属性作为动画控制属性，然后添加关键帧。因为在<code>Idle</code>动画中，我们只在<code>第30帧处</code>添加了一个关键帧，切所有关键帧的<code>Tangent Type</code>为默认的<code>Clamped Auto</code>，所以添加的关键帧属性值参见下图。</p><p><img src="https://github.com/AsanCai/BlogImage/raw/master/PotatoGloryTutorial/Essay5/Image8.png" alt="Idle动画添加的关键帧"></p><p>&amp;emsp;&amp;emsp;创建完毕后，我们点击<code>Create New Clip</code>，创建一个名为<code>Walk.anim</code>的动画并将其保存在<code>Animation\Player</code>文件夹下。</p><p><img src="https://github.com/AsanCai/BlogImage/raw/master/PotatoGloryTutorial/Essay5/Image9.png" alt="创建新动画"></p><p>&amp;emsp;&amp;emsp;创建完毕之后，我们为<code>Walk</code>动画添加动画控制属性和关键帧。因为该动画精细程度要求不高，我们可以先<code>将采样率从60减少到5</code>，再添加动画控制属性。具体添加的动画控制属性见下图。</p><p><img src="https://github.com/AsanCai/BlogImage/raw/master/PotatoGloryTutorial/Essay5/Image10.png" alt="Walk动画的控制属性"></p><blockquote><p>Walk动画新增的关键帧的属性值如下（起始帧和结尾帧不变，<code>Tangent Type</code>都为Free Smooth + Flat）：</p></blockquote><ul><li>KeyFrame 1:<ul><li><code>frame</code>: 1</li><li><code>leftFoot的Position</code>: (0.15, -1.87, 0)</li><li><code>tache的Rotation</code>:    (0, 0, -3.25)</li><li><code>Tangent Type</code>: Free Smooth + Flat</li></ul></li><li>KeyFrame 2:<ul><li><code>frame</code>: 2</li><li><code>bazooka的Position</code>:      (0.33, 0.47, 0)</li><li><code>leftFoot的Position</code>:     (-0.56, -1.8, 0)</li><li><code>leftFoot的Rotation</code>:     (0, 0, -59.081)</li><li><code>leftHand的Position</code>:     (1.033, 0.018, 0)</li><li><code>rightFoot的Position</code>:    (0.56, -1.8, 0)</li><li><code>rightFoot的Rotation</code>:    (0, 0, 37.936)</li><li><code>rightHand的Position</code>:    (-1.07, -0.386, 0)</li><li><code>Tangent Type</code>: Free Smooth + Flat</li></ul></li><li>KeyFrame 3:<ul><li><code>frame</code>: 3</li><li><code>leftFoot的Position</code>: (0.15, -1.87, 0)</li><li><code>Tangent Type</code>: Free Smooth + Flat</li></ul></li></ul><p>&amp;emsp;&amp;emsp;接着，我们继续创建一个名为<code>Jump.anim</code>的动画并将其保存在<code>Animation\Player</code>文件夹下。创建完毕之后，我们为<code>Jump</code>动画添加动画控制属性和关键帧。因为该动画精细程度要求不高，我们可以，我们可以先<code>将采样率从60减少到10</code>，再添加动画控制属性。具体添加的动画控制属性见下图。</p><p><img src="https://github.com/AsanCai/BlogImage/raw/master/PotatoGloryTutorial/Essay5/Image11.png" alt="Jump动画的控制属性"></p><blockquote><p>Jump动画修改的关键帧的属性值如下：</p></blockquote><ul><li>KeyFrame 0:<ul><li><code>frame</code>: 0</li><li><code>hat的Position</code>:          (-0.5, 1.6, 0)</li><li><code>leftFoot的Position</code>:     (1.07, -1.89, 0)</li><li><code>rightFoot的Position</code>:    (-0.73, -2.11, 0)</li><li><code>rightHand的Position</code>:    (-1.59, -0.58, 0)</li><li><code>Tangent Type</code>: Free Smooth + Flat</li></ul></li><li>KeyFrame 1:<ul><li><code>frame</code>: 从10移动到5，表示动画只有0.5s</li><li><code>Tangent Type</code>: Free Smooth + Flat</li></ul></li></ul><p>&amp;emsp;&amp;emsp;设置好<code>Jump</code>动画的关键帧之后，我们继续创建一个名为<code>Shoot.anim</code>的动画并将其保存在<code>Animation\Player</code>文件夹下。创建完毕之后，我们为<code>Shoot</code>动画添加动画控制属性和关键帧。<code>Shoot</code>动画所有关键帧的<code>Tangent Type</code>都为<code>Free Smooth + Flat</code>，因为<code>Shoot</code>动画只在<code>第30帧处</code>添加了一个关键帧，因此添加的关键帧属性值参见下图。</p><p><img src="https://github.com/AsanCai/BlogImage/raw/master/PotatoGloryTutorial/Essay5/Image12.png" alt="Shoot动画添加的关键帧"></p><p>&amp;emsp;&amp;emsp;最后，我们为角色创建和死亡相关的动画。首先新建<code>Death.anim</code>的动画并将其保存在<code>Animation\Player</code>文件夹下。创建完毕之后，我们为<code>Death</code>动画添加动画控制属性和关键帧。<code>Death</code>动画是最为复杂的动画，涉及到的动画控制属性较多，且创建的步骤有所不同。</p><p><img src="https://github.com/AsanCai/BlogImage/raw/master/PotatoGloryTutorial/Essay5/Image13.png" alt="Death动画的关键帧"></p><blockquote><p>Death动画的创建步骤：</p></blockquote><ol><li>添加动画控制属性</li><li>删除默认生成的结尾帧动画</li><li>添加在第10帧处的关键帧</li><li>添加在第4帧处的关键帧</li><li>添加在第15帧处的关键帧<br>修改的关键帧的属性值如下：</li></ol><ul><li>KeyFrame 1:<ul><li><code>frame</code>: 4</li><li><code>Character的Rotation</code>: (0, 0, 0)</li><li><code>Tangent Type</code>: Clamped Auto</li></ul></li><li>KeyFrame 2:<ul><li><code>frame</code>: 10</li><li><code>Character的Rotation</code>:    (0, 0, 24.075)</li><li><code>bazooka的Position</code>:      (-4.36, 0.65, 0)</li><li><code>bazooka的Rotation</code>:      (0, 0, 270.688)</li><li><code>bazooka的Scale</code>:         (0.85, 0.85, 0.85)</li><li><code>bazooka的Color</code>:         (255, 255, 255, 0)</li><li><code>hat的Position</code>:          (-1.52, 3.21, 0)</li><li><code>hat的Rotation</code>:          (0, 0, -214.424)</li><li><code>hat的Color</code>:             (255, 255, 255, 0)</li><li><code>leftEye的Position</code>:      (0.39, 0.97, 0)</li><li><code>leftFoot的Position</code>:     (1.03, -1.25, 0)</li><li><code>leftFoot的Rotation</code>:     (0, 0, 18.147)</li><li><code>leftHand的Position</code>:     (0.77, 0.56, 0)</li><li><code>rightEye的Position</code>:     (-0.11, 0.79, 0)</li><li><code>rightFoot的Position</code>:    (-0.3, -1.6, 0)</li><li><code>rightFoot的Rotation</code>:    (0, 0, 5.605)</li><li><code>rightHand的Position</code>:    (-0.86, 0.51, 0)</li><li><code>tache的Position</code>:        (0, 0.22, 0)</li><li><code>tache的Scale</code>:           (0.8, 0.8, 0.8)</li><li><code>Tangent Type</code>: Clamped Auto</li></ul></li><li>KeyFrame 3:<ul><li><code>frame</code>: 15</li><li><code>Character的Rotation</code>:    (0, 0, 65.82201)</li><li><code>Tangent Type</code>: Clamped Auto</li></ul></li></ul><p>&amp;emsp;&amp;emsp;角色死亡后，还需要一个掉落的动画。首先新建<code>Falling.anim</code>的动画并将其保存在<code>Animation\Player</code>文件夹下。创建完毕之后，我们为<code>Falling</code>动画添加动画控制属性和关键帧。需要注意的是，<code>Falling</code>动画是接着<code>Death</code>动画播放的，因此<code>Falling</code>动画的第一帧是以<code>Death</code>动画的最后一帧为基础的。此外，<code>Falling</code>涉及到的动画控制属性较多，具体有哪些动画控制属性参照下图。</p><p><img src="https://github.com/AsanCai/BlogImage/raw/master/PotatoGloryTutorial/Essay5/Image14.png" alt="Faliing动画的关键帧"></p><blockquote><p>Death动画修改的关键帧的属性值如下：</p></blockquote><ul><li>KeyFrame 0:<ul><li><code>frame</code>: 0</li><li><code>Character的Rotation</code>:    (0, 0, 65.82201)</li><li><code>bazooka的Color</code>:         (255, 255, 255, 0)</li><li><code>body的Rotation</code>:         (0, 0, 0)</li><li><code>hat的Color</code>:             (255, 255, 255, 0)</li><li><code>leftFoot的Position</code>:     (1.03, -1.25, 0)</li><li><code>leftFoot的Rotation</code>:     (0, 0, 18.147)</li><li><code>leftHand的Position</code>:     (0.77, 0.56, 0)</li><li><code>leftHand的Rotation</code>:     (0, 0, 0)</li><li><code>rightFoot的Position</code>:    (-0.3, -1.6, 0)</li><li><code>rightFoot的Rotation</code>:    (0, 0, 5.605)</li><li><code>rightHand的Position</code>:    (-0.86, 0.51, 0)</li><li><code>rightHand的Rotation</code>:    (0, 0, 0)</li><li><code>tache的Position</code>:        (0, 0.22, 0)</li><li><code>tache的Scale</code>:           (0.8, 0.8, 0.8)</li><li><code>Tangent Type</code>: Clamped Auto</li></ul></li><li>KeyFrame 1:<ul><li><code>frame</code>: 10</li><li><code>body的Rotation</code>:         (0, 0, -4.336)</li><li><code>leftFoot的Position</code>:     (1.06, -0.99, 0)</li><li><code>leftFoot的Rotation</code>:     (0, 0, 11.305)</li><li><code>leftHand的Position</code>:     (1.06, 0.9, 0)</li><li><code>leftHand的Rotation</code>:     (0, 0, 17.069)</li><li><code>rightFoot的Position</code>:    (-0.16, -1.91, 0)</li><li><code>rightFoot的Rotation</code>:    (0, 0, 6.283)</li><li><code>rightHand的Position</code>:    (-0.93, 0.28, 0)</li><li><code>rightHand的Rotation</code>:    (0, 0, -13.507)</li><li><code>Tangent Type</code>: Clamped Auto</li></ul></li><li>KeyFrame 2:<ul><li><code>frame</code>: 20</li><li><code>Character的Rotation</code>:    (0, 0, 65.82201)</li><li><code>leftFoot的Position</code>:     (1.15, -1.43, 0)</li><li><code>leftFoot的Rotation</code>:     (0, 0, -8.312)</li><li><code>leftHand的Position</code>:     (0.95, 0.17, 0)</li><li><code>leftHand的Rotation</code>:     (0, 0, -17.067)</li><li><code>rightFoot的Position</code>:    (-0.25, -1.61, 0)</li><li><code>rightFoot的Rotation</code>:    (0, 0, 19.564)</li><li><code>rightHand的Position</code>:    (-0.94, 0.59, 0)</li><li><code>rightHand的Rotation</code>:    (0, 0, 6.41)</li><li><code>Tangent Type</code>: Clamped Auto</li></ul></li></ul><hr><h2 id="制作Prefab"><a href="#制作Prefab" class="headerlink" title="制作Prefab"></a>制作Prefab</h2><p>&amp;emsp;&amp;emsp;创建完所有角色和怪物的动画之后，我们还需要做一点小小的收尾工作。首先，我们在<code>Assets</code>文件夹下都创建一个名为<code>Prefabs</code>的文件夹，然后在<code>Prefabs</code>文件夹下都创建一个名为<code>Character</code>的文件夹，用于存放角色和怪物的Prefab。接着，我们将<code>Player</code>、<code>AlienSlug</code>和<code>AlienShip</code>这三个GameObject从<code>Hierarchy</code>窗口中拖拽到<code>Project</code>下的<code>Assets\Prefabs\Character</code>文件夹中，将它们做成Prefab。</p><p><img src="https://github.com/AsanCai/BlogImage/raw/master/PotatoGloryTutorial/Essay5/Image15.png" alt="制作Prefab"></p><hr><h2 id="后言"><a href="#后言" class="headerlink" title="后言"></a>后言</h2><p>&amp;emsp;&amp;emsp;至此，创建角色和怪物动画的所有工作都已经完成。在制作动画的过程中，读者可以根据自己的喜好调整参数。最后，本篇文章所做的修改，可以在<a href="https://github.com/AsanCai/PotatoGloryTutorial">PotatoGloryTutorial</a>这个仓库的<code>essay3</code>分支下看到，读者可以clone这个仓库到本地进行查看。</p><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://docs.unity3d.com/Manual/SpriteEditor.html">Unity的Sprite Editor</a></li><li><a href="https://docs.unity3d.com/Manual/Prefabs.html">Prefabs</a></li><li><a href="https://docs.unity3d.com/Manual/CreatingPrefabs.html">Creating Prefabs</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
      <category>《土豆荣耀》</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《土豆荣耀》重构笔记（四）创建背景动画</title>
    <link href="/posts/cb0dc95d/"/>
    <url>/posts/cb0dc95d/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&amp;emsp;&amp;emsp;在2D游戏中，游戏背景常常由一张、或者多张图片构成。而图片是静态的，为了不让游戏背景那么一成不变，显得更有动感一点，我们通常需要加入一些不能与游戏内的元素发生交互的背景动画，本篇文章的主要内容，就是讲述如何使用Unity制作一些简单的2D动画。</p><hr><h2 id="Animation-Editor"><a href="#Animation-Editor" class="headerlink" title="Animation Editor"></a>Animation Editor</h2><p>&amp;emsp;&amp;emsp;Unity专门提供了<code>Animation Editor</code>让开发者来制作动画。选中Unity顶部菜单栏的<code>Window</code>，然后点击<code>Animation</code>即可打开<code>Animation</code>窗口。当然，也可以使用快捷键<code>Ctrl+6</code>打开。关于<code>Animation Editor</code>的使用，可以参考Unity的关于<code>Animation Editor</code>的介绍<a href="https://docs.unity3d.com/Manual/AnimationEditorGuide.html">Animation Window Guide</a>。</p><hr><h2 id="添加素材"><a href="#添加素材" class="headerlink" title="添加素材"></a>添加素材</h2><p>&amp;emsp;&amp;emsp;首先，我们在<code>Hierarchy</code>窗口中右击<code>Background</code>并选择<code>Create Empty</code>创建空物体<code>RiverMid</code>、<code>RiverTop</code>、<code>Clouds</code>和<code>Fog</code>，然后分别将<code>env_RiverMid</code>、<code>env_RiverTop</code>、<code>env_Clouds</code>和<code>env_Fog</code>拖到<code>RiverMid</code>、<code>RiverTop</code>、<code>Clouds</code>和<code>Fog</code>下成为其子物体。完成之后，<code>Hierarchy</code>窗口中的场景结构如图所示：</p><p><img src="https://github.com/AsanCai/BlogImage/raw/master/PotatoGloryTutorial/Essay4/Image1.png" alt="场景结构"></p><blockquote><p>它们的属性设置如下:</p></blockquote><ul><li>RiverMid: <ul><li><code>Position</code>: (0, -11, 0)</li></ul></li><li>env_RiverMid:<ul><li><code>Position</code>: (0, 0, 0)</li><li><code>Sorting Layer</code>: Background, <code>Order In Layer</code>: 4</li></ul></li><li>env_RiverMid (1):<ul><li><code>Position</code>: (48, 0, 0)</li><li><code>Sorting Layer</code>: Background, <code>Order In Layer</code>: 4</li></ul></li><li>RiverTop:<ul><li><code>Position</code>: (0, -11, 0)</li></ul></li><li>env_RiverTop:<ul><li><code>Position</code>: (0, 0, 0)</li><li><code>Sorting Layer</code>: Background, <code>Order In Layer</code>: 5</li></ul></li><li>env_RiverTop (1)<ul><li><code>Position</code>: (48, 0, 0)</li><li><code>Sorting Layer</code>: Background, <code>Order In Layer</code>: 5</li></ul></li><li>Clouds:<ul><li><code>Position</code>: (0, -2, 0)</li></ul></li><li>env_Clouds:<ul><li><code>Position</code>: (-40, 0, 0)</li><li><code>Sorting Layer</code>: Background, <code>Order In Layer</code>: 2</li></ul></li><li>env_Clouds (1):<ul><li><code>Position</code>: (0, 0, 0)</li><li><code>Sorting Layer</code>: Background, <code>Order In Layer</code>: 2</li></ul></li><li>env_Fog:<ul><li><code>Position</code>: (-48, 0, 0)</li><li><code>Sorting Layer</code>: Background, <code>Order In Layer</code>: 3</li></ul></li><li>env_Fog (1):<ul><li><code>Position</code>: (0, 0, 0)</li><li><code>Sorting Layer</code>: Background, <code>Order In Layer</code>: 3</li></ul></li></ul><hr><h2 id="创建动画的基本步骤"><a href="#创建动画的基本步骤" class="headerlink" title="创建动画的基本步骤"></a>创建动画的基本步骤</h2><p>&amp;emsp;&amp;emsp;接着，我们在<code>Project</code>窗口的<code>Assets</code>文件夹下创建一个名为<code>Animation</code>的文件夹，然后在<code>Animation</code>文件夹下再创建一个名为<code>Environment</code>的文件夹，用于保存背景动画。接着打开<code>Animation Editor</code>，在<code>Hierarchy</code>窗口中选中<code>RiverMid</code>并点击<code>Animation Editor</code>中的<code>Create</code>按钮在<code>Assets\Animation\Environment</code>文件夹下创建一个名为<code>RiverMid.anim</code>的文件。</p><p><img src="https://github.com/AsanCai/BlogImage/raw/master/PotatoGloryTutorial/Essay4/Image2.png" alt="创建动画"></p><p>&amp;emsp;&amp;emsp;创建完成后，我们可以看到在<code>Environment</code>下生成了两个文件，分别是<code>RiverMid.anim</code>和<code>RiverMid.controller</code>。<code>RiverMid.anim</code>是我们要的动画，而<code>RiverMid.controller</code>则是用于控制动画播放的状态机。当我们在使用<code>Animation Editor</code>创建动画的时候，Unity自动帮我们创建了一个以我们创建的动画作为默认动画的状态机，并将其附加在我们选择的物体上。此时在<code>Hierarchy</code>窗口下选中<code>RiverMid</code>，可以看到多了一个<code>Animator</code>组件。</p><p><img src="https://github.com/AsanCai/BlogImage/raw/master/PotatoGloryTutorial/Essay4/Image3.png" alt="RiverMid"></p><p>&amp;emsp;&amp;emsp;为了有序地管理资源文件，我们需要将<code>controller</code>文件分开存放。在<code>Assets</code>文件夹下创建一个名为<code>Animator</code>的文件夹，然后在<code>Animator</code>文件夹下再创建一个名为<code>Environment</code>的文件夹，用于保存背景动画的状态机文件。创建完成之后，在<code>Project</code>窗口中，将<code>RiverMid.controller</code>拖动到<code>Assets\Animator\Environment</code>下。<code>为了避免丢失资源引用，我们应该尽量在Unity中移动资源文件</code>。</p><p><img src="https://github.com/AsanCai/BlogImage/raw/master/PotatoGloryTutorial/Essay4/Image4.png" alt="文件结构"></p><p>&amp;emsp;&amp;emsp;接着，我们点击<code>Animation Editor</code>中的<code>Add Property</code>按钮，然后点击<code>Transform</code>下<code>Position</code>属性右边的<code>+</code>号将<code>RiverMid</code>的<code>Position</code>作为动画要改变的属性。</p><p><img src="https://github.com/AsanCai/BlogImage/raw/master/PotatoGloryTutorial/Essay4/Image5.png" alt="选择动画控制的属性"></p><p>&amp;emsp;&amp;emsp;选择好动画控制的属性之后，我们开始录制动画。首先，我们使用鼠标右击<code>Animation Editor</code>生成的默认结尾帧，然后选择<code>Delete Keys</code>删除该帧。此外，我们还需要鼠标单击初始帧，并使用鼠标右击选择该关键帧的<code>切线类型</code>为<code>Auto</code>。关于几种<code>切线类型</code>的详细说明，详见<a href="https://asancai.github.io/game-development/Unity-Animation/">Unity的Animation</a>。</p><p>&amp;emsp;&amp;emsp;接着，点击<code>Animation Editor</code>左上角的<code>圆形按钮</code>进入录制模式。然后，我们在右边方框内输入<code>1500</code>后按回车键确认，表示我们想在<code>第1500帧</code>处记录一个关键帧。此时，因为<code>Sample</code>的值为<code>60</code>，因此我们可以认为经过60帧以后，就经过了1s。<code>当然，我们这里也可以使用鼠标左右拖动来选择我们要在哪里记录关键帧</code>。最后，我们设置该关键帧下<code>RiverMid</code>的<code>Position</code>属性的值为<code>(-24, 0, 0)</code>。设置完成后，可以看到<code>Animation Editor</code>在<code>第25秒</code>处生成了一个关键帧。点击<code>Animation Editor</code>的<code>三角形按钮</code>可以播放我们生成的动画以便预览效果。</p><p><img src="https://github.com/AsanCai/BlogImage/raw/master/PotatoGloryTutorial/Essay4/Image6.png" alt="录制关键帧"></p><hr><h2 id="创建剩下的动画"><a href="#创建剩下的动画" class="headerlink" title="创建剩下的动画"></a>创建剩下的动画</h2><p>&amp;emsp;&amp;emsp;创建好<code>RiverMid</code>的动画之后，我们使用相同的步骤为<code>RiverTop</code>、<code>Clouds</code>和<code>Fog</code>创建动画。</p><blockquote><p><code>RiverTop</code>、<code>Clouds</code>和<code>Fog</code>的动画关键帧信息如下：</p></blockquote><ul><li>RiverTop<ul><li><code>关键帧位置</code>: 0, <code>Position</code>: (0, -11, 0), <code>切点类型</code>: Auto</li><li><code>关键帧位置</code>: 2500, <code>Position</code>: (-24, -11, 0), <code>切点类型</code>: Auto</li></ul></li><li>Clouds<ul><li><code>关键帧位置</code>: 0, <code>Position</code>: (0, -2, 0), <code>切点类型</code>: Auto</li><li><code>关键帧位置</code>: 3600, <code>Position</code>: (40, -2, 0), <code>切点类型</code>: Auto</li></ul></li><li>Fog<ul><li><code>关键帧位置</code>: 0, <code>Position</code>: (0, 1.5, 0), <code>切点类型</code>: Auto</li><li><code>关键帧位置</code>: 7200, <code>Position</code>: (48, 1.5, 0), <code>切点类型</code>: Auto</li></ul></li></ul><hr><h2 id="后言"><a href="#后言" class="headerlink" title="后言"></a>后言</h2><p>&amp;emsp;&amp;emsp;所有的动画都创建完成之后，点击Unity编辑器界面的<code>Play</code>按钮运行游戏，可以看到动画在游戏中实际播放的效果。如果觉得效果不符合自己想要的，读者可以返回上一步设置自定义的值。最后，本篇文章所做的修改，可以在<a href="https://github.com/AsanCai/PotatoGloryTutorial">PotatoGloryTutorial</a>这个仓库的<code>essay2</code>分支下看到，读者可以clone这个仓库到本地进行查看。</p><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://docs.unity3d.com/Manual/AnimationEditorGuide.html">Animation Window Guide</a></li><li><a href="https://docs.unity3d.com/Manual/animeditor-UsingAnimationEditor.html">Using the Animation view</a></li><li><a href="https://docs.unity3d.com/Manual/animeditor-CreatingANewAnimationClip.html">Creating a New Animation Clip</a></li><li><a href="https://docs.unity3d.com/Manual/animeditor-AnimatingAGameObject.html">Animating a GameObject</a></li><li><a href="https://asancai.github.io/game-development/Unity-Animation/">Unity的Animation</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
      <category>《土豆荣耀》</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《土豆荣耀》重构笔记（三）创建游戏场景</title>
    <link href="/posts/fe471202/"/>
    <url>/posts/fe471202/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&amp;emsp;&amp;emsp;为了记录重构笔记的进度，我在Github上创建了一个名为<a href="https://github.com/AsanCai/PotatoGloryTutorial">PotatoGloryTutorial</a>的Repository，里面的每个分支都记录着对应文章所做的修改。因为篇幅有限，很多具体的细节不会一一赘述，本篇文章对应的分支为<code>essay1</code>，读者可以将<a href="https://github.com/AsanCai/PotatoGloryTutorial">PotatoGloryTutorial</a>这个仓库clone至本地之后切换到<code>essay1</code>分支，以便查看具体的细节。</p><hr><h2 id="导入资源"><a href="#导入资源" class="headerlink" title="导入资源"></a>导入资源</h2><p>&amp;emsp;&amp;emsp;打开Unity（2017.3.0f3）,点击<code>New</code>，创建一个名为<code>PotatoGloryTutorial</code>的<code>2D</code>项目：</p><p><img src="https://github.com/AsanCai/BlogImage/raw/master/PotatoGloryTutorial/Essay3/Image1.png" alt="创建项目"></p><p>&amp;emsp;&amp;emsp;打开Unity界面之后，我们需要导入资源。前面提到过，本项目大部分素材来源于Unity Assets Store上一个免费的package <a href="https://assetstore.unity.com/packages/essentials/tutorial-projects/2d-platformer-11228">2D Platformer</a>，因此可以直接在<code>Asset Store</code>上Download并Import。</p><p><img src="https://github.com/AsanCai/BlogImage/raw/master/PotatoGloryTutorial/Essay3/Image2.png" alt="Asset Store"></p><p>&amp;emsp;&amp;emsp;需要注意的是，<code>2D Platformer</code>是一个完整的项目，里面还包含了很多脚本，里面有很多写得很不错的代码，有兴趣的读者可以直接下载下来参考。此外，<code>2D Platformer</code>里面还包含已经制作好的<code>Animation</code>和<code>Prefab</code>，不想浪费时间自己从头制作的读者可以直接下载<code>2D Platformer</code>后删除脚本文件，直接使用<code>2D Platformer</code>提供的资源。</p><p>&amp;emsp;&amp;emsp;在这里，因为本项目的脚本不完全和<code>2D Platformer</code>一致，所以我们不直接下载完整的项目，而是导入我预先准备好的资源<a href="https://github.com/AsanCai/Download/raw/master/package/PotatoGlory.unitypackage">package</a>。下载完成之后，在Unity上方的菜单栏找到<code>Assets</code>选项，点击<code>Assets</code>-&gt;<code>Import Package</code>-&gt;<code>Custom Package...</code>，然后找到自己下载好的<code>PotatoGlory.unitypackage</code>，然后点击<code>Import</code>导入全部资源。</p><p><img src="https://github.com/AsanCai/BlogImage/raw/master/PotatoGloryTutorial/Essay3/Image3.png" alt="导入资源"></p><hr><h2 id="调整Unity布局"><a href="#调整Unity布局" class="headerlink" title="调整Unity布局"></a>调整Unity布局</h2><p>&amp;emsp;&amp;emsp;在正式开始搭建游戏背景之前，为了提高开发的效率，我们还需要调整一下Unity界面的布局。点击右上角的<code>Layout</code>按钮，会出现一个下拉菜单。</p><p><img src="https://github.com/AsanCai/BlogImage/raw/master/PotatoGloryTutorial/Essay3/Image4.png" alt="Layout"></p><p>&amp;emsp;&amp;emsp;个人最喜欢的布局方案是<code>2 by 3</code>，大家可以根据自己的喜好进行选择。选择<code>2 by 3</code>方案之后，我们还需要做一些小调整，将<code>Project</code>窗口拖动到<code>Hierarchy</code>窗口下方。当然，这个调整只是出于我个人的习惯，读者可以选择不调整，也可以根据自己的喜好调整其他窗口，调整的方法都是<code>鼠标单击窗口上方的选项卡，然后按住不放进行拖动</code>。</p><p>&amp;emsp;&amp;emsp;调整完成之后，再次点击<code>Layout</code>，选择<code>Save Layout...</code>，将其命名为<code>Favorite</code>，然后点击<code>Save</code>。这样，我们就新建了一个名为<code>Favorite</code>的布局，以后就可以通过选择<code>Favorite</code>来快速恢复到我们现在调整的布局了。我们最终调整完成的布局如下所示：</p><p><img src="https://github.com/AsanCai/BlogImage/raw/master/PotatoGloryTutorial/Essay3/Image5.png" alt="调整后的布局"></p><hr><h2 id="创建游戏场景"><a href="#创建游戏场景" class="headerlink" title="创建游戏场景"></a>创建游戏场景</h2><p>&amp;emsp;&amp;emsp;做好前期准备之后，终于进入我们今天的主题——创建游戏场景了。首先，我们右击在<code>Project</code>窗口下的<code>Assets</code>文件夹，然后选择<code>Create</code>-&gt;<code>Folder</code>来创建一个名为<code>Scenes</code>的文件夹，用于保存我们的游戏场景。然后直接按快捷键<code>Ctrl + S</code>，将Unity默认打开的<code>Untitled</code>场景保存到<code>Scenes</code>文件夹下，并将其命名为<code>SinglePlayerGameScene.unity</code>。</p><p><img src="https://github.com/AsanCai/BlogImage/raw/master/PotatoGloryTutorial/Essay3/Image6.png" alt="创建游戏场景"></p><hr><h2 id="设置Aspect"><a href="#设置Aspect" class="headerlink" title="设置Aspect"></a>设置Aspect</h2><p>&amp;emsp;&amp;emsp;接着，因为我们最后的目标是做成一个Android手机游戏，所以我们还需要<code>Game</code>窗口下设置一个<code>Aspect</code>来预览在手机上运行的效果。这里，我们创建一个固定分辨率为<code>1920x1080</code>的Aspect，并将其命名为<code>Android</code>。</p><p><img src="https://github.com/AsanCai/BlogImage/raw/master/PotatoGloryTutorial/Essay3/Image7.png" alt="设置Aspect"></p><hr><h2 id="放置Sprite"><a href="#放置Sprite" class="headerlink" title="放置Sprite"></a>放置Sprite</h2><p>&amp;emsp;&amp;emsp;创建好<code>Aspect</code>之后，我们将<code>Sprites\Environment</code>目录下的图片<code>env_bg</code>从<code>Project</code>窗口直接拖动到<code>Hierarchy</code>窗口里，可以看到在场景中出现了一张天空的背景图，但在<code>Game</code>窗口中，这张图片的可见范围很小。我们需要调大<code>Main Camera</code>的<code>Size</code>，使其能看到更大的范围，这里，我们将其设置为<code>11</code>。</p><p><img src="https://github.com/AsanCai/BlogImage/raw/master/PotatoGloryTutorial/Essay3/Image8.png" alt="调整Main Camera"></p><p>&amp;emsp;&amp;emsp;调整完Camere之后，我们继续通过拖拽往场景里面添加其他的素材。但奇怪的是，在添加素材的过程中，有可能出现后面拖进去的素材在<code>Scene</code>和<code>Game</code>窗口里看不到的情况。这是因为在Unity里，摄像机按照<code>从远到近</code>的顺序来渲染物体，后渲染的物体会覆盖在先渲染的物体之上。<code>而对于在摄像机投影方向上距离摄像机距离一样的物体，它们的渲染顺序是随机的</code>。</p><p>&amp;emsp;&amp;emsp;想要保证<code>物体A</code>在<code>物体B</code>之后渲染，我们可以设置<code>物体B</code>在摄像机投影方向上与摄像机的距离比<code>物体A</code>近。在Unity的2D项目中，默认使用的是<code>Orthographic Camera</code>，也就是正交摄像机，其投影方向为<code>Z轴的正方向</code>，默认垂直于屏幕。因此，我们只需要按照物体的前后关系来设置它们的z坐标的大小即可。但如果这样做，当场景中的物体增多时往往会出现记不清其他物体坐标的问题，不仅难以管理，而且效率也低。</p><hr><h2 id="Sorting-Layer"><a href="#Sorting-Layer" class="headerlink" title="Sorting Layer"></a>Sorting Layer</h2><p>&amp;emsp;&amp;emsp;为了解决这一问题，Unity在<a href="https://docs.unity3d.com/Manual/class-SpriteRenderer.html">Sprite Renderer组件</a>中提供了<code>Sorting Layer</code>和<code>Order In Layer</code>属性让我们使用。Unity在渲染Sprite时，首先根据按照<code>Sorting Layer</code>的渲染顺序来渲染Sprite，如果两个Sprite处于相同<code>Sorting Layer</code>，那么就按照它们<code>Order In Layer</code>的值<code>从小到大</code>进行渲染。倘若两个Sprite<code>Order In Layer</code>的值也相同，再按照在摄像机投影方向上距离摄像机距离的距离远近、也就是Z轴上的坐标来渲染。</p><p>&amp;emsp;&amp;emsp;选中场景中的<code>env_bg</code>，然后在<code>Inspector</code>窗口，点击<code>Add Sorting Layer...</code>。打开Sorting Layer管理界面后，点击右下角的<code>+</code>创建<code>Background</code>和<code>Foreground</code>两个<code>Sorting Layer</code>，并用鼠标选中<code>Background</code>将其拖到<code>Default</code>上方。创建完毕之后，已有的<code>Sorting Layer</code>如下所示：</p><p><img src="https://github.com/AsanCai/BlogImage/raw/master/PotatoGloryTutorial/Essay3/Image9.png" alt="设置Sorting Layer"></p><p>&amp;emsp;&amp;emsp;在Unity中，<code>Sorting Layer</code>的渲染顺序为从上到下渲染，也就是说，Unity会先渲染所有<code>Sorting Layer</code>为<code>Backgroung</code>的Sprite，然后绘制所有<code>Sorting Layer</code>为<code>Default</code>的Sprite，最后绘制所有<code>Sorting Layer</code>为<code>Foreground</code>的Sprite。</p><blockquote><p>了解了<code>Sorting Layer</code>的使用之后，我们往场景中添加剩下的所有Sprite，场景中所有的Sprite及其属性如下：</p></blockquote><ul><li>env_bg:<ul><li><code>Position</code>: (0, 0, 0)</li><li><code>Sorting Layer</code>：Backgroung, <code>Order In Layer</code>: 0</li></ul></li><li>env_cloudTop:<ul><li><code>Position</code>: (0, 0, 0)</li><li><code>Sorting Layer</code>：Backgroung, <code>Order In Layer</code>: 1</li></ul></li><li>env_BigBen:<ul><li><code>Position</code>: (0, 0, 0)</li><li><code>Sorting Layer</code>：Backgroung, <code>Order In Layer</code>: 1</li></ul></li><li>env_Bank:<ul><li><code>Position</code>: (0, 0, 0)</li><li><code>Sorting Layer</code>：Backgroung, <code>Order In Layer</code>: 2</li></ul></li><li>env_RiverBase: <ul><li><code>Position</code>: (0, -11, 0)，Scale(2, 1, 1)</li><li><code>Sorting Layer</code>: Backgroung, <code>Order In Layer</code>: 3</li></ul></li><li>env_TowerFull:<ul><li><code>Position</code>: (-22, 0, 0), Scale(1, 1, 1)</li><li><code>Sorting Layer</code>: Foreground, <code>Order In Layer</code>: 0</li></ul></li><li>env_TowerFull (1):<ul><li><code>Position</code>: (22, 0, 0), Scale(-1, 1, 1)</li><li><code>Sorting Layer</code>: Foreground, <code>Order In Layer</code>: 0</li></ul></li><li>env_PlatformBridge:<ul><li><code>Position</code>: (-12.3, -11.2, 0), Scale(1, 1, 1)</li><li><code>Sorting Layer</code>: Foreground, <code>Order In Layer</code>: 1</li></ul></li><li>env_PlatformBridge (1):<ul><li><code>Position</code>: (12.3, -11.2, 0), Scale(-1, 1, 1)</li><li><code>Sorting Layer</code>: Foreground, <code>Order In Layer</code>: 1</li></ul></li><li>env_PlatformTop:<ul><li><code>Position</code>: (-14.4, 0, 0), Scale(1, 1, 1)</li><li><code>Sorting Layer</code>: Foreground, <code>Order In Layer</code>: 1</li></ul></li><li>env_PlatformTop (1):<ul><li><code>Position</code>: (14.4, 0, 0), Scale(-1, 1, 1)</li><li><code>Sorting Layer</code>: Foreground, <code>Order In Layer</code>: 1</li></ul></li><li>env_PlatformUfo:<ul><li><code>Position</code>: (0, -4.62, 0)</li><li><code>Sorting Layer</code>: Foreground, <code>Order In Layer</code>: 2</li></ul></li><li>env_UfoLegs:<ul><li><code>Position</code>: (0, -1.44, 0)</li><li><code>Sorting Layer</code>: Foreground, <code>Order In Layer</code>: 2</li></ul></li></ul><hr><h2 id="组织场景中的物体"><a href="#组织场景中的物体" class="headerlink" title="组织场景中的物体"></a>组织场景中的物体</h2><p>&amp;emsp;&amp;emsp;将所有的Sprite添加进去之后，我们发现场景中的物体太多，不太雅观。为了方便管理，我们可以使用<code>Empty GameObject</code>来组织场景中的物体。在Unity中，<code>Empty GameObject</code>只有<code>Transform</code>这一个组件，可以当作空节点用来组织、管理其他的物体。</p><p>&amp;emsp;&amp;emsp;在<code>Hierarchy</code>窗口右击鼠标，选择<code>Create Empty</code>，然后在<code>Inspector</code>窗口将其命名为<code>Background</code>，并<code>Reset</code>其<code>Transform</code>组件的属性值。</p><p><img src="https://github.com/AsanCai/BlogImage/raw/master/PotatoGloryTutorial/Essay3/Image10.png" alt="设置Empty GameObject属性"></p><p>&amp;emsp;&amp;emsp;接着我们用同样的方法，创建另外一个命名为<code>Foreground</code>的<code>Empty GameObject</code>，并重置其<code>Transform</code>组件的属性值。创建完毕之后，我们在<code>Hierarchy</code>窗口中，将<code>Sorting Layer</code>为<code>Background</code>的物体拖到空物体<code>Background</code>下成为其子物体，将<code>Sorting Layer</code>为<code>Foreground</code>的物体拖到空物体<code>Foreground</code>下成为其子物体，最后，<code>Hierarchy</code>窗口的结构如图所示：</p><p><img src="https://github.com/AsanCai/BlogImage/raw/master/PotatoGloryTutorial/Essay3/Image11.png" alt="场景物体组织结构"></p><hr><h2 id="后言"><a href="#后言" class="headerlink" title="后言"></a>后言</h2><p>&amp;emsp;&amp;emsp;因为这是本系列第一篇讲解项目具体制作过程的文章，有些地方写得比较详细，也用了比较多的截图来说明一些基础操作。在后面的文章中，对于一些已经介绍过、或者比较简单的基础操作，将会使用文字描述。最后，本篇文章所做的修改，可以在<a href="https://github.com/AsanCai/PotatoGloryTutorial">PotatoGloryTutorial</a>这个仓库的<code>essay1</code>分支下看到，读者可以clone这个仓库到本地进行查看。</p><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://docs.unity3d.com/Manual/class-SpriteRenderer.html">Unity的Sprite Renderer组件</a></li><li><a href="https://docs.unity3d.com/Manual/class-TagManager.html">Sorting Layer</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
      <category>《土豆荣耀》</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《土豆荣耀》重构笔记（二）Unity的安装以及安卓环境的配置</title>
    <link href="/posts/a2a8cd9/"/>
    <url>/posts/a2a8cd9/</url>
    
    <content type="html"><![CDATA[<h2 id="安装Unity"><a href="#安装Unity" class="headerlink" title="安装Unity"></a>安装Unity</h2><p>&amp;emsp;&amp;emsp;本项目使用Unity 2017.3.0f3进行开发，首先在Unity官网上下载<a href="https://unity3d.com/cn/get-unity/download?thank-you=update&download_nid=49126&os=Win">安装包</a>，然后点击下载好的exe文件，选择需要下载的组件。</p><p><img src="https://github.com/AsanCai/BlogImage/raw/master/PotatoGloryTutorial/Essay2/Image1.png" alt="组件"></p><blockquote><p>模块说明：</p></blockquote><ul><li><code>Unity X.X.X</code>这个组件包含了Unity引擎的可视化编辑器面板，如果之前没有安装过，则必须勾选安装</li><li><code>MonoDevelop / Unity Debugger</code>这个组件包含了IDE<code>MonoDevelop</code>和<code>断点调试</code>模块，建议下载</li><li><code>Microsoft Visual Studio Community X</code>如果电脑上已经安装了Visual Studio，那么不会出现这个选项。总所周知，Visual Studio虽然是个很强大的IDE，但它体量太大，所以不建议下载</li><li><code>Documentation</code>这个组件包含了Unity的离线文档，由于在线文档打开时经常比较慢，建议下载</li><li><code>Standard Assets</code>这个组件包含了Unity提供的标准资源库，里面有不少不错的插件和资源，建议下载</li><li><code>Example Project</code>这个组件包含了Unity提供的示例项目，新手建议下载</li><li>剩下的组件都是各个发布平台的Build Support，需要在哪个平台发布就下哪个support, 由于我们本次想开发安卓手机上的游戏，因此我们勾选<code>Android Build Support</code></li></ul><p>&amp;emsp;&amp;emsp;选择好安装组件之后，选择一个合适的安装路径，一路next，等待一段时间之后完成安装。<code>下面部分是关于如何配置安卓环境的介绍，如果暂时不感兴趣，可以跳过先看其他的，等到最终打包时再回头配置环境</code>。</p><hr><h2 id="下载Android-SDK-Tools"><a href="#下载Android-SDK-Tools" class="headerlink" title="下载Android SDK Tools"></a>下载Android SDK Tools</h2><p>&amp;emsp;&amp;emsp;Android SDK相当于安卓机器的操作系统，Unity想要导出Android应用，就需要先下载Android SDK。Android SDK需要通过Android SDK Manager安装，如果嫌麻烦，可以<a href="https://developer.android.com/studio/?hl=zh-cn#downloads">下载Android Studio</a>，使用里面集成的Android SDK Manager来安装，缺点是<code>Android Studio</code>比较大。如果不想安装Android Studio，也可以在<a href="https://developer.android.com/studio/releases/sdk-tools">官网</a>上下载Android SDK Tools。</p><p>&amp;emsp;&amp;emsp;这里，我们选择<a href="https://dl.google.com/android/installer_r24.4.1-windows.exe?utm_source=androiddevtools&utm_medium=website">下载Android SDK Tools</a>，点击下载好的exe文件开始安装。因为<code>Android SDK Tools</code>的安装需要JDK，所以如果电脑上没有配置JDK，将会安装失败。</p><p><img src="https://github.com/AsanCai/BlogImage/raw/master/PotatoGloryTutorial/Essay2/Image2.png" alt="安装失败界面"></p><hr><h2 id="安装JDK"><a href="#安装JDK" class="headerlink" title="安装JDK"></a>安装JDK</h2><p>&amp;emsp;&amp;emsp;<code>JDK（Java Development Kit）</code>继承了Java语言的各种类库，提供了Java的开发环境和运行环境。因为Android Tools的安装依赖JDK，因此我们先安装JDK。需要注意的是，如果JDK版本太高，和Android SDK使用的版本兼容不了，在构建游戏时有可能会报错。我使用的JDK版本是<code>JDK 8u192</code>，官网目前提供目前提供的可下载版本为<a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html">JDK 8u191和JDk 8u192</a>。JDK 8应该都能正常构建，如果该版本JDK确实有问题，可以卸载JDK，然后使用其他版本的JDK重新安装一次。</p><p>&amp;emsp;&amp;emsp;打开<a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html">JDK官网下载地址</a>下载JDK，这里要注意，我们只需要JDK，不选择带有<code>Demos and Samples</code>的版本。先点击接受License，然后点击下方的下载链接开始下载。</p><p><img src="https://github.com/AsanCai/BlogImage/raw/master/PotatoGloryTutorial/Essay2/Image3.png" alt="下载JDK"></p><p>&amp;emsp;&amp;emsp;下载完成之后，点击下载好的exe文件，选择JDK安装路径之后开始安装。<code>需要注意的是，安装完JDK之后，会提示你安装JRE，建议将JRE安装在JDK安装路径的同级目录下</code>。如图所示，我分别将JDK和JRE分别安装在<code>文件夹JDK</code>和<code>文件夹JRE</code>中。</p><p><img src="https://github.com/AsanCai/BlogImage/raw/master/PotatoGloryTutorial/Essay2/Image4.png" alt="安装目录"></p><hr><h2 id="配置JDK"><a href="#配置JDK" class="headerlink" title="配置JDK"></a>配置JDK</h2><p>&amp;emsp;&amp;emsp;安装好JDK之后，我们还需要为JDK配置系统变量。</p><blockquote><p>配置的具体步骤如下：</p></blockquote><ol><li>在电脑搜索框搜索<code>高级系统设置</code>，然后点击<code>环境变量</code>打开环境变量设置面板</li><li>在<code>系统变量</code>框，新建一个变量名为<code>JAVA_HOME</code>的变量，然后点击<code>浏览目录</code>选择JDK安装路径，或者直接将JDK安装路径填入<code>变量值</code>框</li><li>在<code>系统变量</code>框，新建一个变量，先在<code>变量名</code>框填入<code>CLASSPATH</code>，然后在<code>变量值</code>框里填入<code>.;%JAVA_HOME%\lib;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;</code>，需要注意最前面有个<code>.</code></li><li>保存退出之后，打开cmd窗口，输入<code>java -version</code>，若输出版本信息则配置成功，若没有则配置失败，请返回前面的步骤进行检查</li></ol><p><img src="https://github.com/AsanCai/BlogImage/raw/master/PotatoGloryTutorial/Essay2/Image5.png" alt="系统变量设置"></p><hr><h2 id="安装Android-SDK"><a href="#安装Android-SDK" class="headerlink" title="安装Android SDK"></a>安装Android SDK</h2><p>&amp;emsp;&amp;emsp;安装配置好JDK之后，我们继续前面Android SDK Tools的安装。安装完成之后，打开安装目录，点击<code>SDK Manager.exe</code>打开Android SDK Manager下载SDK。</p><blockquote><p>在<a href="https://stuff.mit.edu/afs/sipb/project/android/docs/sdk/exploring.html">官方指导</a>中，在SDK Manager中需要安装以下内容：</p></blockquote><ul><li>Tools 目录下选择:<ul><li>Android SDK Tools（Android SDK 的一个组件，包括一套完整的 Android 开发和调试工具）</li><li>Android SDK Platform-tools（Android SDK 的一个组件，内容主要包含与 Android 移动平台交互的工具，例如用来和应用通信的adb和查看分析系统运行中的所有数据的systrace等）</li><li>Android SDK Build-tools (选择最高版本)</li></ul></li><li>Android X.X 文件夹选择:<ul><li>SDK Platform</li><li>ARM EABI v7a System Image（模拟器需要，非必须）</li><li>Sources for Android SDK（源代码，非必须）</li></ul></li><li>Extras目录下：<ul><li>Android Support Repository</li><li>Google USB Driver（在Windows进行ADB调试时需要用到）</li></ul></li></ul><p><img src="https://github.com/AsanCai/BlogImage/raw/master/PotatoGloryTutorial/Essay2/Image6.png" alt="下载的项目"></p><hr><h2 id="配置NDK"><a href="#配置NDK" class="headerlink" title="配置NDK"></a>配置NDK</h2><p>&amp;emsp;&amp;emsp;<code>NDK（Native Development Kit）</code>是一系列工具的集合，帮助开发者快速开发C（或C++）的动态库，并能自动将<code>so文件</code>和Java应用一起打包成apk。Unity为<code>Android平台</code>提供了两种<code>脚本后端（Scripting backend）</code>来编译和执行C#脚本，一种是传统的<code>Mono</code>，另外一种则是比较新的<code>IL2CPP</code>。如果我们在打包时选择<code>IL2CPP</code>作为执行C#脚本的脚本后端，那么我们就要下载并配置相应的NDK版本。在这里，我们选择使用<code>Mono</code>作为脚本后端，因此暂时不需要下载并配置NDK。关于<code>IL2CPP</code>的详细介绍，见<a href="https://asancai.github.io/game-development/Unity-IL2CPP/">Unity的IL2CPP</a>。</p><hr><h2 id="Unity的Android环境设置"><a href="#Unity的Android环境设置" class="headerlink" title="Unity的Android环境设置"></a>Unity的Android环境设置</h2><p>&amp;emsp;&amp;emsp;Android SDK下载完成之后，我们就可以在Unity进行Android开发设置了。打开Unity，输入自己的账号密码登录，如果没有账号可以前往<a href="https://id.unity.com/en/conversations/f5cb5457-8200-4cd4-905c-2f34569a70c400ef">Unity官网</a>注册一个。登录完成之后，点击新建一个项目，打开Unity界面，然后点击<code>Edit-&gt;Preferences-&gt;External Tools</code>，在Android下的SDK、JDK项里选择Android SDK、JDK的安装路径。<code>如果不清楚Android SDK的安装路径，可以打开Android SDK Manager查看</code>。</p><blockquote><p>前面有提到NDK的用途以及现在不配置NDK的原因。如果确实想先配置NDK，也可以直接点NDK后的<code>Download</code>按钮，下载NDK安装包，然后将其解压缩到某个选定的目录。因为NDK无需安装，因此解压完成之后，点击<code>Browse</code>选择NDK的解压路径就好了。</p></blockquote><p><img src="https://github.com/AsanCai/BlogImage/raw/master/PotatoGloryTutorial/Essay2/Image7.png" alt="Unity设置"></p><hr><h2 id="切换平台"><a href="#切换平台" class="headerlink" title="切换平台"></a>切换平台</h2><p>&amp;emsp;&amp;emsp;设置完成之后，选择<code>File-&gt;Build Settings</code>，首先选择<code>Android</code>并点击<code>Switch Platform</code>切换到Android平台。在这里，我们需要大概了解一下在构建Android apk时，Unity为Android提供的两种<a href="https://docs.unity3d.com/Manual/android-BuildProcess.html">Build System</a>：<code>Internal</code>和<code>Gradle</code>。</p><blockquote><p>Unity Android Build System: </p></blockquote><ul><li><code>Internal</code>：Unity内置的Build System，仅需Android SDK支持；直接生成apk文件，不能导出其他工程项目，适用于仅使用Unity开发的工程。</li><li><code>Gradle</code>：使用<a href="https://docs.unity3d.com/Manual/android-gradle-overview.html">Gradle</a>进行构建，需要Android SDK与Gradle支持；选择Gradle之后，勾选下面的<code>Export Project</code>可以导出Android Studio工程，适用于Unity与Android交互的项目。</li></ul><p>&amp;emsp;&amp;emsp;因为我们是直接使用Unity打包apk，所以在<code>Build System</code>处我们需要选择<code>Internal</code>。</p><hr><h2 id="修改Player-Settings"><a href="#修改Player-Settings" class="headerlink" title="修改Player Settings"></a>修改Player Settings</h2><p>&amp;emsp;&amp;emsp;完成平台切换后，我们还需要进行其他设置。点击<code>Player Settings</code>按钮，在右侧<code>Inspector</code>窗口下进行设置。首先我们需要修改最上方的<code>Company Name</code>，这是apk的发布者信息，不能使用默认的<code>DefaultCompany</code>，必须修改。然后我们还需要设置下方的<code>ProductName</code>，这是apk安装到手机上之后显示的应用名称，可以使用中文。接着，我们还需要修改<code>Other Settings</code>下的<code>Package Name</code>。我们需要将默认值<code>com.Company.ProductName</code>中的<code>Company</code>修改为我们在<code>DefaultCompany</code>处填写的值，至于<code>ProductName</code>我们可以任意填写，可以填写在上面<code>ProductName</code>处填写的名称，也可以设置成别的。</p><p><img src="https://github.com/AsanCai/BlogImage/raw/master/PotatoGloryTutorial/Essay2/Image8.png" alt="构建设置"></p><p>&amp;emsp;&amp;emsp;完成上面所有的基本设置修改完成之后，点击<code>Build</code>，若构建成功，则环境设置已完成。若构建失败，则需要返回检查哪个步骤出错。</p><p><img src="https://github.com/AsanCai/BlogImage/raw/master/PotatoGloryTutorial/Essay2/Image9.png" alt="构建成功"></p><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://stuff.mit.edu/afs/sipb/project/android/docs/sdk/exploring.html">Exploring the SDK</a></li><li><a href="https://asancai.github.io/game-development/Unity-IL2CPP/">Unity的IL2CPP</a></li><li><a href="https://docs.unity3d.com/Manual/android-BuildProcess.html">Building apps for Android</a></li><li><a href="https://docs.unity3d.com/Manual/android-gradle-overview.html">Gradle for Android</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
      <category>《土豆荣耀》</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《土豆荣耀》重构笔记（一）概述</title>
    <link href="/posts/2ea56247/"/>
    <url>/posts/2ea56247/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&amp;emsp;&amp;emsp;经过两个多星期的掉坑爬坑，总算是磕磕绊绊地将《PotatoGlory》这个游戏做完了。虽然这个游戏的制作过程十分艰辛，但踩完这么多坑之后，我也收获颇丰，对Unity的使用也有了更深的理解。写这个系列博客的目的，除了是想通过重新整理这个项目，把开发过程中遇到的种种坑记录下来作为自己的学习笔记，也是想可以通过博客和大家交流分享我的学习心得。</p><hr><h2 id="游戏简介"><a href="#游戏简介" class="headerlink" title="游戏简介"></a>游戏简介</h2><p>&amp;emsp;&amp;emsp;《PotatoGlory》是一个使用Unity开发的一个2D射击小游戏，其大部分素材来源于Unity Assets Store上一个名为<a href="https://assetstore.unity.com/packages/essentials/tutorial-projects/2d-platformer-11228">2D Platformer</a>的免费package。《PotatoGlory》部分运行截图如下: </p><p><img src="https://github.com/AsanCai/BlogImage/raw/master/PotatoGloryTutorial/Essay1/Image1.png" alt="游戏菜单"></p><p><img src="https://github.com/AsanCai/BlogImage/raw/master/PotatoGloryTutorial/Essay1/Image2.png" alt="游戏场景"></p><p><img src="https://github.com/AsanCai/BlogImage/raw/master/PotatoGloryTutorial/Essay1/Image3.png" alt="游戏暂停"></p><p><img src="https://github.com/AsanCai/BlogImage/raw/master/PotatoGloryTutorial/Essay1/Image4.png" alt="游戏失败"></p><p><img src="https://github.com/AsanCai/BlogImage/raw/master/PotatoGloryTutorial/Essay1/Image5.png" alt="游戏胜利"></p><hr><h2 id="安装包"><a href="#安装包" class="headerlink" title="安装包"></a>安装包</h2><p>&amp;emsp;&amp;emsp;这里，我提供了《PotatoGlory》的<a href="https://gitee.com/AsanCai/Download/raw/master/apk/PotatoGloryTutorial.apk">apk安装包</a>供有兴趣的读者进行体验。因为是手机游戏，为了方便在手机上下载安装，我也提供了安装包的下载二维码，用手机扫描二维码即可下载。</p><p><img src="https://github.com/AsanCai/BlogImage/raw/master/PotatoGloryTutorial/Essay1/Image5.png" alt="安装包下载二维码"></p><hr><h2 id="教程内容"><a href="#教程内容" class="headerlink" title="教程内容"></a>教程内容</h2><p>&amp;emsp;&amp;emsp;本系列教程主要记录了如何从零开始一步一步制作一款2D手机游戏，包括介绍<code>如何使用Unity制作动画</code>、<code>如何使用Unity制作粒子特效</code>和<code>如何自己实现可以在手机上使用的虚拟摇杆</code>等。此外，实现某些功能之前，我会先大概讲解一下实现这些功能涉及到的知识点，例如<code>Unity的事件函数</code>、<code>Mono和IL2CPP的区别</code>等。最后，我也会在设计程序框架的时候，介绍一些我认为在开发中比较有用的设计思路，如<code>单例模式的运用</code>等。</p><p>&amp;emsp;&amp;emsp;总而言之，这个教程的特点是<code>从实战中学习知识点</code>。如果你很享受那些<code>提供手把手指导</code>、<code>提供清晰例子</code>以及<code>那些不会一下将你淹没在细节中</code>的教程，希望<code>能快速做点东西出来</code>，那么我的这个教程很可能就很适合你。</p><p>&amp;emsp;&amp;emsp;最后，我还创建了一个用于和本教程同步更新的仓库<a href="https://github.com/AsanCai/PotatoGloryTutorial">PhotoGloryTutorial</a>，每一个分支对应每一篇文章,读者可以在<a href="https://github.com/AsanCai/PotatoGloryTutorial">PhotoGloryTutorial</a>上看到每一篇文章对应的具体修改。</p><hr><h2 id="重构笔记目录"><a href="#重构笔记目录" class="headerlink" title="重构笔记目录"></a>重构笔记目录</h2><blockquote><p>目录列表: </p></blockquote><ol><li><strong>概述</strong></li><li><a href="https://asancai.github.io/tutorial/potato-glory/PotatoGloryTutorial-2/">Unity的安装以及安卓环境的配置</a></li><li><a href="https://asancai.github.io/tutorial/potato-glory/PotatoGloryTutorial-3/">创建游戏场景</a></li><li><a href="https://asancai.github.io/tutorial/potato-glory/PotatoGloryTutorial-4/">创建背景动画</a></li><li><a href="https://asancai.github.io/tutorial/potato-glory/PotatoGloryTutorial-5/">创建角色以及怪物的动画</a></li><li><a href="https://asancai.github.io/tutorial/potato-glory/PotatoGloryTutorial-6/">实现怪物的AI</a></li><li><a href="https://asancai.github.io/tutorial/potato-glory/PotatoGloryTutorial-7/">控制角色移动并添加音效</a></li><li><a href="https://asancai.github.io/tutorial/potato-glory/PotatoGloryTutorial-8/">给角色添加动画</a></li><li><a href="https://asancai.github.io/tutorial/potato-glory/PotatoGloryTutorial-9/">实现角色的血量控制功能</a></li><li><a href="https://asancai.github.io/tutorial/potato-glory/PotatoGloryTutorial-10/">实现摄像机跟随角色移动的功能</a></li><li><a href="https://asancai.github.io/tutorial/potato-glory/PotatoGloryTutorial-11/">实现发射导弹的功能</a></li><li><a href="https://asancai.github.io/tutorial/potato-glory/PotatoGloryTutorial-12/">对怪物造成伤害</a></li><li><a href="https://asancai.github.io/tutorial/potato-glory/PotatoGloryTutorial-13/">实现放置炸弹的功能</a></li><li><a href="https://asancai.github.io/tutorial/potato-glory/PotatoGloryTutorial-14/">随机生成更多的怪物</a></li><li><a href="https://asancai.github.io/tutorial/potato-glory/PotatoGloryTutorial-15/">实现角色和怪物掉入河中被销毁的功能</a></li><li><a href="https://asancai.github.io/tutorial/potato-glory/PotatoGloryTutorial-16/">随机生成不可交互物体</a></li><li><a href="https://asancai.github.io/tutorial/potato-glory/PotatoGloryTutorial-17/">随机生成可拾取道具</a></li><li><a href="https://asancai.github.io/tutorial/potato-glory/PotatoGloryTutorial-18/">使用自定义Inspector窗口拓展Generator</a></li><li><a href="https://asancai.github.io/tutorial/potato-glory/PotatoGloryTutorial-19/">使用单例模式实现游戏游戏主逻辑管理器</a></li><li><a href="https://asancai.github.io/tutorial/potato-glory/PotatoGloryTutorial-20/">为游戏场景添加UI</a></li><li><a href="https://asancai.github.io/tutorial/potato-glory/PotatoGloryTutorial-21/">制作游戏菜单场景</a></li><li><a href="https://asancai.github.io/tutorial/potato-glory/PotatoGloryTutorial-22/">实现虚拟摇杆和按钮</a></li><li><a href="https://asancai.github.io/tutorial/potato-glory/PotatoGloryTutorial-23/">打包游戏</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
      <category>《土豆荣耀》</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
